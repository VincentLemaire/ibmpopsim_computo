<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.551">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Daphné Giorgi">
<meta name="author" content="Vincent Lemaire">
<meta name="author" content="Sarah Kaakai">
<meta name="dcterms.date" content="2024-03-26">
<meta name="keywords" content="Individual-based models, stochastic simulation, population dynamics, Poisson measures, thinning method, actuarial science, insurance portfolio simulation">
<meta name="description" content="TODO">

<title>Efficient simulation of individual-based population models</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="article_files/libs/clipboard/clipboard.min.js"></script>
<script src="article_files/libs/quarto-html/quarto.js"></script>
<script src="article_files/libs/quarto-html/popper.min.js"></script>
<script src="article_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="article_files/libs/quarto-html/anchor.min.js"></script>
<link href="article_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="article_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="article_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="article_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="article_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script src="article_files/libs/quarto-contrib/pseudocode-2.4/pseudocode.min.js"></script>
<link href="article_files/libs/quarto-contrib/pseudocode-2.4/pseudocode.min.css" rel="stylesheet">
<style>

      .quarto-title-block .quarto-title-banner h1,
      .quarto-title-block .quarto-title-banner h2,
      .quarto-title-block .quarto-title-banner h3,
      .quarto-title-block .quarto-title-banner h4,
      .quarto-title-block .quarto-title-banner h5,
      .quarto-title-block .quarto-title-banner h6
      {
        color: #FFFFFF;
      }

      .quarto-title-block .quarto-title-banner {
        color: #FFFFFF;
background: #034E79;
      }
</style>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body>

<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <div class="quarto-title-block"><div><h1 class="title"><a href="https://computo.sfds.asso.fr">
        <img src="https://computo.sfds.asso.fr/assets/img/logo_notext_white.png" height="60px">
      </a> &nbsp; Efficient simulation of individual-based population models</h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> source</button></div></div>
            <p class="subtitle lead">The <code>R</code> package <code>IBMPopSim</code></p>
            <p><a href="http://creativecommons.org/licenses/by/4.0/"><img src="https://i.creativecommons.org/l/by/4.0/80x15.png" alt="Creative Commons BY License"></a>
ISSN 2824-7795</p>
            <div>
        <div class="description">
          <p>TODO</p>
        </div>
      </div>
                </div>
  </div>
    
    <div class="quarto-title-meta-author">
      <div class="quarto-title-meta-heading">Authors</div>
      <div class="quarto-title-meta-heading">Affiliations</div>
          
          <div class="quarto-title-meta-contents">
        <a href="https://perso.lpsm.paris/~giorgi/">Daphné Giorgi</a> 
      </div>
          
          <div class="quarto-title-meta-contents">
              <p class="affiliation">
                  <a href="https://www.lpsm.paris/">
                  Sorbonne Université, CNRS
                  </a>
                </p>
            </div>
            <div class="quarto-title-meta-contents">
        <a href="https://perso.lpsm.paris/~vlemaire/">Vincent Lemaire</a> <a href="https://orcid.org/0000-0002-0433-7722" class="quarto-title-author-orcid"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg=="></a>
      </div>
          
          <div class="quarto-title-meta-contents">
              <p class="affiliation">
                  <a href="https://www.lpsm.paris/">
                  Sorbonne Université, CNRS
                  </a>
                </p>
            </div>
            <div class="quarto-title-meta-contents">
        <a href="https://perso.univ-lemans.fr/~skaakai/">Sarah Kaakai</a> 
      </div>
          
          <div class="quarto-title-meta-contents">
              <p class="affiliation">
                  <a href="https://lmm.univ-lemans.fr/fr/">
                  Le Mans Université, CNRS, Institut du Risque et de l’Assurance
                  </a>
                </p>
            </div>
        </div>
                    
  <div class="quarto-title-meta">
                                
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">March 26, 2024</p>
      </div>
    </div>
                                    
      <div>
      <div class="quarto-title-meta-heading">Modified</div>
      <div class="quarto-title-meta-contents">
        <p class="date-modified">March 26, 2024</p>
      </div>
    </div>
      
                  
      <div>
      <div class="quarto-title-meta-heading">Keywords</div>
      <div class="quarto-title-meta-contents">
        <p class="date">Individual-based models, stochastic simulation, population dynamics, Poisson measures, thinning method, actuarial science, insurance portfolio simulation</p>
      </div>
    </div>
    
    <div>
      <div class="quarto-title-meta-heading">Status</div>
      <div class="quarto-title-meta-contents">
              <p class="date">draft</p>
                  </div>
    </div>

  </div>
                                                
  <div>
    <div class="abstract">
    <div class="abstract-title">Abstract</div>
      <p>The <code>R</code> Package <code>IBMPopSim</code> aims to simulate the random evolution of heterogeneous populations using stochastic Individual-Based Models (IBMs). The package enables users to simulate population evolution, in which individuals are characterized by their age and some characteristics, and the population is modified by different types of events, including births/arrivals, death/exit events, or changes of characteristics. The frequency at which an event can occur to an individual can depend on their age and characteristics, but also on the characteristics of other individuals (interactions). Such models have a wide range of applications in fields including actuarial science, biology, ecology or epidemiology. <code>IBMPopSim</code> overcomes the limitations of time-consuming IBMs simulations by implementing new efficient algorithms based on thinning methods, which are compiled using the <code>Rcpp</code> package while providing a user-friendly interface.</p>
    </div>
  </div>

  </header><div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Contents</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction"><span class="header-section-number">1</span> Introduction</a></li>
  <li><a href="#sec-ibm" id="toc-sec-ibm" class="nav-link" data-scroll-target="#sec-ibm"><span class="header-section-number">2</span> Stochastic Individual-Based Models (IBMs) in IBMPopSim</a>
  <ul class="collapse">
  <li><a href="#brief-package-overview" id="toc-brief-package-overview" class="nav-link" data-scroll-target="#brief-package-overview"><span class="header-section-number">2.1</span> Brief package overview</a>
  <ul class="collapse">
  <li><a href="#model-creation" id="toc-model-creation" class="nav-link" data-scroll-target="#model-creation"><span class="header-section-number">2.1.1</span> Model creation</a></li>
  <li><a href="#simulation" id="toc-simulation" class="nav-link" data-scroll-target="#simulation"><span class="header-section-number">2.1.2</span> Simulation</a></li>
  </ul></li>
  <li><a href="#sec-population" id="toc-sec-population" class="nav-link" data-scroll-target="#sec-population"><span class="header-section-number">2.2</span> Population</a>
  <ul class="collapse">
  <li><a href="#notations" id="toc-notations" class="nav-link" data-scroll-target="#notations"><span class="header-section-number">2.2.1</span> Notations</a></li>
  <li><a href="#individuals" id="toc-individuals" class="nav-link" data-scroll-target="#individuals"><span class="header-section-number">2.2.2</span> Individuals</a></li>
  <li><a href="#population-process" id="toc-population-process" class="nav-link" data-scroll-target="#population-process"><span class="header-section-number">2.2.3</span> Population process</a></li>
  </ul></li>
  <li><a href="#sec-events" id="toc-sec-events" class="nav-link" data-scroll-target="#sec-events"><span class="header-section-number">2.3</span> Events</a></li>
  <li><a href="#sec-event-intensity" id="toc-sec-event-intensity" class="nav-link" data-scroll-target="#sec-event-intensity"><span class="header-section-number">2.4</span> Events intensity</a>
  <ul class="collapse">
  <li><a href="#events-intensity-bounds" id="toc-events-intensity-bounds" class="nav-link" data-scroll-target="#events-intensity-bounds"><span class="header-section-number">2.4.1</span> Events intensity bounds</a></li>
  </ul></li>
  <li><a href="#pathwise-representation" id="toc-pathwise-representation" class="nav-link" data-scroll-target="#pathwise-representation"><span class="header-section-number">2.5</span> Pathwise representation</a>
  <ul class="collapse">
  <li><a href="#non-explosion-criterion" id="toc-non-explosion-criterion" class="nav-link" data-scroll-target="#non-explosion-criterion"><span class="header-section-number">2.5.1</span> Non explosion criterion</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#sec-simulation" id="toc-sec-simulation" class="nav-link" data-scroll-target="#sec-simulation"><span class="header-section-number">3</span> Population simulation</a>
  <ul class="collapse">
  <li><a href="#sec-thinning" id="toc-sec-thinning" class="nav-link" data-scroll-target="#sec-thinning"><span class="header-section-number">3.1</span> Thinning of Poisson measure</a>
  <ul class="collapse">
  <li><a href="#sec-vector" id="toc-sec-vector" class="nav-link" data-scroll-target="#sec-vector"><span class="header-section-number">3.1.1</span> Multivariate Poisson process</a></li>
  </ul></li>
  <li><a href="#sec-simulation-algo" id="toc-sec-simulation-algo" class="nav-link" data-scroll-target="#sec-simulation-algo"><span class="header-section-number">3.2</span> Simulation algorithm</a>
  <ul class="collapse">
  <li><a href="#first-event-simulation" id="toc-first-event-simulation" class="nav-link" data-scroll-target="#first-event-simulation"><span class="header-section-number">3.2.1</span> First event simulation</a></li>
  </ul></li>
  <li><a href="#sec-simulation-randomized" id="toc-sec-simulation-randomized" class="nav-link" data-scroll-target="#sec-simulation-randomized"><span class="header-section-number">3.3</span> Simulation algorithm with randomization</a></li>
  </ul></li>
  <li><a href="#sec-package" id="toc-sec-package" class="nav-link" data-scroll-target="#sec-package"><span class="header-section-number">4</span> Model creation and simulation with IBMPopSim</a>
  <ul class="collapse">
  <li><a href="#sec-package-population" id="toc-sec-package-population" class="nav-link" data-scroll-target="#sec-package-population"><span class="header-section-number">4.1</span> Population</a>
  <ul class="collapse">
  <li><a href="#individual" id="toc-individual" class="nav-link" data-scroll-target="#individual"><span class="header-section-number">4.1.1</span> Individual</a></li>
  </ul></li>
  <li><a href="#sec-package-events" id="toc-sec-package-events" class="nav-link" data-scroll-target="#sec-package-events"><span class="header-section-number">4.2</span> Events</a>
  <ul class="collapse">
  <li><a href="#intensities" id="toc-intensities" class="nav-link" data-scroll-target="#intensities"><span class="header-section-number">4.2.1</span> Intensities</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#sec-insurance-portfolio" id="toc-sec-insurance-portfolio" class="nav-link" data-scroll-target="#sec-insurance-portfolio"><span class="header-section-number">5</span> Insurance portfolio</a>
  <ul class="collapse">
  <li><a href="#insurance-population" id="toc-insurance-population" class="nav-link" data-scroll-target="#insurance-population"><span class="header-section-number">5.1</span> Population</a></li>
  <li><a href="#insurance-events" id="toc-insurance-events" class="nav-link" data-scroll-target="#insurance-events"><span class="header-section-number">5.2</span> Events</a></li>
  <li><a href="#insurance-simulation" id="toc-insurance-simulation" class="nav-link" data-scroll-target="#insurance-simulation"><span class="header-section-number">5.3</span> Model creation and simulation</a></li>
  <li><a href="#outputs" id="toc-outputs" class="nav-link" data-scroll-target="#outputs"><span class="header-section-number">5.4</span> Outputs</a></li>
  </ul></li>
  <li><a href="#sec-example-interaction" id="toc-sec-example-interaction" class="nav-link" data-scroll-target="#sec-example-interaction"><span class="header-section-number">6</span> Population with genetically variable traits</a>
  <ul class="collapse">
  <li><a href="#population" id="toc-population" class="nav-link" data-scroll-target="#population"><span class="header-section-number">6.1</span> Population</a></li>
  <li><a href="#events" id="toc-events" class="nav-link" data-scroll-target="#events"><span class="header-section-number">6.2</span> Events</a>
  <ul class="collapse">
  <li><a href="#birth-events" id="toc-birth-events" class="nav-link" data-scroll-target="#birth-events"><span class="header-section-number">6.2.1</span> Birth events</a></li>
  <li><a href="#death-events" id="toc-death-events" class="nav-link" data-scroll-target="#death-events"><span class="header-section-number">6.2.2</span> Death events</a></li>
  </ul></li>
  <li><a href="#model-creation-and-simulation" id="toc-model-creation-and-simulation" class="nav-link" data-scroll-target="#model-creation-and-simulation"><span class="header-section-number">6.3</span> Model creation and simulation</a></li>
  </ul></li>
  
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="article.pdf"><i class="bi bi-file-pdf"></i>PDF (computo)</a></li></ul></div></nav>
</div>
<main class="content quarto-banner-title-block" id="quarto-document-content">




<section id="introduction" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Introduction</h1>
<p>In various fields, advances in probability have contributed to the development of a new mathematical framework for so-called individual-based stochastic population dynamics, also called stochastic Individual-Based Models (IBMs).</p>
<p>Stochastic IBMs allow the modeling in continuous time of populations dynamics structured by age and/or characteristics. In the field of mathematical biology and ecology, a large community has used this formalism for the study of the evolution of structured populations (see e.g. <span class="citation" data-cites="FerTra09 collet2013rigorous BanMel15 costa2016stochastic billiard2016effect lavallee2019stochastic meleard2019birth calvez2020horizontal">(<a href="#ref-FerTra09" role="doc-biblioref">Ferrière and Tran 2009</a>; <a href="#ref-collet2013rigorous" role="doc-biblioref">Collet, Méléard, and Metz 2013</a>; <a href="#ref-BanMel15" role="doc-biblioref">Bansaye and Méléard 2015</a>; <a href="#ref-costa2016stochastic" role="doc-biblioref">Costa et al. 2016</a>; <a href="#ref-billiard2016effect" role="doc-biblioref">Billiard et al. 2016</a>; <a href="#ref-lavallee2019stochastic" role="doc-biblioref">Lavallée et al. 2019</a>; <a href="#ref-meleard2019birth" role="doc-biblioref">Méléard, Rera, and Roget 2019</a>; <a href="#ref-calvez2020horizontal" role="doc-biblioref">Calvez et al. 2020</a>)</span>), after the pioneer works&nbsp;<span class="citation" data-cites="FouMel04 tran_2008 meleard2009trait">(<a href="#ref-FouMel04" role="doc-biblioref">Fournier and Méléard 2004</a>; <a href="#ref-tran_2008" role="doc-biblioref">Tran 2008</a>; <a href="#ref-meleard2009trait" role="doc-biblioref">Méléard and Tran 2009</a>)</span>.</p>
<p>IBMs are also useful in demography and actuarial sciences, for the modeling of human populations dynamics (see e.g. <span class="citation" data-cites="Ben10 Bou16 karoui2021simulating">(<a href="#ref-Ben10" role="doc-biblioref">Bensusan 2010</a>; <a href="#ref-Bou16" role="doc-biblioref">Boumezoued 2016</a>; <a href="#ref-karoui2021simulating" role="doc-biblioref">El Karoui, Hadji, and Kaakai 2021</a>)</span>). They allow the modeling of heterogeneous and complex population dynamics, which can be used to compute demographic indicators or simulate the evolution of insurance portfolios in order to study the basis risk, compute cash flows for annuity products or pension schemes, or for a fine assessment of mortality models <span class="citation" data-cites="barrieu2012understanding">(<a href="#ref-barrieu2012understanding" role="doc-biblioref">Barrieu et al. 2012</a>)</span>. There are other domains in which stochastic IBMs can be used, for example in epidemiology with stochastic compartmental models, neurosciences, cyber risk, or Agent-Based Models (ABMs) in economy and social sciences, which can be seen as IBMs. Many mathematical results have been obtained in the literature cited above, for quantifying the limit behaviors of IBMs in long time or in large population. In particular, pathwise representations of IBMs have been introduced in <span class="citation" data-cites="FouMel04">(<a href="#ref-FouMel04" role="doc-biblioref">Fournier and Méléard 2004</a>)</span> (and extended to age-structured populations in <span class="citation" data-cites="tran_2008 meleard2009trait">(<a href="#ref-tran_2008" role="doc-biblioref">Tran 2008</a>; <a href="#ref-meleard2009trait" role="doc-biblioref">Méléard and Tran 2009</a>)</span>), as measure-valued pure jumps Markov processes, solutions of SDEs driven by Poisson measures. These pathwise representations are based on the <em>thinning</em> and projection of Poisson random measures defined on extended spaces. However, the simulation of large and interacting populations is often referred as computationally expensive.</p>
<p>The aim of the <code>R</code> package <code>IBMPopSim</code> is to meet the needs of the various communities for efficient tools in order to simulate the evolution of stochastic IBMs. <code>IBMPopSim</code> provides a general framework for the simulation of a wide class of IBMs, where individuals are characterized by their age and/or a set of characteristics. Different types of events can be included in the modeling by users, depending on their needs: births, deaths, entry or exit in/to the population and changes of characteristics (swap events). Furthermore, the various events that can happen to individuals in the population can occur at a non-stationary frequency, depending on the individuals’ characteristics and time, and also including potential interactions between individuals.</p>
<p>We introduce a unified mathematical and simulation framework for this class of IBMs, generalizing the pathwise representation of IBMs by thinning of Poisson measures, as well as the associated population simulation algorithm, based on an acceptance/rejection procedure. In particular, we provide general sufficient conditions on the event intensities under which the simulation of a particular model is possible.</p>
<p>We opted to implement the algorithms of the <code>IBMPopSim</code> package using the <code>Rcpp</code> package, a tool facilitating the seamless integration of high-performance <code>C++</code> code into easily callable <code>R</code> functions <span class="citation" data-cites="JSSv040i08">(<a href="#ref-JSSv040i08" role="doc-biblioref">Eddelbuettel and Francois 2011</a>)</span>. With just a few lines of <code>C++</code> code, <code>IBMPopSim</code> offers user-friendly R functions for defining IBMs. Once events and their associated intensities are specified, an automated procedure creates the model. This involves integrating the user’s source code into the primary <code>C++</code> code using a template mechanism. Subsequently, <code>Rcpp</code> is invoked to compile the model and integrate it into the <code>R</code> session. Following this process, the model becomes callable with varying parameters, enabling the generation of diverse population evolution scenarios. Combined with the design of the simulation algorithms, the package structure yields very competitive simulation runtimes for IBMs, while staying user-friendly for <code>R</code> users. Several outputs function are also implemented in <code>IBMPopSim</code>. For instance the package allows the construction and visualization of age pyramids, as well as the construction of death and exposures table from the censored individual data, compatible with <code>R</code> packages concerned with mortality modelling, such as <span class="citation" data-cites="Rdemography">(<a href="#ref-Rdemography" role="doc-biblioref">Hyndman et al. 2023</a>)</span> or <span class="citation" data-cites="Rstmomo">(<a href="#ref-Rstmomo" role="doc-biblioref">A. Villegas, Millossovich, and Kaishev Hyndman 2018</a>)</span>. Several examples are provided in the form of <code>R</code> vignettes on the <a href="https://daphnegiorgi.github.io/IBMPopSim/">website</a>, and in recent works of <span class="citation" data-cites="karoui2021simulating">(<a href="#ref-karoui2021simulating" role="doc-biblioref">El Karoui, Hadji, and Kaakai 2021</a>)</span> and <span class="citation" data-cites="roget2022positive">(<a href="#ref-roget2022positive" role="doc-biblioref">Roget et al. 2022</a>)</span>.</p>
<p>Designed for applications in social sciences, the <code>R</code> package <code>MicSim</code>&nbsp;<span class="citation" data-cites="Zin14">(<a href="#ref-Zin14" role="doc-biblioref">Zinn 2014</a>)</span> can be used for continuous time microsimulation. In continuous-time microsimulation, individual life-courses are usually specified by sequences of state transitions (events) and the time spans between these transitions. The state space is usually discrete and finite, which is no necessarily the case in <code>IBMPopSim</code>, where individuals can have continuous characteristics. But most importantly, microsimulation does not allow for interactions between individuals. Indeed, microsimulation produces separately the life courses of all individuals in the populations, based on the computation of the distribution functions of the waiting times in the distinct states of the state space, for each individual <span class="citation" data-cites="Zin14">(<a href="#ref-Zin14" role="doc-biblioref">Zinn 2014</a>)</span>. This can be slow in comparison to the simulation by thinning of event times occurring in the population, which is based on selecting event times among some competing proposed event times. Finally, <code>MicSim</code> simplifies the Mic-Core microsimulation tool implemented in Java <span class="citation" data-cites="zinn2009mic">(<a href="#ref-zinn2009mic" role="doc-biblioref">Zinn et al. 2009</a>)</span>. However, the implementation in <code>R</code> of simulation algorithms yields longer simulation run times than when using <code>Rcpp</code>. To the best of our knowledge, there are no other <code>R</code> packages currently available addressing the issue of IBMs efficient simulation.</p>
<p>In <a href="#sec-ibm" class="quarto-xref">Section&nbsp;2</a>, we introduce the mathematical framework that characterizes the class of Stochastic Individual-Based Models (IBMs) that can be implemented in the <code>IBMPopSim</code> package. In particular, a general pathwise representation of IBMs is presented. The population dynamics is obtained as the solution of an SDE driven by Poisson measures, for which we obtain existence and uniqueness results in <a href="#thm-eq-Z" class="quarto-xref">Theorem&nbsp;1</a>. Additionally, a succinct overview of the package is provided. In <a href="#sec-simulation" class="quarto-xref">Section&nbsp;3</a> the two main algorithms for simulating the population evolution of an IBM across the interval <span class="math inline">[0, T]</span> are detailed. In <a href="#sec-package" class="quarto-xref">Section&nbsp;4</a> we present the main functions of the <code>IBMPopSim</code> package, which allow for the definition of events and their intensities, the creation of a model, and the simulation of scenarios. Two examples are detailed in <a href="#sec-insurance-portfolio" class="quarto-xref">Section&nbsp;5</a> and <a href="#sec-example-interaction" class="quarto-xref">Section&nbsp;6</a>, featuring applications involving an heterogeneous insurance portfolio characterized by entry and exit events, and an age and size-structured population with intricate interactions.</p>
</section>
<section id="sec-ibm" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Stochastic Individual-Based Models (IBMs) in IBMPopSim</h1>
<p>Stochastic Individual-Based Models (IBMs) represent a broad class of random population dynamics models, allowing the description of populations evolution on a microscopic scale. Informally, an IBM can be summarized by the description of the individuals constituting the population, the various types of events that can occur to these individuals, along with their respective frequencies. In <code>IBMPopSim</code>, individuals can be characterized by their age and/or a collection of discrete or continuous characteristics. Moreover, the package enables users to simulate efficiently populations in which one or more of the following event types may occur:</p>
<ul>
<li><strong>Birth event</strong>: addition of an individual of age 0 to the population.</li>
<li><strong>Death event</strong>: removal of an individual from the population.</li>
<li><strong>Entry event</strong>: arrival of an individual in the population.</li>
<li><strong>Exit (emigration) event</strong>: exit from the population (other than death).</li>
<li><strong>Swap event</strong>: an individual changes characteristics.</li>
</ul>
<p>Each event type is linked to an associated event kernel, describing how the population is modified following the occurrence of the event. For some event types, the event kernel requires explicit specification. This is the case for entry events when a new individual joins the population. Then,the model should specify how the age and characteristics of this new individual are chosen. For instance, the characteristics of a new individual in the population can be chosen uniformly in the space of all characteristics, or can depend on the distribution of his parents or those of the other individuals composing the population.</p>
<p>The last component of an IBM are the event intensities. Informally, an event intensity is a function <span class="math inline">\lambda^e_t(I, Z)</span> describing the frequency at which an event <span class="math inline">e</span> can occur to an individual <span class="math inline">I</span> in a population <span class="math inline">Z</span> at a time <span class="math inline">t</span>. Given a history of the population <span class="math inline">(\mathcal{F}_t)</span>, the probability of event <span class="math inline">e</span> occurring to individual <span class="math inline">I</span> during a small interval of time <span class="math inline">(t,t+dt]</span> is proportional to <span class="math inline">\lambda^e(I,t)</span>: <span class="math display">
    \mathbb{P}(\text{event } e \text{ occurring to $I$ during } (t,t+dt] | \mathcal{F}_t) \simeq \lambda^e_t(I, Z)dt.
</span> The intensity function <span class="math inline">\lambda^e</span> can include dependency on the individual’s <span class="math inline">I</span> age and characteristics, the time <span class="math inline">t</span>, or the population composition <span class="math inline">Z</span> in the presence of interactions.</p>
<section id="brief-package-overview" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="brief-package-overview"><span class="header-section-number">2.1</span> Brief package overview</h2>
<p>Prior to providing a detailed description of an Individual-Based Model (IBM), we present a simple model of birth and death in an age-structured <em>human</em> population. We assume no interactions between individuals, and individuals are characterized by their gender, in addition to their age. In this simple model, all individuals, regardless of gender, can give birth when their age falls between 15 and 40 years, with a constant birth rate of 0.05. The death intensity is assumed to follow a Gompertz-type intensity depending on age. The birth and death intensities are then given by<br>
<span class="math display">\begin{equation*}
    \lambda^b(t, I) = 0.05 \times \mathbf{1}_{[15,40]}(a(I,t)), \quad
    \lambda^d(t, I) = \alpha\exp(\beta a(I,t)),
\end{equation*}</span> with <span class="math inline">a(I,t)</span> the age of individual <span class="math inline">I</span> at time <span class="math inline">t</span>. Birth events are also characterized with a kernel determining the gender of the newborn, who is male with probability <span class="math inline">p_{male}</span>.</p>
<section id="model-creation" class="level3" data-number="2.1.1">
<h3 data-number="2.1.1" class="anchored" data-anchor-id="model-creation"><span class="header-section-number">2.1.1</span> Model creation</h3>
<p>To implement this model in IBMPopSim, it is necessary to individually define each event type. In this example, the <code>mk_event_individual</code> function is used. The creation of an event involves a few lines of <code>cpp</code> instructions defining the intensity and, if applicable, the kernel of the event. For a more in depth description of the event creation step and its parameters, we refer to <a href="#sec-package-events" class="quarto-xref">Section&nbsp;4.2</a>.</p>
<p>The events of this simple model are for example defined through the following calls.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>birth_event <span class="ot">&lt;-</span> <span class="fu">mk_event_individual</span>(</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">type =</span> <span class="st">"birth"</span>, </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">intensity_code =</span> <span class="st">"result = birth_rate(I.age(t));"</span>,</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">kernel_code =</span> <span class="st">"newI.male = CUnif(0,1) &lt; p_male;"</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>death_event <span class="ot">&lt;-</span> <span class="fu">mk_event_individual</span>(</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span class="at">type =</span> <span class="st">"death"</span>,</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span class="at">intensity_code =</span> <span class="st">"result = alpha * exp(beta * I.age(t));"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>In the <code>cpp</code> codes, the names <code>birth_rate</code>, <code>p_male</code>, <code>alpha</code> and <code>beta</code> refer to the model parameters defined in the following list.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>params <span class="ot">&lt;-</span> <span class="fu">list</span>(</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="st">"alpha"</span> <span class="ot">=</span> <span class="fl">0.008</span>, <span class="st">"beta"</span> <span class="ot">=</span> <span class="fl">0.02</span>, </span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="st">"p_male"</span> <span class="ot">=</span> <span class="fl">0.51</span>,</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="st">"birth_rate"</span> <span class="ot">=</span> <span class="fu">stepfun</span>(<span class="fu">c</span>(<span class="dv">15</span>, <span class="dv">40</span>), <span class="fu">c</span>(<span class="dv">0</span>, <span class="fl">0.05</span>, <span class="dv">0</span>)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>In a second step, the model is created by calling the function <code>mk_model</code>. A <code>cpp</code> source code is automatically created through a template mechanism based on the events and parameters, subsequently compiled using the <code>sourceCpp</code> function from the <code>Rcpp</code> package.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>birth_death_model <span class="ot">&lt;-</span> <span class="fu">mk_model</span>(</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">characteristics =</span> <span class="fu">c</span>(<span class="st">"male"</span> <span class="ot">=</span> <span class="st">"bool"</span>),</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">events =</span> <span class="fu">list</span>(death_event, birth_event),</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">parameters =</span> params)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="simulation" class="level3" data-number="2.1.2">
<h3 data-number="2.1.2" class="anchored" data-anchor-id="simulation"><span class="header-section-number">2.1.2</span> Simulation</h3>
<p>Once the model is created and compiled, the <code>popsim</code> function is called to simulate the evolution of a population according to this model. To achieve this, an initial population must be defined. In this example, we extract a population from a dataset specified in the package (a sample of <span class="math inline">100\,000</span> individuals based on the population of England and Wales in 2014). It is also necessary to set bounds for the events intensities. In this example, they are obtained by assuming that the maximum age for an individual is 115 years.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>a_max <span class="ot">&lt;-</span> <span class="dv">115</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>events_bounds <span class="ot">=</span> <span class="fu">c</span>(</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="st">"death"</span> <span class="ot">=</span> params<span class="sc">$</span>alpha <span class="sc">*</span> <span class="fu">exp</span>(params<span class="sc">$</span>beta <span class="sc">*</span> a_max),</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span class="st">"birth"</span> <span class="ot">=</span> <span class="fu">max</span>(params<span class="sc">$</span>birth_rate))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The function <code>popsim</code> can now be called to simulate the population starting from the initial population <code>population(EW_pop_14$sample)</code> up to time <span class="math inline">T = 30</span>.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>sim_out <span class="ot">&lt;-</span> <span class="fu">popsim</span>(</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  birth_death_model, </span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">population</span>(EW_pop_14<span class="sc">$</span>sample), </span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  events_bounds, </span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">parameters =</span> params, <span class="at">age_max =</span> a_max, </span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">time =</span> <span class="dv">30</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The data frame <code>sim_out$population</code> contains the information (birth, death, gender) on individuals who lived in the population over the period <span class="math inline">[0,30]</span>. Functions of the package allows to provide aggregated information on the population.</p>
<p>In the remainder of this section, we define rigorously the class of IBMs that can be simulated in <code>IBMPopSim</code>, along with the assumptions that are required in order for the population to be simulatable. The representation of age-structured IBMs based on measure-valued processes, as introduced in <span class="citation" data-cites="tran_2008">Tran (<a href="#ref-tran_2008" role="doc-biblioref">2008</a>)</span>, is generalized to a wider class of abstract population dynamics. The modeling differs slightly here, since individuals are <em>kept in the population</em> after their death (or exit), by including the death/exit date as an individual trait.</p>
</section>
</section>
<section id="sec-population" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="sec-population"><span class="header-section-number">2.2</span> Population</h2>
<section id="notations" class="level3" data-number="2.2.1">
<h3 data-number="2.2.1" class="anchored" data-anchor-id="notations"><span class="header-section-number">2.2.1</span> Notations</h3>
<p>In the remainder of the paper, the filtered probability space is denoted by <span class="math inline">(\Omega,\{\mathcal{F}_t \},{\mathbb{P}})</span>, under the usual assumptions. All processes are assumed to be càdlàg and adapted to the filtration <span class="math inline">\{\mathcal{F}_t \}</span> (for instance the history of the population) on a time interval <span class="math inline">[0,T]</span>. For a càdlàg process <span class="math inline">X</span>, we denote <span class="math inline">X_{t^-} := \lim_{\genfrac{}{}{0pt}{2}{s\to t}{s&lt;t}} X_s</span>.</p>
</section>
<section id="individuals" class="level3" data-number="2.2.2">
<h3 data-number="2.2.2" class="anchored" data-anchor-id="individuals"><span class="header-section-number">2.2.2</span> Individuals</h3>
<p>An individual is represented by a triplet <span class="math inline">I = (\tau^b, \tau^d, x) \in \mathcal{I}= {\mathbb{R}}\times \bar {\mathbb{R}}\times {\mathcal{X}}</span> with:</p>
<ul>
<li><span class="math inline">\tau^b \in {\mathbb{R}}</span> the date of birth,</li>
<li><span class="math inline">\tau^d \in \bar {\mathbb{R}}</span> the death date, with <span class="math inline">\tau^d = \infty</span> if the individual is still alive,</li>
<li>a collection <span class="math inline">x \in {\mathcal{X}}</span> of characteristics where <span class="math inline">{\mathcal{X}}</span> is the space of characteristics.</li>
</ul>
<p>Note that in IBMs, individuals are usually characterized by their age <span class="math inline">a(t) =t-\tau^b</span> instead of their date of birth <span class="math inline">\tau^b</span>. However, using the latter is actually easier for the simulation, as it remains constant over time.</p>
</section>
<section id="population-process" class="level3" data-number="2.2.3">
<h3 data-number="2.2.3" class="anchored" data-anchor-id="population-process"><span class="header-section-number">2.2.3</span> Population process</h3>
<p>The population at a given time <span class="math inline">t</span> is a random set <span class="math display">
    Z_t=\{ I_k \in \mathcal{I}; \; k= 1,\dots, N_t\},
</span> composed of all individuals (alive or dead) who have lived in the population before time <span class="math inline">t</span>. As a random set, <span class="math inline">Z_t</span> can be represented by a random counting measure on <span class="math inline">\mathcal{I}</span> , that is an integer-valued measure <span class="math inline">Z: \Omega \times \mathcal{I}\to \bar {\mathbb{N}}</span> where for <span class="math inline">A \in \mathcal{I}</span>, <span class="math inline">Z(A)</span> is the (random) number of individuals <span class="math inline">I</span> in the subset <span class="math inline">A</span>. With this representation: <span id="eq-popZ"><span class="math display">
\begin{aligned}
    Z_t (\mathrm{d}\tau^b, \mathrm{d}\tau^d , \mathrm{d}x) &amp;= \sum_{k=1}^{N_t} \delta_{I_k} (\tau^b, \tau^d,x), \nonumber \\
    \text{ with }  \int_{\mathcal{I}} f(\tau^b, \tau^d, x) Z_t (\mathrm{d}\tau^b, \mathrm{d}\tau^d , \mathrm{d}x) &amp;= \sum_{k=1}^{N_t} f(I_k).
\end{aligned}
\tag{1}</span></span></p>
<p>The number of individuals present in the population <em>before time</em> <span class="math inline">t</span> is obtained by taking <span class="math inline">f\equiv 1</span>: <span class="math display">
    N_t =  \int_{\mathcal{I}}  Z_t(\mathrm{d}\tau^b, \mathrm{d}\tau^d, \mathrm{d}x) = \sum_{k=1}^{N_t} \boldsymbol{1}_{\mathcal{I}} (I_k).
</span> Note that <span class="math inline">(N_t)_{t\geq 0}</span> is an increasing process since dead/exited individuals are kept in the population <span class="math inline">Z</span>. The number of alive individuals in the population at time <span class="math inline">t</span> is: <span id="eq-Nta"><span class="math display">
    N_t^a =  \int_{\mathcal{I}}  \mathsf{1}_{\{\tau^d &gt; t \} }Z_t(\mathrm{d}\tau^b, \mathrm{d}\tau^d, \mathrm{d}x) = \sum_{k=1}^{N_t} \mathsf{1}_{\{\tau^d_k &gt; t \} }.
\tag{2}</span></span> Another example is the number of alive individuals of age over <span class="math inline">a</span> is <span class="math display">
    N_t([a,+\infty)) :=  \int_{\mathcal{I}}  \boldsymbol{1}_{[a,+\infty)}(t-\tau^b)\mathsf{1}_{]t,\infty]}(\tau^d) Z_t(\mathrm{d}\tau^b, \mathrm{d}\tau^d, \mathrm{d}x) = \sum_{k=1}^{N_t}  \boldsymbol{1}_{\{ t -\tau_k^b \geq a \}}\mathsf{1}_{\{\tau^d_k \geq t \} }.
</span></p>
</section>
</section>
<section id="sec-events" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="sec-events"><span class="header-section-number">2.3</span> Events</h2>
<p>The population composition changes at random dates following different types of events. <code>IBMPopSim</code> allows the simulation of IBMs with the following events types:</p>
<ul>
<li><p>A <strong>birth</strong> event at time <span class="math inline">t</span> is the addition of a new individual <span class="math inline">I'=(t,\infty, X)</span> of age <span class="math inline">0</span> to the population. Their date of birth is <span class="math inline">\tau^b =t</span>, and characteristics is <span class="math inline">X</span>, a random variable of distribution defined by the birth kernel <span class="math inline">k^b(t,I,\mathrm{d}x)</span> on <span class="math inline">{\mathcal{X}}</span>, depending on <span class="math inline">t</span> and its parent <span class="math inline">I</span>. The population size becomes <span class="math inline">N_t = N_{t^-} + 1</span>, and the population composition after the event is <span class="math display">Z_t  = Z_{t^-} +  \delta_{(t,\infty, X)}.</span></p></li>
<li><p>An <strong>entry</strong> event at time <span class="math inline">t</span> is also the addition of an individual <span class="math inline">I'</span> in the population. However, this individual is not of age <span class="math inline">0</span>. The date of birth and characteristics of the new individual <span class="math inline">I'= (\tau^b, \infty, X)</span> are random variables of probability distribution defined by the entry kernel <span class="math inline">k^{en}(t, \mathrm{d}s, \mathrm{d}x)</span> on <span class="math inline">{\mathbb{R}}\times {\mathcal{X}}</span>. The population size becomes <span class="math inline">N_t = N_{t^-} + 1</span>, and the population composition after the event is: <span class="math display">
  Z_t  = Z_{t^-} +  \delta_{(\tau^b, \infty, X)}.
</span></p></li>
<li><p>A <strong>death</strong> or <strong>exit</strong> event of an individual <span class="math inline">I= (\tau^b,\infty, x)\in Z_{t^-}</span> at time <span class="math inline">t</span> is the modification of its death date <span class="math inline">\tau^d</span> from <span class="math inline">+\infty</span> to <span class="math inline">t</span>. This event results in the simultaneous addition of the individual <span class="math inline">(\tau^b,t,x)</span> and removal of the individual <span class="math inline">I</span> from the population. The population size is not modified, and the population composition after the event is <span class="math display">
  Z_t  = Z_{t^-} +\delta_{(\tau^b,t,x)}- \delta_{I}.
</span></p></li>
<li><p>A <strong>swap</strong> event (change of characteristics) results in the simultaneous addition and removal of an individual. If an individual <span class="math inline">I= (\tau^b,\infty, x) \in Z_{t^-}</span> changes of characteristics at time <span class="math inline">t</span>, then it is removed from the population and replaced by <span class="math inline">I' = (\tau^b,\infty, X)</span>. The new characteristics <span class="math inline">X</span> is a random variable of distribution <span class="math inline">k^s(t, I,\mathrm{d}x)</span> on <span class="math inline">{\mathcal{X}}</span>, depending on time, the individual’s age and previous characteristics <span class="math inline">x</span>. In this case, the population size is not modified and the population becomes: <span class="math display">
  Z_t  = Z_{t^-}   +  \delta_{(\tau^b,  \infty, X)} -  \delta_{(\tau^b, \infty, x)}.
</span></p></li>
</ul>
<p>To summarize, the space of event types is <span class="math inline">E = \{ b, en, d, s \}</span>, and the jump <span class="math inline">\Delta Z_t = Z_t - Z_{t^-}</span> (change in the population composition) generated by an event of type <span class="math inline">e \in \{ b, en, d, s \}</span> is denoted by <span class="math inline">\phi^e(t, I)</span>. We thus have the following rules summarized in the table <a href="#tbl-event-action" class="quarto-xref">Table&nbsp;1</a>.</p>
<div id="tbl-event-action" class="quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-event-action-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;1: Action in the population for a given event name
</figcaption>
<div aria-describedby="tbl-event-action-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table">
<colgroup>
<col style="width: 13%">
<col style="width: 13%">
<col style="width: 37%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th>Event</th>
<th style="text-align: center;">Type</th>
<th><span class="math inline">\phi^e(t, I)</span></th>
<th>New individual</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Birth</td>
<td style="text-align: center;"><span class="math inline">b</span></td>
<td><span class="math inline">\delta_{(t, \infty,  X)}</span></td>
<td><span class="math inline">\tau^b =t, \; X \sim k^b(t,I,\mathrm{d}x)</span></td>
</tr>
<tr class="even">
<td>Entry</td>
<td style="text-align: center;"><span class="math inline">en</span></td>
<td><span class="math inline">\delta_{(\tau^b, \infty,  X)}</span></td>
<td><span class="math inline">(\tau^b, X) \sim k^{en}(t,\mathrm{d}s, \mathrm{d}x)</span></td>
</tr>
<tr class="odd">
<td>Death/Exit</td>
<td style="text-align: center;"><span class="math inline">d</span></td>
<td><span class="math inline">\delta_{(\tau^b, t,x)} - \delta_{(\tau^b, \infty, x)}</span></td>
<td><span class="math inline">\tau^d = t</span></td>
</tr>
<tr class="even">
<td>Swap</td>
<td style="text-align: center;"><span class="math inline">s</span></td>
<td><span class="math inline">\delta_{(\tau^b, \infty , X)} - \delta_{(\tau^b, \infty, x)}</span></td>
<td><span class="math inline">X \sim k^s(t,I,\mathrm{d}x)</span></td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<div id="rem-popfinale" class="proof remark">
<p><span class="proof-title"><em>Remark 1</em> (Composition of the population). </span></p>
<ul>
<li>At time <span class="math inline">T</span>, the population <span class="math inline">Z_T</span> contains all individuals who lived in the population before <span class="math inline">T</span>, including dead/exited individuals. If there are no swap events, or entries,the population state <span class="math inline">Z_t</span> for any time <span class="math inline">t\leq T</span> can be obtained from <span class="math inline">Z_T</span>. Indeed, if <span class="math inline">Z_T = \sum_{k=1}^{N_T}  \delta_{I_k}</span>, then the population at time <span class="math inline">t\leq T</span> is simply composed of the individuals born before <span class="math inline">t</span>: <span class="math display">
  Z_t = \sum_{k=1}^{N_T} \boldsymbol{1}_{\{\tau^b_k \leq t \}} \delta_{I_k}.
</span></li>
<li>In the presence of entries (open population), a characteristic <span class="math inline">x</span> can track the individuals’ entry dates. Then, the previous equation can be easily modified in order to obtain the population <span class="math inline">Z_t</span> at time <span class="math inline">t\leq T</span> from <span class="math inline">Z_T</span>.</li>
</ul>
</div>
</section>
<section id="sec-event-intensity" class="level2" data-number="2.4">
<h2 data-number="2.4" class="anchored" data-anchor-id="sec-event-intensity"><span class="header-section-number">2.4</span> Events intensity</h2>
<p>Once the different event types have been defined in the population model, the frequency at which each event occur in the population <span class="math inline">e</span> have to be specified. Informally, the intensity <span class="math inline">\Lambda^e_t(Z_t)</span> at which an event <span class="math inline">e</span> can occur is defined by <span class="math display">
    \mathbb P\big( \text{event } e \text { occurs in the population }  Z_t  \in (t,t+\mathrm{d}t] | \mathcal{F}_t \big) \simeq  \Lambda^e_t (Z_t)\mathrm{d}t.
</span> For a more formal definition of stochastic intensities, we refer to <span class="citation" data-cites="bremaud1981point">(<a href="#ref-bremaud1981point" role="doc-biblioref">Brémaud 1981</a>)</span> or <span class="citation" data-cites="KaaElK20">(<a href="#ref-KaaElK20" role="doc-biblioref">Kaakai and El Karoui 2023</a>)</span>. The form of the intensity function <span class="math inline">(\Lambda^e_t (Z_t))</span> determines the population simulation algorithm in <code>IBMPopSim</code>:</p>
<ul>
<li>When the event intensity does not depend on the population state, <span id="eq-poisson-intensity"><span class="math display">
  \big(\Lambda^e_t (Z_t)\big)_{t\in [0,T]} = \big(\mu^e(t)\big)_{t \in [0,T]},
\tag{3}</span></span> with <span class="math inline">\mu^e</span> a deterministic function, the events of type <span class="math inline">e</span> occur at the jump times of an inhomogeneous Poisson process of intensity function <span class="math inline">(\mu^e(t))_{t \in [0,T]}</span>. When such an event occurs, the individual to whom the event happens to is drawn uniformly among alive individuals in the population. In a given model, the set of events <span class="math inline">e\in E</span> with Poisson intensities will be denoted by <span class="math inline">\mathcal{P}</span>.</li>
<li>Otherwise, we assume that the global intensity <span class="math inline">\Lambda^e_t(Z_t)</span> at which the events of type <span class="math inline">e</span> occur in the population can be written as the sum of individual intensities <span class="math inline">\lambda^e_t(I,Z_t)</span>: <span id="eq-global-intensity"><span class="math display">
\begin{aligned}
  &amp;\Lambda^e_t (Z_t) = \sum_{k=1}^{N_t} \lambda^e_t ( I_k,Z_t),  \\
  &amp; \nonumber \text{with } \mathbb P\big( \text{event } e \text { occurs to an individual } I \in (t,t+\mathrm{d}t] | \mathcal{F}_t \big) \simeq  \lambda^e_t (I,Z_t)\mathrm{d}t.
\end{aligned}
\tag{4}</span></span></li>
</ul>
<p>Obviously, nothing can happen to dead or exited individuals, i.e.&nbsp;individuals <span class="math inline">I= (\tau^b, \tau^d, x)</span> with <span class="math inline">\tau^d \leq t</span>. Thus, individual event intensities are assumed to be null for dead/exited individuals: <span class="math display">
    \lambda^e_t ( I,Z_t) = 0, \text{ if }\tau^d \leq t, \text{ so that } \Lambda^e_t (Z_t) = \sum_{k=1}^{N_t^a} \lambda^e_t ( I_k,Z_t),
</span> with <span class="math inline">N^a_t</span> the number of alive individuals at time <span class="math inline">t</span>.</p>
<p>The event’s individual intensity <span class="math inline">\lambda^e_t (I,Z_t)</span> can depend on time (for instance when there is a mortality reduction over time), on the individual’s age <span class="math inline">t-\tau^b</span> and characteristics, but also on the population composition <span class="math inline">Z_t</span>. The dependence of <span class="math inline">\lambda^e</span> on the population <span class="math inline">Z</span> models interactions between individuals in the populations. Hence, two types of individual intensity functions can be implemented in <code>IBMPopSim</code>:</p>
<ol type="1">
<li><p><em>No interactions:</em> The intensity function <span class="math inline">\lambda^e</span> does not depend on the population composition. The intensity at which the event of type <span class="math inline">e</span> occur to an individual <span class="math inline">I</span> only depends on its date of birth and characteristics: <span id="eq-intensity-no-interaction"><span class="math display">
\lambda^e_t (I,Z_t) = \lambda^e(t, I),
\tag{5}</span></span> where <span class="math inline">\lambda^e: \mathbb{R}_+ \times \mathcal{I}\to {\mathbb{R}}^+</span> is a deterministic function. In a given model, we denote by <span class="math inline">\mathcal{E}</span> the set of event types with individual intensity <a href="#eq-intensity-no-interaction" class="quarto-xref">Equation&nbsp;5</a>.</p></li>
<li><p><em>“Quadratic” interactions:</em> The intensity at which an event of type <span class="math inline">e</span> occurs to an individual <span class="math inline">I</span> depends on <span class="math inline">I</span> and on the population composition, through an interaction function <span class="math inline">W^e</span>. The quantity <span class="math inline">W^e(t, I,J)</span> describes the intensity of interactions between two alive individuals <span class="math inline">I</span> and <span class="math inline">J</span> at time <span class="math inline">t</span>, for instance in the presence of competition or cooperation. In this case, we have <span id="eq-intensity-interaction"><span class="math display">
\lambda^e_t(I,Z_t)=\sum_{j=1}^{N_t} W^e(t, I, I_j) = \int_{\mathcal{I}} W^e(t, I, (\tau^b,\tau^d,x)) Z_t (\mathrm{d}\tau^b,\mathrm{d}\tau^d, \mathrm{d}x),
\tag{6}</span></span> where <span class="math inline">W^e(t, I, (\tau^b,\tau^d,x))  = 0</span> if the individual <span class="math inline">J =(\tau^b,\tau^d,x)</span> is dead, i.e.&nbsp;<span class="math inline">\tau^d \leq t</span>.&nbsp;In a given model, we denote by <span class="math inline">\mathcal{E}_W</span> the set of event types with individual intensity <a href="#eq-intensity-interaction" class="quarto-xref">Equation&nbsp;6</a>.</p></li>
</ol>
<p>To summarize, an individual intensity in IBMPopSim can be written as: <span id="eq-individual-intensity"><span class="math display">
    \lambda^e_t(I,Z_t) = \lambda^e(t, I) \mathbf{1}_{\{e \in \mathcal{E}\}} + \biggl( \sum_{j=1}^{N_t} W^e(t, I, I_j) \biggr) \mathbf{1}_{\{e \in \mathcal{E}_W\}}.
\tag{7}</span></span></p>
<div id="exm-popfinale" class="theorem example">
<p><span class="theorem-title"><strong>Example 1</strong></span> &nbsp;</p>
<ol type="1">
<li><p>An example of death intensity without interaction for an individual <span class="math inline">I=(\tau^b, \tau^d, x)</span> alive at time <span class="math inline">t</span>, <span class="math inline">t &lt; \tau^d</span>, is: <span class="math display">
\lambda^d(t,I) =  \alpha_x \exp(\beta_x a(I,t)), \text{ where }  a(I,t) = t-\tau^b
</span> is the age of the individual <span class="math inline">I</span> at time <span class="math inline">t</span>. In this classical case, the death rate of an individual <span class="math inline">I</span> is an exponential (Gompertz) function of the individual’s age, with coefficients depending on the individual’s characteristics <span class="math inline">x</span>.</p></li>
<li><p>In the presence of competition between individuals, the death intensity of an individual <span class="math inline">I</span> also depend on other individuals <span class="math inline">J</span> in the population. For example, if <span class="math inline">I=(\tau^b,\tau^d, x)</span>, with <span class="math inline">x</span> its size, then we can have: <span id="eq-ex-interaction"><span class="math display">
W^d(t,I,J) = (x_J - x)^+ \mathbf{1}_{\{\tau^d_J &gt; t\}}, \quad \forall \; J=(\tau^b_J,\tau^d_J , x_J).
\tag{8}</span></span> This can be interpreted as follows: if the individual <span class="math inline">I</span> meets randomly an individual <span class="math inline">J</span> alive at time <span class="math inline">t</span>, and of bigger size <span class="math inline">x_J &gt; x</span>, then he can die at the intensity <span class="math inline">x_J-x</span>. If <span class="math inline">J</span> is smaller than <span class="math inline">I</span>, then he cannot kill <span class="math inline">I</span>. The bigger is the size <span class="math inline">x</span> of <span class="math inline">I</span>, the lower is his death intensity <span class="math inline">\lambda^d_t(I,Z_t)</span> defined by <span class="math display">
\lambda^d_t(I,Z_t) = \sum_{\genfrac{}{}{0pt}{2}{J\in Z_t,}{x_J &gt; x}} (x_J -x)\mathbf{1}_{\{\tau^d_J &gt; t\}}.
</span></p></li>
<li><p><code>IBMPopSim</code> can simulate IBMs that include intensities expressed as a sum of Poisson intensities and individual intensities of the form <span class="math inline">\Lambda^e(Z_t) =\mu^e_t + \sum_{k=1}^{N_t} \lambda^e(I_k, Z_t)</span>. Other examples are provided in <a href="#sec-insurance-portfolio" class="quarto-xref">Section&nbsp;5</a> and <a href="#sec-example-interaction" class="quarto-xref">Section&nbsp;6</a>. Finally, the global intensity at which an event can occur in the population is defined by: <span id="eq-global-ev-intensity"><span class="math display">
\Lambda_t(Z_t) = \sum_{e\in \mathcal{P}} \mu^e(t) + \sum_{e \in \mathcal E} \Big(\sum_{k=1}^{N_t} \lambda^e(t, I_k)\Big) + \sum_{e \in \mathcal E_W} \Big(\sum_{k=1}^{N_t}\sum_{j=1}^{N_t} W^e(t, I_k, I_j)\Big).
\tag{9}</span></span> An important point is that for events <span class="math inline">e \in \mathcal E</span> without interactions, the global event intensity <span class="math inline">\Lambda^e_t(Z_t) = \sum_{k=1}^{N_t} \lambda^e(t, I_k)</span> is <em>of order</em> <span class="math inline">N_t^a</span> defined in <a href="#eq-Nta" class="quarto-xref">Equation&nbsp;2</a> (number of alive individuals at time <span class="math inline">t</span>). On the other hand, for events <span class="math inline">e \in \mathcal{E}_W</span> with interactions, <span class="math inline">\Lambda^e_t(Z_t) = \sum_{k=1}^{N_t}\sum_{j=1}^{N_t} W^e(t, I_k, I_j)</span> is of order <span class="math inline">(N_t^a)^2</span>. Informally, this means that when the population size increases, events with interaction are more costly to simulate. Furthermore, the numerous computations of the interaction kernel <span class="math inline">W^e</span> can also be quite costly. The randomized Algorithm <a href="#alg-randomized">Algorithm 3</a>, detailed in Section <a href="#sec::simulation_algo_randomized" data-reference-type="ref" data-reference="sec::simulation_algo_randomized">2.3</a>, allows us to overcome these limitations.</p></li>
</ol>
</div>
<section id="events-intensity-bounds" class="level3" data-number="2.4.1">
<h3 data-number="2.4.1" class="anchored" data-anchor-id="events-intensity-bounds"><span class="header-section-number">2.4.1</span> Events intensity bounds</h3>
<p>The simulation algorithms implemented in <code>IBMPopSim</code> are based on an acceptance/rejection procedure, which requires to specify bounds for the various events intensities <span class="math inline">\Lambda^e_t(Z_t)</span>. These bounds are defined differently depending on the expression of the intensity.</p>
<div id="cnj-intensity-poisson" class="theorem conjecture">
<p><span class="theorem-title"><strong>Assumption 1</strong></span> For all events <span class="math inline">e \in \mathcal{P}</span> with Poisson intensity <a href="#eq-poisson-intensity" class="quarto-xref">Equation&nbsp;3</a>, the intensity is assumed to be bounded on <span class="math inline">[0,T]</span>: <span class="math display">
    \forall t \in [0,T], \quad \Lambda^e_t(Z_t) = \mu^e(t) \leq \bar \mu^e.
</span></p>
</div>
<p>When <span class="math inline">e \in \mathcal{E} \cup \mathcal{E}_W</span>, <span class="math inline">\Lambda^e_t(Z_t) =\sum_{k=1}^{N_t} \lambda^e_t(I_k,Z_t)</span>, assuming that <span class="math inline">\Lambda^e_t(Z_t)</span> is uniformly bounded is too restrictive since the event intensity depends on the population size. In this case, the assumption is made on the individual intensity <span class="math inline">\lambda^e</span> or on the interaction function <span class="math inline">W^e</span>, depending on the situation.</p>
<div id="cnj-intensity1" class="theorem conjecture">
<p><span class="theorem-title"><strong>Assumption 2</strong></span> For all event types <span class="math inline">e \in \mathcal{E}</span>, the associated individual event intensity <span class="math inline">\lambda^e</span> with no interactions, <em>i.e.</em> <span class="math inline">\lambda^e</span> verifies <a href="#eq-intensity-no-interaction" class="quarto-xref">Equation&nbsp;5</a>, is assumed to be uniformly bounded: <span class="math display">
    \lambda^e(t, I) \leq \bar \lambda^e, \quad \forall \;  t\in [0, T],  \;   I \in \mathcal{I}.
</span> In particular, <span id="eq-def-bar-Lambda"><span class="math display">
    \forall t \in [0,T], \quad \Lambda^e_t (Z_t) = \sum_{k=1}^{N_t} \lambda^e(t, I) \leq \bar \lambda^e  N_t .
\tag{10}</span></span></p>
</div>
<div id="cnj-intensity2" class="theorem conjecture">
<p><span class="theorem-title"><strong>Assumption 3</strong></span> For all event types <span class="math inline">e \in \mathcal{E}_W</span>, the associated interaction function <span class="math inline">W^e</span> is assumed to be uniformly bounded: <span class="math display">
    W^e(t, I, J) \leq \bar W^e, \quad \forall \; t\in [0,T], \;   I, J \in \mathcal{I}.
</span> In particular, <span class="math inline">\forall t \in [0,T]</span>, <span class="math display">
    \lambda^e_t (I,Z_t) = \sum_{j=1}^{N_t} W^e(t, I, I_j)  \leq  \bar W^e N_t, \quad \text{and} \quad \Lambda^e_t (Z_t) \leq \bar W^e (N_t)^2.
</span></p>
</div>
<p><a href="#cnj-intensity-poisson" class="quarto-xref">Assumption&nbsp;1</a>, <a href="#cnj-intensity1" class="quarto-xref">Assumption&nbsp;2</a> and <a href="#cnj-intensity2" class="quarto-xref">Assumption&nbsp;3</a> yield that events in the population occur with the global event intensity&nbsp;<span class="math inline">\Lambda_t(Z_t)</span>, given in <a href="#eq-global-ev-intensity" class="quarto-xref">Equation&nbsp;9</a>, which is dominated by a polynomial function in the population size: <span id="eq-def-bar-Lambda"><span class="math display">
    \Lambda_t(Z_t) \leq \bar \Lambda(N_t), \quad \text{with }  \bar \Lambda (n) = \sum_{e \in \mathcal{P}} \bar \mu^e + \sum_{e\in \mathcal{E}}\bar \lambda^e  n + \sum_{e \in \mathcal E_W} \bar W^e n^2.
\tag{11}</span></span> This bound is linear in the population size if there are no interactions, and quadratic if there at least is an event including interactions. This assumption is the key to the algorithms implemented in <code>IBMPopSim</code>. Before presenting the simulation algorithm, we close this section with a rigorous definition of an IBM, based on the pathwise representation of its dynamics a Stochastic Differential Equation (SDE) driven by Poisson random measures.</p>
</section>
</section>
<section id="pathwise-representation" class="level2" data-number="2.5">
<h2 data-number="2.5" class="anchored" data-anchor-id="pathwise-representation"><span class="header-section-number">2.5</span> Pathwise representation</h2>
<p>Since the seminal paper of <span class="citation" data-cites="FouMel04">(<a href="#ref-FouMel04" role="doc-biblioref">Fournier and Méléard 2004</a>)</span>, it has been shown in many examples that a stochastic IBM dynamics can be defined rigorously as the unique solution of an SDE driven by Poisson measures, under reasonable non explosion conditions. In the following, we introduce a unified framework for the pathwise representation of the class of stochastic IBMs introduced above. Some recalls on Poisson random measures are presented in the Appendix <a href="#sec-recall-poisson" class="quarto-xref">Section&nbsp;7.1</a>, and for more details on these representations on particular examples, we refer to the abundant literature on the subject.</p>
<p>In the following we consider an individual-based stochastic population <span class="math inline">(Z_t)_{t\in [0,T]}</span>, keeping the notations introduced in <a href="#sec-events" class="quarto-xref">Section&nbsp;2.3</a> and <a href="#sec-event-intensity" class="quarto-xref">Section&nbsp;2.4</a> for the events and their intensities. In particular, the set of events types that define the population evolution is denoted by <span class="math inline">\mathcal{P} \cup \mathcal{E} \cup \mathcal{E}_W \subset E</span>, with <span class="math inline">\mathcal{P}</span> the set of events types with Poisson intensity verifying <a href="#cnj-intensity-poisson" class="quarto-xref">Assumption&nbsp;1</a>, <span class="math inline">\mathcal{E}</span> the set of events types with individual intensity and no interaction, verifying <a href="#cnj-intensity1" class="quarto-xref">Assumption&nbsp;2</a> and finally <span class="math inline">\mathcal{E}_W</span> the set of event types with interactions, verifying <a href="#cnj-intensity2" class="quarto-xref">Assumption&nbsp;3</a>.</p>
<section id="non-explosion-criterion" class="level3" data-number="2.5.1">
<h3 data-number="2.5.1" class="anchored" data-anchor-id="non-explosion-criterion"><span class="header-section-number">2.5.1</span> Non explosion criterion</h3>
<p>First, one has to ensure that the number of events occurring in the population will not explode in finite time, leading to an infinite simulation time. <a href="#cnj-intensity1" class="quarto-xref">Assumption&nbsp;2</a> and <a href="#cnj-intensity2" class="quarto-xref">Assumption&nbsp;3</a> are not sufficient to guarantee the non explosion of the event number, due to the potential explosion of the population size in the presence of interactions. An example is the case when only birth events occur, with an intensity <span class="math inline">\Lambda^b_t(Z_t) = C_b (N_t^a)^2</span> (<span class="math inline">W^b(t, I,J) =C_b</span>). Then, the number of alive individuals <span class="math inline">(N_t^a)_{t\geq 0}</span> is a well-known pure birth process of intensity function <span class="math inline">g(n) = C_b n^2</span> (intensity of moving from state <span class="math inline">n</span> to <span class="math inline">n+1</span>). This process explodes in finite time, since <span class="math inline">g</span> does not verify the necessary and sufficient non explosion criterion for pure birth Markov processes: <span class="math inline">\sum_{n=1}^\infty \frac{1}{g(n)} = \infty</span> (see e.g.&nbsp;Theorem 2.2 in <span class="citation" data-cites="BanMel15">(<a href="#ref-BanMel15" role="doc-biblioref">Bansaye and Méléard 2015</a>)</span>). There is thus an explosion in finite time of birth events.</p>
<p>This example shows that the important point for non explosion is to control the population size. We give below a general sufficient condition on birth and entry event intensities, in order for the population size to stay finite in finite time. This ensures that the number of events does not explode in finite time. Informally, the idea is to control the intensities by a pure birth intensity function verifying the non-explosion criterion.</p>
<div id="cnj-non-explosion" class="theorem conjecture">
<p><span class="theorem-title"><strong>Assumption 4</strong></span> Let <span class="math inline">e=b</span> or <span class="math inline">en</span>, a birth or entry event type. If the intensity at which the events of type <span class="math inline">e</span> occur in the population are not Poissonian, i.e.&nbsp;<span class="math inline">e \in \mathcal{E} \cup \mathcal{E}_W</span>, then there exists a function <span class="math inline">f^e : {\mathbb{N}}\to (0, +\infty)</span>, such that <span class="math display">
    \sum_{n=1}^{\infty} \frac{1}{nf^e(n)} = \infty,
</span> and for all individual <span class="math inline">I \in \mathcal{I}</span> and population measure <span class="math inline">Z = \sum_{k=1}^{n} \delta_{I_k}</span> of size <span class="math inline">n</span>, <span class="math display">
    \lambda^e_t (I, Z) \leq f^e(n), \; \forall \; 0\leq t \leq T.
</span></p>
</div>
<div id="rem">
<p>If <span class="math inline">e \in \mathcal{E}</span>, <span class="math inline">\lambda_t^e(I,Z) = \lambda^e(t,I) \leq \bar{\lambda}^e</span> by the domination <a href="#cnj-intensity2" class="quarto-xref">Assumption&nbsp;3</a>, then <a href="#cnj-non-explosion" class="quarto-xref">Assumption&nbsp;4</a> is always verified with <span class="math inline">f^e(n) = \bar{\lambda}^e</span>.</p>
</div>
<p><a href="#cnj-non-explosion" class="quarto-xref">Assumption&nbsp;4</a> yields that the global intensity <span class="math inline">\Lambda_t^e(\cdot)</span> of event <span class="math inline">e</span> is bounded by a function <span class="math inline">g^e</span> only depending on the population size: <span class="math display">
    \Lambda_t^e (Z) \leq g^e(n) := nf^e(n), \quad \text{with }\sum_{n=1}^{\infty} \frac{1}{g^e(n)} = \infty.
</span> If <span class="math inline">e\in \mathcal{P}</span> has a Poisson intensity, then <span class="math inline">\Lambda_t^e(Z) =\mu^e_t</span> always verifies the previous equation with <span class="math inline">g^e(n) = \bar \mu^e</span>.</p>
<p>Before introducing the IBM SDE, let us give an idea of the equation construction. Between two successive events, the population composition <span class="math inline">Z_t</span> stays constant, since the population process <span class="math inline">(Z_t)_{t \geq 0}</span> is a pure jump process. Furthermore, since each event type is characterized by an intensity function, the jumps occurring in the population can be represented by restriction and projection of a Poisson measure defined on a larger state space. More precisely, we introduce a random Poisson measure <span class="math inline">Q</span> on <span class="math inline">\mathbb R^+ \times \mathcal{J}\times \mathbb{R}^+</span>, with <span class="math inline">\mathcal{J}= \mathbb N \times(\mathcal E \cup \mathcal{E}_W)</span>. <span class="math inline">Q</span> is composed of random quadruplets <span class="math inline">(\tau, k , e, \theta)</span>, where <span class="math inline">\tau</span> represents a potential event time for an individual <span class="math inline">I_k</span> and event type <span class="math inline">e</span>. The last variable <span class="math inline">\theta</span> is used to accept/reject this proposed event, depending on the event intensity. Hence, the Poisson measure is restricted to a certain random set and then projected on the space of interest <span class="math inline">{\mathbb{R}}^+ \times \mathcal{J}</span>. If the event is accepted, then a jump <span class="math inline">\phi^e(\tau,I_k)</span> occurs.</p>
<div id="thm-eq-Z" class="theorem">
<p><span class="theorem-title"><strong>Theorem 1 (Pathwise representation)</strong></span> Let <span class="math inline">T\in {\mathbb{R}}^+</span> and <span class="math inline">\mathcal{J}= \mathbb N \times(\mathcal E \cup \mathcal{E}_W)</span>. Let <span class="math inline">Q</span> be a random Poisson measure on <span class="math inline">\mathbb R^+ \times \mathcal{J}\times \mathbb{R}^+</span>, of intensity <span class="math inline">\mathrm{d}t \delta_{\mathcal{J}}(\mathrm{d}k,\mathrm{d}e)  \mathbf{1}_{[0,\bar \lambda^e]} (\theta)\mathrm{d}\theta</span>, with <span class="math inline">\delta_{\mathcal{J}}</span> the counting measure on <span class="math inline">\mathcal{J}</span>. Finally, let <span class="math inline">Q^{\mathcal P}</span> be a random Poisson measure on <span class="math inline">\mathbb R^+ \times \mathcal{P}  \times \mathbb{R}^+</span>, of intensity <span class="math inline">\mathrm{d}t \delta_{\cal P}(\mathrm{d}e)  \mathbf{1}_{[0,\bar \mu^e]} (\theta)\mathrm{d}\theta</span>, and <span class="math inline">Z_0= \sum_{k=1}^{N_0} \delta_{I_k}</span> an initial population. Then, under <a href="#cnj-non-explosion" class="quarto-xref">Assumption&nbsp;4</a> , there exists a unique measure-valued population process <span class="math inline">Z</span>, strong solution on the following SDE driven by the Poisson measure <span class="math inline">Q</span>: <span id="eq-sde-eq-Z"><span class="math display">
    \begin{aligned}
    Z_t = Z_0 &amp;+ \int_0^t \int_{ \mathcal{J}\times \mathbb R^+ }\phi^e (s , I_k)  \mathbf{1}_{\{k \leq N_{s^-}\} }\mathbf{1}_{\{\theta \leq \lambda_s^e(I_k, Z_{s^-})\}} Q (\mathrm{d}s ,\mathrm{d}k , \mathrm{d}e, \mathrm{d}\theta ) \\
    \nonumber &amp;+   \int_0^t \int_{\mathcal{P} \times \mathbb R^+}  \phi^e(s, I_{s^-}) \mathbf{1}_{\{\theta \leq \mu^e(s) \}} Q^{\mathcal{P}} (\mathrm{d}s ,\mathrm{d}e,  \mathrm{d}\theta),  \qquad \forall  0 \leq t \leq T,
\end{aligned}
\tag{12}</span></span> and where <span class="math inline">I_{s^-}</span> is an individual, chosen uniformly among alive individuals in the population <span class="math inline">Z_{s^-}</span>.</p>
</div>
<p>The proof of <a href="#thm-eq-Z" class="quarto-xref">Theorem&nbsp;1</a> is detailed in the Appendix, <a href="#sec-prf-thm-eq-Z" class="quarto-xref">Section&nbsp;7.2.2</a>. Note that <a href="#eq-sde-eq-Z" class="quarto-xref">Equation&nbsp;12</a> is an SDE describing the evolution of the IBM, the intensity of the events in the right hand side of the equation depending on the population process <span class="math inline">Z</span> itself. The main idea of the proof of <a href="#thm-eq-Z" class="quarto-xref">Theorem&nbsp;1</a> is to use the non explosion property of <a href="#lem-non-explosion" class="quarto-xref">Lemma&nbsp;1</a>, and to write the r.h.s of <a href="#eq-sde-eq-Z" class="quarto-xref">Equation&nbsp;12</a> as a sum of simple equations between two successive events, solved by induction.</p>
<div id="lem-non-explosion" class="theorem lemma">
<p><span class="theorem-title"><strong>Lemma 1</strong></span> Let <span class="math inline">Z</span> be a solution of <a href="#eq-sde-eq-Z" class="quarto-xref">Equation&nbsp;12</a> on <span class="math inline">{\mathbb{R}}^+</span>, with <span class="math inline">(T_n)_{n\geq 0}</span> its jump times, <span class="math inline">T_0 = 0</span>. If <a href="#cnj-non-explosion" class="quarto-xref">Assumption&nbsp;4</a> is satisfied, then <span class="math display">
    \lim_{n \to \infty} T_n = \infty, \quad {\mathbb{P}}\text{-a.s.}
</span></p>
</div>
<p>The proof of <a href="#lem-non-explosion" class="quarto-xref">Lemma&nbsp;1</a>, detailed in Appendix <a href="#sec-prf-lem-non-explosion" class="quarto-xref">Section&nbsp;7.2.3</a> is more technical and rely on pathwise comparison result, generalizing those obtained in <span class="citation" data-cites="KaaElK20">(<a href="#ref-KaaElK20" role="doc-biblioref">Kaakai and El Karoui 2023</a>)</span>. An alternative pathwise representation of the population process, inspired by the randomized <a href="#alg-randomized">Algorithm 3</a> is given as well in <a href="#prp-randomized" class="quarto-xref">Proposition&nbsp;3</a>.</p>
</section>
</section>
</section>
<section id="sec-simulation" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Population simulation</h1>
<p>We now present the main algorithm for simulating the evolution of an IBM over <span class="math inline">[0,T]</span>.The algorithm implemented in <code>IBMPopSim</code> allows the exact simulation of <a href="#eq-sde-eq-Z" class="quarto-xref">Equation&nbsp;12</a>, based on an acceptance/reject algorithm for simulating random times called <em>thinning</em>. The exact simulation of event times with this acceptance/reject procedure is closely related to the simulations of inhomogeneous Poisson processes by the so-called thinning algorithm, often attributed to <span class="citation" data-cites="LewShe79">Lewis and Shedler (<a href="#ref-LewShe79" role="doc-biblioref">1979</a>)</span>. The simulation methods for inhomogeneous Poisson processes can be adapted to IBMs, and we introduce in this section a general algorithm extending those by <span class="citation" data-cites="FouMel04">Fournier and Méléard (<a href="#ref-FouMel04" role="doc-biblioref">2004</a>)</span> (see also <span class="citation" data-cites="FerTra09">Ferrière and Tran (<a href="#ref-FerTra09" role="doc-biblioref">2009</a>)</span>, <span class="citation" data-cites="Ben10">Bensusan (<a href="#ref-Ben10" role="doc-biblioref">2010</a>)</span>).</p>
<p>The algorithm is based on exponential “candidate” event times, chosen with a (constant) intensity which must be greater than the global event intensity <span class="math inline">\Lambda_t(Z_t)</span> (<a href="#eq-global-intensity" class="quarto-xref">Equation&nbsp;4</a>). Starting from time <span class="math inline">t</span>, once a candidate event time <span class="math inline">t + \bar T_\ell</span> has been proposed, a candidate event type <span class="math inline">e</span> (birth, death,...) is chosen with a probability <span class="math inline">p^e</span> depending on the event intensity bounds <span class="math inline">\bar \mu^e</span>, <span class="math inline">\bar \lambda^e</span> and <span class="math inline">\bar W^e</span>, as defined in <a href="#cnj-intensity1" class="quarto-xref">Assumption&nbsp;2</a> and <a href="#cnj-intensity2" class="quarto-xref">Assumption&nbsp;3</a>. An individual <span class="math inline">I</span> is then drawn from the population. Finally, it remains to accept or reject the candidate event with a probability <span class="math inline">q^e(t,I,Z_t)</span> depending on the true event intensity. If the candidate event time is accepted, then the event <span class="math inline">e</span> occurs at time <span class="math inline">t + \bar T_\ell</span> to the individual <span class="math inline">I</span>. The main idea of the algorithm implemented can be summarized as follows:</p>
<ol type="1">
<li>Draw a candidate time <span class="math inline">t + \bar T_\ell</span> and candidate event type <span class="math inline">e</span>.</li>
<li>Draw a uniform variable <span class="math inline">\theta \sim \mathcal{U}([0, 1])</span> and individual <span class="math inline">I</span>.</li>
<li><strong>If</strong> <span class="math inline">\theta \leq q^e(t,I,Z_t)</span> <strong>then</strong> event <span class="math inline">e</span> occur to individual <span class="math inline">I</span>, <strong>else</strong> Do nothing and start again from <span class="math inline">t + \bar T_\ell</span>.</li>
</ol>
<p>Before introducing the main algorithms in more details, we recall briefly the thinning procedure for simulating inhomogeneous Poisson processes, as well as the links with pathwise representations. Some recalls on Poisson random measures are presented in <a href="#sec-recall-poisson" class="quarto-xref">Section&nbsp;7.1</a>. For a more general presentation of thinning of a Poisson random measure, see <span class="citation" data-cites="Dev86 Cin11 Kal17">(<a href="#ref-Dev86" role="doc-biblioref">Devroye 1986</a>; <a href="#ref-Cin11" role="doc-biblioref">Çinlar 2011</a>; <a href="#ref-Kal17" role="doc-biblioref">Kallenberg 2017</a>)</span>.</p>
<section id="sec-thinning" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="sec-thinning"><span class="header-section-number">3.1</span> Thinning of Poisson measure</h2>
<p>Let us start with the simulation and pathwise representation of an inhomogeneous Poisson process on <span class="math inline">[0,T]</span> with intensity <span class="math inline">(\Lambda(t))_{t\in [0,T]}</span>. The thinning procedure is based on the fundamental assumption that <span class="math inline">\Lambda(t) \leq  \bar \Lambda</span> is bounded on <span class="math inline">[0,T]</span>. In this case, the inhomogeneous Poisson can be obtained from an homogeneous Poisson process of intensity <span class="math inline">\bar \Lambda</span>, which can be simulated easily.</p>
<p>First, the Poisson process can be extended to a Marked Poisson measure <span class="math inline">\bar Q:= \sum_{\ell \ge 1} \delta_{(\bar T_\ell, \bar \Theta_\ell)}</span> on <span class="math inline">(\mathbb{R}^+)^2</span>, defined as follow:</p>
<ul>
<li><p>The jump times of <span class="math inline">(\bar T_\ell)_{\ell \ge 1}</span> of <span class="math inline">\bar Q</span> are the jump times of a Poisson process of intensity <span class="math inline">\bar \Lambda</span>.</p></li>
<li><p>The marks <span class="math inline">(\bar \Theta_\ell)_{\ell \ge 1}</span> are <em>i.i.d.</em> random variables, uniformly distributed on <span class="math inline">[0, \bar \Lambda]</span>.</p></li>
</ul>
<p>By <a href="#prp-marked-poisson" class="quarto-xref">Proposition&nbsp;6</a> , <span class="math inline">\bar{Q}</span> is a Poisson random measure with mean measure <span class="math display">
    \bar \mu(\mathrm{d}t, \mathrm{d}\theta): = \bar \Lambda \mathrm{d}t
    \frac{\mathbf{1}_{[0, \bar \Lambda]}(\theta)}{\bar \Lambda} \mathrm{d}\theta= \mathrm{d}t  \mathbf{1}_{[0, \bar \Lambda]}(\theta) \mathrm{d}\theta.
</span> In particular, the average number of atoms <span class="math inline">(\bar T_\ell, \bar \Theta_\ell)</span> in <span class="math inline">[0,t]\times [0,h]</span> is <span class="math display">
    \mathbb{E}[Q([0,t]\times [0,h])]={\mathbb{E}}[\sum_{\ell} \boldsymbol{1}_{[0,t]\times [0,h]} (\bar T_\ell, \bar \Theta_{\ell})]  = \int_{(\mathbb{R}^+)^2}  \bar \mu(\mathrm{d}t, \mathrm{d}\theta)  = t (\bar \Lambda \wedge h).
</span> The thinning is based on the restriction property for Poisson measure: for a measurable set <span class="math inline">\Delta\subset {\mathbb{R}}^+\times {\mathbb{R}}^+</span>, the restriction <span class="math inline">Q^\Delta:= \boldsymbol{1}_{\Delta}\bar Q</span> of <span class="math inline">\bar Q</span> to <span class="math inline">\Delta</span> (by taking only atoms in <span class="math inline">\Delta</span>) is also a Poisson random measure of mean measure <span class="math inline">\mu^{\Delta}(\mathrm{d}t, \mathrm{d}\theta)  = \boldsymbol{1}_{\Delta}(t,\theta) \bar \mu(\mathrm{d}t, \mathrm{d}\theta).</span></p>
<p>In order to obtain an inhomogeneous Poisson measure of intensity <span class="math inline">(\Lambda(t))</span>, the “good” choice of <span class="math inline">\Delta</span> is the hypograph of <span class="math inline">\Lambda</span>: <span class="math inline">\Delta =\{ (t,\theta) \in [0,T]\times [0,\bar \Lambda] ; \; \theta \leq \Lambda(t)\}</span> (see <a href="#fig-thinning" class="quarto-xref">Figure&nbsp;1</a>). Then, <span class="math display">
    Q^\Delta = \sum_{\ell \ge 1} \mathbf{1}_{\left\{\bar \Theta_\ell \le \Lambda(\bar T_\ell)\right\}} \delta_{(\bar T_\ell, \bar \Theta_\ell)},
</span> and since <span class="math inline">\Lambda(t) \leq \bar \Lambda</span>, on <span class="math inline">[0,T]</span>: <span class="math display">
\begin{aligned}
    \mu^{\Delta}(\mathrm{d}t, \mathrm{d}\theta) &amp; = \boldsymbol{1}_{\{ \theta \leq \Lambda(t)\}}  \mathrm{d}t
\mathbf{1}_{[0, \bar \Lambda]}(\theta)\mathrm{d}\theta = \boldsymbol{1}_{\{\theta \leq \Lambda(t)\}} \mathrm{d}t \mathrm{d}\theta.
\end{aligned}
</span></p>
<div id="fig-thinning" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-thinning-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<embed src="img/plot_thinning.tex" class="img-fluid">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-thinning-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Realization of a Marked Poisson measure <span class="math inline">\bar Q</span> on <span class="math inline">[0,T]</span> with mean measure <span class="math inline">\bar \mu(\mathrm{d} t, \mathrm{d} \theta) = \mathrm{d} t \mathbf{1}_{[0, \bar \Lambda]}(\theta) \mathrm{d} \theta</span> (red crosses), and realization of the restriction <span class="math inline">\bar Q^\Delta</span> where <span class="math inline">\Delta = \{ (t,\theta)\in [0,T]\times[0, \bar \Lambda], \theta \leq \Lambda(t) \}</span> (blue circles). The projection of <span class="math inline">\bar Q^\Delta</span> on first component is an inhomogeneous Poisson process on <span class="math inline">[0,T]</span> of intensity <span class="math inline">(\Lambda(t))</span> and jump times <span class="math inline">(T_k)_{k \ge 1}</span>.
</figcaption>
</figure>
</div>
<p>Finally, the inhomogeneous Poisson process is obtained by the projection <a href="#prp-proj-poisson-measure" class="quarto-xref">Proposition&nbsp;5</a>, which states that the jump times of <span class="math inline">Q^\Delta</span> are the jump times of an inhomogeneous Poisson process of intensity <span class="math inline">(\Lambda(t))</span>.</p>
<div id="prp-thinning" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 1</strong></span> The counting process <span class="math inline">N^\Lambda</span>, projection of <span class="math inline">Q^{\Delta}</span> on the time component and defined by, <span id="eq-thinning-inhomogeneous-poisson"><span class="math display">
    N^{\Lambda}_t := Q^{\Delta}( [0,t] \times {\mathbb{R}}^+) = \int_0^t \int_{{\mathbb{R}}^+} \boldsymbol{1}_{\{\theta \leq \Lambda(s)\}} \bar Q(\mathrm{d}s, \mathrm{d}\theta) = \sum_{\ell \geq 1} \mathsf{1}_{\{ \bar T_\ell \leq t \}} \mathsf{1}_{\{\bar \Theta_\ell \leq  \Lambda(\bar T_\ell) \}},  \quad \forall t \in [0,T],
\tag{13}</span></span> is an inhomogeneous Poisson process on <span class="math inline">[0,T]</span> of intensity function <span class="math inline">(\Lambda(t))_{t\in [0,T]}</span>. The thinning <a href="#eq-thinning-inhomogeneous-poisson" class="quarto-xref">Equation&nbsp;13</a> is a pathwise representation of <span class="math inline">N^\Lambda</span> by <em>restriction and projection</em> of the Poisson measure <span class="math inline">Q</span> on <span class="math inline">[0,T]</span>.</p>
</div>
<p>The previous proposition yields a straightforward thinning algorithm to simulate the jump times <span class="math inline">(T_k)_{k \ge 1}</span> of an inhomogeneous Poisson process of intensity <span class="math inline">\Lambda(t)</span>, by selecting jump times <span class="math inline">\bar T_\ell</span> such that <span class="math inline">\bar \Theta_\ell \le \Lambda(\bar T_\ell)</span>.</p>
<section id="sec-vector" class="level3" data-number="3.1.1">
<h3 data-number="3.1.1" class="anchored" data-anchor-id="sec-vector"><span class="header-section-number">3.1.1</span> Multivariate Poisson process</h3>
<p>This can be extended to the simulation of multivariate inhomogeneous Poisson processes, which is an important example before tackling the simulation of an IBM.</p>
<p>Let <span class="math inline">(N^j)_{j \in \mathcal{J}}</span> be a (inhomogeneous) multivariate Poisson process indexed by a finite set <span class="math inline">\mathcal{J}</span>, such that <span class="math inline">\forall j \in \mathcal{J}</span>, the intensity <span class="math inline">(\lambda_j(t))_{t\in [0,T]}</span> of <span class="math inline">N_j</span> is bounded on <span class="math inline">[0,T]</span>: <span class="math display">
    \sup_{t\in[0,T]} \lambda_j(t) \le \bar \lambda_j, \text{ and let }
    \bar \Lambda = \sum_{j \in \mathcal{J}} \bar \lambda_j.
</span> Recall that such multivariate counting process can be rewritten as a Poisson random measure <span class="math inline">N= \sum_{k\geq 1} \delta_{(T_k,J_k)}</span> on <span class="math inline">{\mathbb{R}}^+\times \mathcal{J}</span> (see e.g.&nbsp;Sec. 2 of Chapter 6 in&nbsp;<span class="citation" data-cites="Cin11">(<a href="#ref-Cin11" role="doc-biblioref">Çinlar 2011</a>)</span>), where <span class="math inline">T_k</span> is the <span class="math inline">k</span>th jump time of <span class="math inline">\sum_{j\in \mathcal{J}} N^j</span> and <span class="math inline">J_k</span> corresponds to the component of the the vector which jumps. In particular, <span class="math inline">N^j_t = N([0,t]\times \{j\})</span>.</p>
<p>Once again the simulation of such process can be obtained from the simulation of a (homogeneous) multivariate Poisson process of intensity vector <span class="math inline">(\bar{\lambda}_j)_{j \in \mathcal{J}}</span>, extended into a Poisson measures by adding marks on <span class="math inline">{\mathbb{R}}^+</span>. Thus, we introduce the Marked Poisson measure <span class="math inline">\bar Q = \sum \delta_{(\bar T_\ell, \bar J_\ell, \bar \Theta_\ell)}</span> on <span class="math inline">{\mathbb{R}}^+  \times \mathcal{J}\times {\mathbb{R}}^+</span>, such that:</p>
<ul>
<li>The jump times <span class="math inline">(\bar T_\ell)</span> of <span class="math inline">\bar Q</span> are the jump times of a Poisson measure of intensity <span class="math inline">\bar \Lambda</span>.</li>
<li>The variables <span class="math inline">(\bar J_\ell)</span> are <em>i.i.d.</em> random variables on <span class="math inline">\mathcal{J}</span>, with <span class="math inline">\displaystyle p_j= {\mathbb{P}}(\bar J_1 = j)= \bar \lambda_j/\bar \Lambda</span> and representing the component of the vector which jumps.</li>
<li>The marks <span class="math inline">(\bar \Theta_\ell)</span> are independent variables with <span class="math inline">\bar \Theta_\ell</span> a uniform random variable on <span class="math inline">[0,\bar \lambda_{{\bar J}_\ell}]</span>, <span class="math inline">\forall \ell \geq 1</span>.</li>
</ul>
<p>By <a href="#prp-marked-poisson" class="quarto-xref">Proposition&nbsp;6</a> and <a href="#prp-proj-poisson-measure" class="quarto-xref">Proposition&nbsp;5</a>, each measure <span class="math inline">\bar Q_j (\mathrm{d}t, \mathrm{d}\theta) = \bar Q(\mathrm{d}t, \{j\}, \mathrm{d}\theta) = \sum_{\ell \geq 1} \mathsf{1}_{\{\bar J_\ell=j \}} \delta_{(\bar T_\ell, \bar \Theta_\ell)}</span> is a marked Poisson measure of intensity <span class="math display">
    \bar \mu_j ( \mathrm{d}t  ,\mathrm{d}\theta) = \bar{\Lambda}p_j \mathrm{d}t  \frac{\mathsf{1}_{\{\theta \leq \bar \lambda_{j}\}}(\theta)}{\bar \lambda_{j}} \mathrm{d}\theta = \mathrm{d}t  \mathsf{1}_{\{\theta \leq \bar \lambda_{j}\}}(\theta) \mathrm{d}\theta.
</span> As a direct application of <a href="#prp-thinning" class="quarto-xref">Proposition&nbsp;1</a> , the inhomogeneous multivariate Poisson process is obtained by restriction of each measures <span class="math inline">\bar Q_j</span> to <span class="math inline">\Delta_j = \{ (t, \theta) \in [0,T] \times [0,\bar \lambda_j] ;\; \theta \leq \lambda_j(t) \}</span> and projection.</p>
<div id="prp-thinning-vector" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 2</strong></span> The multivariate counting process <span class="math inline">(N^j)_{j \in \mathcal{J}}</span>, defined for all <span class="math inline">j \in \mathcal{J}</span> and <span class="math inline">t \in [0,T]</span> by thinning and projection of <span class="math inline">\bar Q</span>: <span class="math display">
    N^j_t  := \int_0^t \int_{ {\mathbb{R}}^+} \boldsymbol{1}_{\{\theta \leq \lambda_j(s)\}} \bar{Q}(\mathrm{d}s, \{j\}, \mathrm{d}\theta) = \sum_{\ell \geq 1} \mathsf{1}_{\{ \bar T_\ell \leq t \}}\mathsf{1}_{\{\bar J_\ell = j\}} \mathsf{1}_{\{\bar \Theta_\ell \leq  \lambda_j (\bar T_\ell ) \}},
</span> is an inhomogeneous Poisson process of intensity vector <span class="math inline">(\lambda_j(t))_{j\in\mathcal{J}}</span> on <span class="math inline">[0,T]</span>.</p>
</div>
<p><a href="#prp-thinning-vector" class="quarto-xref">Proposition&nbsp;2</a> yields the following simulation <a href="#alg-thinning2">Algorithm 1</a> for multivariate Poisson processes.</p>
<div id="alg-thinning2" class="pseudocode-container" data-line-number-punc=":" data-no-end="false" data-indent-size="1.2em" data-pseudocode-index="1" data-alg-title="Algorithm" data-line-number="true" data-comment-delimiter="//">
<div class="pseudocode">
\begin{algorithm} \caption{Thinning algorithm for multivariate inhomogeneous Poisson processes.} \begin{algorithmic} \State \textbf{Input:} Functions $\lambda_j: [0,T] \to [0,\bar \lambda]$ and $\bar \lambda_j$, $\bar \Lambda = \sum_{j \in \mathcal{J}} \bar \lambda_j$ \State \textbf{Output:} Points $(T_k, J_k)$ of Poisson measure $N$ on $[0,T] \times \mathcal{J}$ \State Initialization $T_0 \longleftarrow 0$, $\bar T_0 \longleftarrow 0$ \While{$T_k &lt; T$} \Repeat \State increment iterative variable $\ell \longleftarrow \ell+1$ \State compute next proposed time $\bar T_{\ell} \longleftarrow \bar T_{\ell-1} + S_\ell$ with $S_\ell \sim \mathcal{E}(\bar \Lambda)$ \State draw $\bar J_\ell \sim \mathcal{U}\big\{ \bar \lambda_j / \bar \Lambda, j \in \mathcal{J} \big\}$ i.e. $\mathbb{P}(\bar J_\ell = j) = \bar \lambda_j / \bar \Lambda$ \State draw $\bar \Theta_\ell \sim \mathcal{U}([0,\bar \lambda_{\bar J_\ell}])$ \Until{accepted event $\bar \Theta_\ell \le \lambda_{\bar J_\ell}(\bar T_{\ell})$} \State record $(T_k, J_k) \longleftarrow (\bar T_{\ell}, \bar J_\ell)$ as accepted point \EndWhile \end{algorithmic} \end{algorithm}
</div>
</div>
<div id="rem-alternate-thinning" class="proof remark">
<p><span class="proof-title"><em>Remark 2</em>. </span>The acceptance/rejection <a href="#alg-thinning2">Algorithm 1</a> can be efficient when the functions <span class="math inline">\lambda_j</span> are of different order, and thus bounded by different <span class="math inline">\bar \lambda_j</span>. However, it is important to note that the simulation of the discrete random variables <span class="math inline">(\bar J_\ell)</span> can be costly (compared to a uniform law) when <span class="math inline">\mathcal{J}</span> is large, for instance when an individual is drawn from a large population. In this case, an alternative is to choose the same bound <span class="math inline">\bar \lambda_j= \bar \lambda</span> for all <span class="math inline">j \in \mathcal{J}</span>. Then the marks <span class="math inline">(\bar J_\ell, \bar \Theta_\ell)</span> are <em>i.i.d.</em> uniform variables on <span class="math inline">\mathcal{J}\times [0,\bar \lambda]</span>, faster to simulate.</p>
</div>
</section>
</section>
<section id="sec-simulation-algo" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="sec-simulation-algo"><span class="header-section-number">3.2</span> Simulation algorithm</h2>
<p>Let us now come back to the simulation of the IBM introduced in <a href="#sec-ibm" class="quarto-xref">Section&nbsp;2</a>. For ease of notations, we assume that there are no event with Poisson intensity (<span class="math inline">\mathcal{P} =\emptyset</span>), so that all events that occur are of type <span class="math inline">e \in \mathcal{E} \cup \mathcal{E}_W</span>, with individual intensity <span class="math inline">\lambda_t^e(I,Z_t)</span> depending on the population composition <span class="math inline">Z_t</span> (<span class="math inline">e \in \mathcal{E}_W</span>) or not (<span class="math inline">e \in \mathcal{E}</span>), as defined in <a href="#eq-individual-intensity" class="quarto-xref">Equation&nbsp;7</a> and verifying either <a href="#cnj-intensity1" class="quarto-xref">Assumption&nbsp;2</a> or <a href="#cnj-intensity2" class="quarto-xref">Assumption&nbsp;3</a>. The global intensity <a href="#eq-global-ev-intensity" class="quarto-xref">Equation&nbsp;9</a> at time <span class="math inline">t \in [0,T]</span> is thus <span id="eq-def-intensity"><span class="math display">
    \Lambda_t(Z_t) = \sum_{e \in \mathcal{E}} \Big( \sum_{k=1}^{N_t} \lambda^e(t, I_k) \Big)
    + \sum_{e \in \mathcal{E}_W} \Big( \sum_{k=1}^{N_t} \sum_{j=1}^{N_t} W^e(t, I_k, I_j) \Big) \leq \bar \Lambda(N_t),
\tag{14}</span></span> with <span class="math inline">\bar \Lambda(n) = \big(\sum_{e \in \mathcal{E}} \bar \lambda^e \big) n + \big( \sum_{e \in \mathcal{E}_W} \bar W^e \big) n^2</span>.</p>
<p>One of the main difficulty is that the intensity of events is not deterministic as in the case of inhomogeneous Poisson processes, but a function <span class="math inline">\Lambda_t(Z_t)</span> of the population state, bounded by a function which also depends on the population size. However, the <a href="#alg-thinning2">Algorithm 1</a> can be adapted to simulate the IBM. The construction is done by induction, by conditioning on the state of the population <span class="math inline">Z_{T_k}</span> at the <span class="math inline">k</span>th event time <span class="math inline">T_k</span> (<span class="math inline">T_0 = 0</span>).</p>
<p>We first present the construction of the first event at time <span class="math inline">T_1</span>.</p>
<section id="first-event-simulation" class="level3" data-number="3.2.1">
<h3 data-number="3.2.1" class="anchored" data-anchor-id="first-event-simulation"><span class="header-section-number">3.2.1</span> First event simulation</h3>
<p>Before the first event time, on <span class="math inline">\{ t &lt; T_1 \}</span>, the population composition is constant : <span class="math inline">Z_t = Z_0 = \{ I_1, \dots, I_{N_0}\}</span>. For each type of event <span class="math inline">e</span> and individual <span class="math inline">I_k</span>, <span class="math inline">k \in \{1,\dots N_0\}</span>, we denote by <span class="math inline">N^{k,e}</span> the counting process of intensity <span class="math inline">\lambda_t^e (I_k,Z_t)</span>, counting the occurrences of the events of type <span class="math inline">e</span> happening to the individual <span class="math inline">I_k</span>. Then, the first event <span class="math inline">T_1</span> is the first jump time of the multivariate counting vector <span class="math inline">(N^{(k,e)})_{ (k,e) \in \mathcal{J}_0}</span>, with <span class="math inline">\mathcal{J}_0 = \{1,\dots , N_0\}\times \big(\mathcal{E} \cup \mathcal{E}_W \big)</span>.</p>
<p>Since the population composition is constant before the first event time, each counting process <span class="math inline">N^{j}</span> coincides on <span class="math inline">[0,T_1[</span> with an inhomogeneous Poisson process, of intensity <span class="math inline">\lambda_t^e (I_k,Z_0)</span>. Thus (conditionally to <span class="math inline">Z_0</span>), <span class="math inline">T_1</span> is also the first jump time of an inhomogeneous multivariate Poisson process <span class="math inline">N^0 = (N^{0,j})_{j \in \mathcal{J}_0}</span> of intensity function <span class="math inline">(\lambda_j)_{j\in \mathcal J_0}</span>, defined for all <span class="math inline">j = (k,e) \in \mathcal{J}_0</span> by: <span class="math display">
    \lambda_j(t) = \lambda^e_t(I_k,Z_0) \le \bar \lambda^e_0 \quad \text{with} \quad \bar \lambda^e_0 = \bar \lambda^e \mathbf{1}_{e \in \mathcal{E}} + \bar W^e N_0 \mathbf{1}_{e \in \mathcal{E}_W},
</span> by <a href="#cnj-intensity1" class="quarto-xref">Assumption&nbsp;2</a> and <a href="#cnj-intensity2" class="quarto-xref">Assumption&nbsp;3</a>. In particular, the jump times of <span class="math inline">N^0</span> occur at the intensity <span class="math display">
    \Lambda(t) =\sum_{j \in \mathcal{J}_0} \lambda_j(t)  =\sum_{e \in \mathcal{E} \cup \mathcal{E}_W} \sum_{k=1}^{N_0}  \lambda^e_t(I_k,Z_0) \leq \bar \Lambda(N_0)=N_0 \sum_{e \in \mathcal{E} \cup \mathcal{E}_W} \bar \lambda^e_0.
</span> By <a href="#prp-thinning-vector" class="quarto-xref">Proposition&nbsp;2</a>, <span class="math inline">N^0</span> can be obtained by thinning of the marked Poisson measure <span class="math inline">\bar Q^0 = \sum_{\ell \geq 1} \delta_{(\bar T_\ell , (\bar{K}_\ell, \bar E_\ell), \bar \Theta_\ell)}</span> on <span class="math inline">{\mathbb{R}}^+\times\mathcal{J}_0 \times {\mathbb{R}}^+</span>, with:</p>
<ul>
<li><span class="math inline">(\bar T_\ell)_{\ell \in {\mathbb{N}}^*}</span> the jump times of a Poisson process of rate <span class="math inline">\bar \Lambda(N_0)</span>.</li>
<li><span class="math inline">(\bar{K}_\ell, \bar E_\ell)_{\ell \in {\mathbb{N}}^*}</span> discrete <em>i.i.d.</em> random variables on <span class="math inline">\mathcal{J}_0 = \{1,\dots , N_0\}\times \big(\mathcal{E} \cup \mathcal{E}_W \big)</span>, with <span class="math inline">K_\ell</span> representing the index of the chosen individual and <span class="math inline">E_\ell</span> the event type for the proposed event, such that: <span class="math display">
  \mathbb{P}( \bar  K_1 = k, \bar E_1 = e)
  = \frac{\bar \lambda^e_0 }{\bar \Lambda(N_0)}
  = \frac{1}{N_0} \frac{\bar \lambda^e_0 N_0}{\bar \Lambda(N_0)},
</span> i.e.&nbsp;<span class="math inline">(\bar K_1, \bar E_1)</span> are distributed as independent random variables where <span class="math inline">\bar K_1 \sim \mathcal U(\{1,\dots, N_0\})</span> and <span class="math inline">\bar E_1</span> such that <span class="math display">
  p_e := \mathbb{P}( \bar E_1 = e)
      = \frac{\bar \lambda^e_0 N_0}{\bar \Lambda(N_0)}.
</span></li>
<li><span class="math inline">(\bar \Theta_\ell)_{\ell \in {\mathbb{N}}^*}</span> are independent uniform random variables, with <span class="math inline">\bar \Theta_\ell \sim \mathcal{U}([0,\bar \lambda^{\bar E_\ell}]).</span></li>
</ul>
<p>Since the first event is the first jump of <span class="math inline">N^0</span>, by <a href="#prp-thinning-vector" class="quarto-xref">Proposition&nbsp;2</a> and <a href="#alg-thinning2">Algorithm 1</a>, the first event time <span class="math inline">T_1</span> is the first jump time <span class="math inline">\bar T_\ell</span> of <span class="math inline">\bar Q^0</span> such that <span class="math inline">\bar \Theta_\ell \leq \lambda^{\bar E_\ell}_{\bar T_\ell}(I_{\bar K_\ell}, Z_0)</span>.</p>
<p>At <span class="math inline">T_1 =\bar T_{\ell}</span>, the event <span class="math inline">\bar E_\ell</span> occurs to the individual <span class="math inline">I_{\bar K_\ell} = (\tau^b, \infty, x)</span>. For instance, if <span class="math inline">\bar E_\ell =d</span>, a death/exit event occurs, so that <span class="math inline">Z_{T_1} = Z_{0} + \delta_{(\tau^b, T_1, x)} - \delta_{I_{\bar K_\ell}}</span> and <span class="math inline">N_{T_1} = N_{0}</span>. If <span class="math inline">\bar E_\ell =b</span> or <span class="math inline">en</span>, a birth or entry event occurs, so that <span class="math inline">N_{T_1} = N_{0} + 1</span>, and a new individual <span class="math inline">I_{N_0+1}</span> is added to the population, chosen as described in <a href="#tbl-event-action" class="quarto-xref">Table&nbsp;1</a>. Finally, if <span class="math inline">\bar E_\ell=s</span>, a swap event occurs, the population size stays constant and <span class="math inline">I_{\bar K_\ell}</span> is replaced by an individual <span class="math inline">I_{\bar K_\ell}'</span>, chosen as described in <a href="#tbl-event-action" class="quarto-xref">Table&nbsp;1</a>.</p>
<p>The steps for simulating the first event in the population can be iterated in order to simulate the population. At the <span class="math inline">k</span>th step, the same procedure is repeated to simulate the <span class="math inline">k</span>th event, starting from a population <span class="math inline">Z_{T_{k-1}}</span> of size <span class="math inline">N_{T_{k-1}}</span>.</p>
<div id="alg-interaction" class="pseudocode-container" data-line-number-punc=":" data-no-end="false" data-indent-size="1.2em" data-pseudocode-index="2" data-alg-title="Algorithm" data-line-number="true" data-comment-delimiter="//">
<div class="pseudocode">
\begin{algorithm} \caption{IBM simulation algorithm (without events of Poissonian intensity)} \begin{algorithmic} \State \textbf{Input:} Initial population $Z_0$, horizon $T &gt; 0$, and events described by: \State - Intensity functions and bounds $(\lambda^e, \bar \lambda^e)$ for $e \in \mathcal{E}$ and $(W^e, \bar W^e)$ for $e \in \mathcal{E}_W$ \State - Event action functions $\phi^e(t, I)$ for $e \in \mathcal{E} \cup \mathcal{E}_W$ (see @tbl-event-action) \State \textbf{Output:} Population $Z_T$ \State Initialization $T_0 \longleftarrow 0$, $\bar T_0 \longleftarrow 0$ \While{$T_k &lt; T$} \Repeat \State increment iterative variable $\ell \longleftarrow \ell+1$ \State compute next proposed time $\bar T_{\ell} \longleftarrow \bar T_{\ell-1} + \mathcal{E}\big(\bar \Lambda(N_{T_k}) \big)$ \State draw a proposed event $\bar E_\ell \sim \mathcal{U}\{p_e\}$ with $p_e = \frac{\bar \lambda^e \mathbf{1}_{e \in \mathcal{E}} + \bar W^e N_{T_k} \mathbf{1}_{e \in \mathcal{E}_W}}{\sum_{e \in \mathcal{E}} \bar \lambda^e + \sum_{e \in \mathcal{E}_W} \bar W^e N_{T_k}}$ \State draw an individual index $\bar K_\ell \sim \mathcal{U}(\{1,\dots,N_{T_k}\})$ \State draw $\bar \Theta_\ell \sim \mathcal{U}([0, \bar \lambda^{\bar E_\ell}])$ if $\bar E_\ell \in \mathcal{E}$ or $\bar \Theta_\ell \sim \mathcal{U}([0, \bar W^{\bar E_\ell} N_{T_k}])$ if $\bar E_\ell \in \mathcal{E}_W$ \Until{accepted event $\bar \Theta_\ell \le \lambda^{\bar E_\ell}_{\bar T_\ell}(I_{\bar K_\ell},Z_{T_{k}})$} \State increment iterative variable $k \longleftarrow k+1$ \State record $(T_k, E_k, I_k) \longleftarrow (\bar T_{\ell}, \bar E_\ell, I_{\bar K_\ell})$ as accepted time, event and individual \State update the population $Z_{T_k} = Z_{T_{k-1}} + \phi^{E_k}(T_k, I_k)$ \EndWhile \end{algorithmic} \end{algorithm}
</div>
</div>
<div id="thm-interaction" class="theorem">
<p><span class="theorem-title"><strong>Theorem 2</strong></span> A population process <span class="math inline">(Z_t)_{t \in [0,T]}</span> simulated by the <a href="#alg-interaction">Algorithm 2</a> is an exact solution of the SDE <a href="#eq-sde-eq-Z" class="quarto-xref">Equation&nbsp;12</a>.</p>
</div>
<p>The proof of <a href="#thm-interaction" class="quarto-xref">Theorem&nbsp;2</a> is detailed in the Appendix <a href="#sec-prf-thm-interaction" class="quarto-xref">Section&nbsp;7.3</a>.</p>
<div id="rem-remvoval-dead" class="proof remark">
<p><span class="proof-title"><em>Remark 3</em>. </span>The population <span class="math inline">Z_{T_k}</span> includes dead/exited individuals before the event time <span class="math inline">T_k</span>. Thus, <span class="math inline">N_{T_k} &gt; N_{T_k}^a</span> is greater than the number of alive individuals at time <span class="math inline">T_k</span>. When a dead individual <span class="math inline">I_{\bar K_l}</span> is drawn from the population during the rejection/acceptance phase of the algorithm, the proposed event <span class="math inline">(\bar T_{\ell}, \bar E_\ell,  I_{\bar K_\ell})</span> is automatically rejected since the event intensity is <span class="math inline">\lambda^{\bar E_\ell}_{T_\ell}(I_{\bar K_\ell}, Z_{T_k}) = 0</span> (nothing can happen to a dead individual). This can slow down the algorithm, especially when the proportion of dead/exited individuals in the population increases. However, the computational cost of keeping dead/exited individuals in the population is much lower than the cost of removing an individual from the population at each death/exit event, which is linear in the population size.</p>
<p>Actually, dead/exited individuals are regularly removed from the population in the <code>IBMPopSim</code> algorithm, in order to optimize the trade-off between having to many dead individuals and removing dead individuals from the population too often. The frequency at which dead individuals are “removed from the population” can be chosen by the user, as an optional argument of the main function <code>popsim</code> (see details in <a href="#sec-simulation" class="quarto-xref">Section&nbsp;3</a>).</p>
</div>
<div id="rem-sharp-bounds" class="proof remark">
<p><span class="proof-title"><em>Remark 4</em>. </span>In practice, the bounds <span class="math inline">\bar \lambda^e</span> and <span class="math inline">\bar W^e</span> should be chosen as sharp as possible. It is easy to see that conditionally to <span class="math inline">\{\bar E_\ell = e, \bar T_\ell = t, \bar K_\ell = l \}</span> the probability of accepting the event is, depending if there are interactions, <span class="math display">
    \mathbb{P}\big(\bar \Theta_\ell \le \lambda^e_t(I_l,Z_{T_k})| \mathcal{F}_{T_k}\big)
    = \frac{\lambda^e(t, I_l)}{\bar \lambda^e} \mathbf{1}_{e \in \mathcal{E}} +  \frac{\sum_{j=1}^{N_{T_k}} W^e(t, I_l, I_j)}{\bar W^e N_{T_k}} \mathbf{1}_{e \in \mathcal{E}_W}.
</span> The sharper the bounds <span class="math inline">\bar \lambda^e</span> and <span class="math inline">\bar W^e</span> are, the higher is the acceptance rate. For even sharper bounds, an alternative is to define bounds <span class="math inline">\bar \lambda^e(I_l)</span> and <span class="math inline">\bar W^e(I_l)</span> depending on the individuals’ characteristics. However, the algorithm is modified and the individual <span class="math inline">I_l</span> is not chosen uniformly in the population anymore. Due to the population size, this is way more costly than choosing uniform bounds, as explained in <a href="#rem-alternate-thinning" class="quarto-xref">Remark&nbsp;2</a>.</p>
</div>
</section>
</section>
<section id="sec-simulation-randomized" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="sec-simulation-randomized"><span class="header-section-number">3.3</span> Simulation algorithm with randomization</h2>
<p>Let <span class="math inline">e \in \cal E_W</span> be an event with interactions. In order to evaluate the individual intensity <span class="math inline">\lambda^e_t (I,Z_t) = \sum_{j=1}^{N_t} W^e(t, I,I_j)</span> one must compute <span class="math inline">W^e(t, I_l, I_j)</span> for all individuals in the population. This step can be computationally costly, especially for large populations. One way to avoid this summation is to use randomization (see also&nbsp;<span class="citation" data-cites="FouMel04">Fournier and Méléard (<a href="#ref-FouMel04" role="doc-biblioref">2004</a>)</span> in a model without age). The randomization consists in replacing the summation by an evaluation of the interaction function <span class="math inline">W^e</span> using an individual <span class="math inline">J</span> drawn uniformly from the population.</p>
<p>More precisely, if <span class="math inline">J \sim \mathcal{U}(\{1, \dots, N_{T_k}\})</span> is independent of <span class="math inline">\bar \Theta_\ell</span>, we have <span id="eq-randomized-event"><span class="math display">
    \mathbb{P}\Big(\bar \Theta_\ell \le
    \sum_{j=1}^{N_{T_k}} W^e(t, I_l, I_j) | \mathcal{F}_{T_k} \Big)
    = \mathbb{P}\big(\bar \Theta_\ell
    \le N_{T_k} W^e(t, I_l, I_J) | \mathcal{F}_{T_k}\big).
\tag{15}</span></span> Equivalently, we can write this probability as <span class="math inline">\mathbb{P}\big(\tilde \Theta_\ell \le W^e(t, I_l, I_J) \big)</span> where <span class="math inline">\tilde \Theta_\ell  = \frac{\bar \Theta_\ell}{N_{T_k}}\sim \mathcal{U}([0, \bar W^e])</span> is independent of <span class="math inline">J \sim \mathcal{U}(\{1, \dots, N_{T_k}\})</span>.</p>
<div id="rem">
<p>The efficiency of the randomization procedure increases with the population homogeneity. If the function <span class="math inline">W^e</span> varies little according to the individuals in the population, the randomization approach is very efficient in practice, especially when the population is large.</p>
</div>
<p>We now present the main algorithm implemented in the <code>popsim</code> function of the <code>IBMPopSim</code> package in the case where events arrive with individual intensities, but also with interactions (using randomization) and Poisson intensities. In this general case, <span class="math inline">\bar \Lambda(n)</span> is defined by <a href="#eq-def-bar-Lambda" class="quarto-xref">Equation&nbsp;11</a>.</p>
<div id="alg-randomized" class="pseudocode-container" data-line-number-punc=":" data-no-end="false" data-indent-size="1.2em" data-pseudocode-index="3" data-alg-title="Algorithm" data-line-number="true" data-comment-delimiter="//">
<div class="pseudocode">
\begin{algorithm} \caption{Randomized IBM simulation algorithm.} \begin{algorithmic} \State \textbf{Input:} Initial population $Z_0$, horizon $T &gt; 0$, and events described by \State Intensity functions and bounds $(\lambda^e, \bar \lambda^e)$ for $e \in \mathcal{E}$, $(W^e, \bar W^e)$ for $e \in \mathcal{E}_W$ and $(\mu^e, \bar \mu^e)$ for $e \in \mathcal{P}$ \State Event action functions $\phi^e(t, I)$ for $e \in \mathcal{E} \cup \mathcal{E}_W \cup \mathcal{P}$ \State \textbf{Output:} Population $Z_T$ \State Initialization $T_0 \longleftarrow 0$, $\bar T_0 \longleftarrow 0$ \While{$T_k &lt; T$} \Repeat \State increment iterative variable $\ell \longleftarrow \ell+1$ \State compute next proposed time $\bar T_{\ell} \longleftarrow \bar T_{\ell-1} + \mathcal{E}\big(\bar \Lambda(N_{T_k}) \big)$ \State draw an individual index $\bar K_\ell \sim \mathcal{U}(\{1,\dots,N_{T_k}\})$ \State draw a proposed event $\bar E_\ell \sim \mathcal{U}\{p_e\}$ with $p_e = \frac{\bar \mu^e \mathbf{1}_{e \in \mathcal{P}} + \bar \lambda^e N_{T_k}\mathbf{1}_{e \in \mathcal{E}} + \bar W^e (N_{T_k})^2 \mathbf{1}_{e \in \mathcal{E}_W}}{\bar \Lambda(N_{T_k})}$ \If{$\bar E_\ell \in \mathcal{E}$ (without interaction)} \State draw $\bar \Theta_\ell \sim \mathcal{U}\big([0, \bar \lambda^{\bar E_\ell}] \big)$ \State \emph{accepted} $\longleftarrow \bar \Theta_\ell \le \lambda^{\bar E_\ell}(\bar T_\ell, I_{\bar K_\ell})$ \EndIf \If{$\bar E_\ell \in \mathcal{E}_W$ (with interaction)} \State draw $(\bar \Theta_\ell, J_\ell) \sim \mathcal{U}\big([0, \bar W^{\bar E_\ell}] \times \{1, \dots, N_{T_k}\} \big)$ \State \emph{accepted} $\longleftarrow \bar \Theta_\ell \le W^{\bar E_\ell}(\bar T_\ell, I_{\bar K_\ell}, I_{J_\ell})$ \EndIf \If{$\bar E_\ell \in \mathcal{P}$ (Poissonian intensity)} \State draw $\bar \Theta_\ell \sim \mathcal{U}\big([0, \bar \mu^{\bar E_\ell}] \big)$ \State \emph{accepted} $\longleftarrow \bar \Theta_\ell \le \mu^{\bar E_\ell}(\bar T_\ell)$ \EndIf \Until{accepted} \State increment iterative variable $k \longleftarrow k+1$ \State record $(T_k, E_k, I_k) \longleftarrow (\bar T_{\ell}, \bar E_\ell, \bar I_{\bar K_\ell})$ as accepted time, event and individual \State update the population $Z_{T_k} = Z_{T_{k-1}} + \phi^{E_k}(T_k, I_k)$ \EndWhile \end{algorithmic} \end{algorithm}
</div>
</div>
<div id="prp-randomized" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 3</strong></span> The population processes <span class="math inline">(Z_t)_{t\in [0,T]}</span> simulated by the <a href="#alg-interaction">Algorithm 2</a> and <a href="#alg-randomized">Algorithm 3</a> have the same law.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>The only difference between <a href="#alg-interaction">Algorithm 2</a> and <a href="#alg-randomized">Algorithm 3</a> is in the acceptance/rejection step of proposed events, in the presence of interactions. In <a href="#alg-randomized">Algorithm 3</a> , a proposed event <span class="math inline">(\bar T_\ell, \bar E_\ell, \bar K_\ell)</span>, with <span class="math inline">\bar E_l \in \mathcal{E}_W</span> an event with interaction, is accepted as a true event in the population if <span class="math display">
    \bar \Theta_\ell \le W^{\bar E_\ell}(\bar T_\ell, I_{\bar K_\ell}, I_{\bar J_\ell}), \text{ with } (\bar \Theta_\ell, \bar J_\ell) \sim  \mathcal{U}\big([0, \bar W^{\bar E_\ell}] \times \{1, \dots, N_{T_k}\} \big).
</span> By <a href="#eq-randomized-event" class="quarto-xref">Equation&nbsp;15</a>, the probability of accepting this event is the same than in <a href="#alg-interaction">Algorithm 2</a>, which achieves the proof.</p>
</div>
</section>
</section>
<section id="sec-package" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Model creation and simulation with IBMPopSim</h1>
<p>The use of the <code>IBMPopSim</code> package is mainly done in two steps: a first model creation followed by the simulation of the population evolution. The creation of a model is itself based on two steps: the description of the population <span class="math inline">Z_t</span>, as introduced in <a href="#sec-population" class="quarto-xref">Section&nbsp;2.2</a>, and the description of the events types, along with their associated intensities, as detailed in <a href="#sec-events" class="quarto-xref">Section&nbsp;2.3</a> and <a href="#sec-event-intensity" class="quarto-xref">Section&nbsp;2.4</a>. A model is compiled by calling the <code>mk_model</code> function, which internally uses a template mechanism to generate automatically the source code describing the model, which is subsequently compiled using the <code>Rcpp</code> package to produce the object code.</p>
<p>After the compilation of the model, the simulations are launched by calling the <code>popsim</code> function. This function depends on the previously compiled model and simulates a random trajectory of the population evolution based on an initial population and on parameter values, which can change from a call to another.</p>
<p>In this section, we take a closer look at each component of a model in <code>IBMPopSim</code>. We also refer to the <a href="https://daphnegiorgi.github.io/IBMPopSim/">IBMPopSim website</a> and to the <code>vignettes</code> of the package for more details on the package and various examples of model creation.</p>
<section id="sec-package-population" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="sec-package-population"><span class="header-section-number">4.1</span> Population</h2>
<p>A population <span class="math inline">Z</span> is represented by an object of class <code>population</code> containing a data frame where each row corresponds to an individual <span class="math inline">I=(\tau^b, \tau^d, x)</span>, and which has at least two columns, <code>birth</code> and <code>death</code>, corresponding to the birth date <span class="math inline">\tau^b</span> and death/exit date <span class="math inline">\tau^d</span> (<span class="math inline">\tau^d</span> is set to <code>NA</code> for alive individuals). The data frame can contain more than two columns if individuals are described by additional characteristics <span class="math inline">x= (x_1,\dots x_n)</span>.</p>
<p>If entry events can occur in the population, the population shall contain a characteristic named <code>entry</code>. This can be done by setting the flag <code>entry=TRUE</code> in the <code>population</code> function, or by calling the <code>add_characteristic</code> function on an existing population. During the simulation, the date at which an individual enters the population is automatically recorded in the variable <code>I.entry</code>. If exit events can occur, the population shall contain a characteristic named <code>out</code>. This can be done by setting the flag <code>out=TRUE</code> in the <code>population</code> function, or by calling the <code>add_characteristic</code> function. When an individual <code>I</code> exits the population during the simulation, <code>I.out</code> is set to <code>TRUE</code> and its exit time is recorded as a “death” date.</p>
<p>In the example below, individuals are described by their birth and death dates, as well a Boolean characteristics called male, and the <code>entry</code> characteristic. For instance, the first individual is a female whose age at <span class="math inline">t_0=0</span> is <span class="math inline">107</span> and who was originally in the population.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>pop_init <span class="ot">&lt;-</span> <span class="fu">population</span>(EW_pop_14<span class="sc">$</span>sample, <span class="at">entry=</span><span class="cn">TRUE</span>)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(pop_init)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Classes 'population' and 'data.frame':  100000 obs. of  4 variables:
 $ birth: num  -107 -107 -105 -104 -104 ...
 $ death: num  NA NA NA NA NA NA NA NA NA NA ...
 $ male : logi  FALSE FALSE TRUE FALSE FALSE FALSE ...
 $ entry: logi  NA NA NA NA NA NA ...</code></pre>
</div>
</div>
<section id="individual" class="level3" data-number="4.1.1">
<h3 data-number="4.1.1" class="anchored" data-anchor-id="individual"><span class="header-section-number">4.1.1</span> Individual</h3>
<p>In the <code>C++</code> model which is automatically generated and compiled, an individual <code>I</code> is an object of an internal class containing some attributes (<code>birth_date</code>, <code>death_date</code> and the characteristics), and some methods including:</p>
<ul>
<li><code>I.age(t)</code>: a <code>const</code> method returning the age of an individual <code>I</code> at time <code>t</code>,</li>
<li><code>I.set_age(a, t)</code>: a method to set the age <code>a</code> at time <code>t</code> of an individual <code>I</code> (set <code>birth_date</code> at <code>t-a</code>),</li>
<li><code>I.is_dead(t)</code>: a <code>const</code> method returning <code>true</code> if the individual <code>I</code> is dead at time <code>t</code>.</li>
</ul>
<div id="rem-characteristics" class="proof remark">
<p><span class="proof-title"><em>Remark 5</em>. </span>A characteristic <span class="math inline">x_i</span> must be of atomic type: <code>logical</code>, <code>integer</code>, <code>double</code> or <code>character</code>. The function <code>get_characteristic</code> allows to easily get characteristics names and their types from a population data frame. We draw the attention to the fact that some names for characteristics are forbidden, or reserved to specific cases : this is the case for <code>birth</code>, <code>death</code>, <code>entry</code>, <code>out</code>, <code>id</code>.</p>
</div>
</section>
</section>
<section id="sec-package-events" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="sec-package-events"><span class="header-section-number">4.2</span> Events</h2>
<p>The most important step of the model creation is the events creation. The call to the function creating an event is of form</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mk_event_CLASS</span>(<span class="at">type=</span><span class="st">"TYPE"</span>, <span class="at">name=</span><span class="st">"NAME"</span>, ...)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>where <code>CLASS</code> is replaced by the class of the event intensity, described in <a href="#sec-event-intensity" class="quarto-xref">Section&nbsp;2.4</a> , and <code>type</code> corresponds to the event type, described in Section&nbsp;<a href="#sec-events" class="quarto-xref">Section&nbsp;2.3</a>. <a href="#tbl-intensity-classes" class="quarto-xref">Table&nbsp;2 (a)</a> and <a href="#tbl-event-types" class="quarto-xref">Table&nbsp;2 (b)</a> summarize the different possible choices for intensity classes and types of event. The optional argument <code>name</code> gives a name to the event. If not specified, the name of the event is its type, for instance <code>death</code>. However, a name must be specified if the model is composed of several events with the same type (for instance when there are multiple death events corresponding to different causes of death). The other arguments depend on the intensity class and on the event type.</p>
<div id="tbl-panel" class="quarto-layout-panel anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-panel-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;2: Choices of <code>CLASS</code> and <code>TYPE</code> arguments for an event creation.
</figcaption>
<div aria-describedby="tbl-panel-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-layout-row">
<div class="quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="tbl-panel" style="flex-basis: 50.0%;justify-content: center;">
<div id="tbl-intensity-classes" class="quarto-float anchored">
<figure class="quarto-float quarto-subfloat-tbl figure">
<figcaption class="quarto-float-caption-top quarto-subfloat-caption quarto-subfloat-tbl" id="tbl-intensity-classes-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(a) Intensity Classes
</figcaption>
<div aria-describedby="tbl-intensity-classes-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table">
<thead>
<tr class="header">
<th style="text-align: left;">Intensity class</th>
<th style="text-align: left;">Set</th>
<th style="text-align: left;"><code>CLASS</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Individual</td>
<td style="text-align: left;"><span class="math inline">\mathcal{E}</span></td>
<td style="text-align: left;"><code>individual</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">Interaction</td>
<td style="text-align: left;"><span class="math inline">\mathcal{E}_W</span></td>
<td style="text-align: left;"><code>interaction</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Poisson</td>
<td style="text-align: left;"><span class="math inline">\mathcal{P}</span></td>
<td style="text-align: left;"><code>poisson</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">Inhomogeneous Poisson</td>
<td style="text-align: left;"><span class="math inline">\mathcal{P}</span></td>
<td style="text-align: left;"><code>inhomogeneous_poisson</code></td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
</div>
<div class="quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="tbl-panel" style="flex-basis: 50.0%;justify-content: center;">
<div id="tbl-event-types" class="quarto-float anchored">
<figure class="quarto-float quarto-subfloat-tbl figure">
<figcaption class="quarto-float-caption-top quarto-subfloat-caption quarto-subfloat-tbl" id="tbl-event-types-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(b) Event Types
</figcaption>
<div aria-describedby="tbl-event-types-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table">
<thead>
<tr class="header">
<th style="text-align: left;">Event type</th>
<th style="text-align: left;"><code>TYPE</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Birth</td>
<td style="text-align: left;"><code>birth</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">Death</td>
<td style="text-align: left;"><code>death</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Entry</td>
<td style="text-align: left;"><code>entry</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">Exit</td>
<td style="text-align: left;"><code>exit</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Swap</td>
<td style="text-align: left;"><code>swap</code></td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
</div>
</div>
</div>
</figure>
</div>
<p>The intensity function and the kernel of an event are defined through arguments of the function <code>mk_event_CLASS</code>. These arguments are strings composed of few lines of code. Since the model is compiled using <code>Rcpp</code>, the code should be written in <code>C++</code>. However, thanks to the functions/variables of the package, even the non-experienced <code>C++</code> user can define a model quite easily. To facilitate the implementation, the user can also define a list of <strong>model parameters</strong>, which can be used in the event and intensity definitions. These parameters are stored in a named list and can be of various types: atomic type, numeric vector or matrix, predefined function of one variable (<code>stepfun</code>, <code>linfun</code>, <code>gompertz</code>, <code>weibull</code>, <code>piecewise_x</code>), piecewise functions of two variables (<code>piecewise_xy</code>). We refer to the <code>vignette(IBMPopSim_cpp)</code> for more details on parameters types and basic <code>C++</code> tools. Another advantage of the model parameters is that their value can be modified from a simulation to another without changing the model.</p>
<section id="intensities" class="level3" data-number="4.2.1">
<h3 data-number="4.2.1" class="anchored" data-anchor-id="intensities"><span class="header-section-number">4.2.1</span> Intensities</h3>
<p>In <code>IBMPopSim</code>, the intensity of an event can belong to three classes <a href="#sec-event-intensity" class="quarto-xref">Section&nbsp;2.4</a>: individual intensities without interaction between individuals, corresponding to events <span class="math inline">e\in\mathcal{E}</span>, individual intensities with interaction, corresponding to events <span class="math inline">e\in\mathcal{E}_W</span>, and Poisson intensities (homogeneous and inhomogeneous), corresponding to events <span class="math inline">e\in\mathcal{P}</span>.</p>
<section id="event-creation-with-individual-intensity" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="event-creation-with-individual-intensity">Event creation with individual intensity</h4>
<p>An event <span class="math inline">e\in \mathcal{E}</span> (see <a href="#eq-intensity-no-interaction" class="quarto-xref">Equation&nbsp;5</a>) has an intensity of the form <span class="math inline">\lambda^e(t, I)</span> which depends only on the individual <code>I</code> and time. Events with such intensity are created using the function</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mk_event_individual</span>(<span class="at">type =</span> <span class="st">"TYPE"</span>, </span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>                    <span class="at">name =</span> <span class="st">"NAME"</span>,</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>                    <span class="at">intensity_code =</span> <span class="st">"INTENSITY"</span>, ...)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The <code>intensity_code</code> argument is a character string containing few lines of <code>C++</code> code describing the intensity function <span class="math inline">\lambda^e(t, I)</span>. The intensity value has to be stored in a variable called <code>result</code> and the available variables for the intensity code are given in <a href="#tbl-intensity-variables" class="quarto-xref">Table&nbsp;3</a>.</p>
<div id="tbl-intensity-variables" class="quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-intensity-variables-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;3: <code>C++</code> variables available for intensity code
</figcaption>
<div aria-describedby="tbl-intensity-variables-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table">
<thead>
<tr class="header">
<th style="text-align: left;">Variable</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Variable</td>
<td style="text-align: left;">Description</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>I</code></td>
<td style="text-align: left;">Current individual</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>J</code></td>
<td style="text-align: left;">Another individual in the population (only for interaction)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>t</code></td>
<td style="text-align: left;">Current time</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Model parameters</td>
<td style="text-align: left;">Depends on the model</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>For instance, the intensity code below corresponds to an individual death intensity <span class="math inline">\lambda^d(t,I)</span> equal to <span class="math inline">d_1(a(I,t)) = \alpha_1 \exp(\beta_1 a(I,t))</span> for males and <span class="math inline">d_2(a(I,t)) = \alpha_2 \exp(\beta_2 a(I,t))</span> for females, where <span class="math inline">a(I,t)=t-\tau^b</span> is the age of the individual <span class="math inline">I=(\tau^b, \tau^d,x)</span> at time <span class="math inline">t</span>. In this case, the intensity function depends on the individuals’ age, gender, and on the model parameters <span class="math inline">\alpha = (\alpha_1, \alpha_2)</span> and <span class="math inline">\beta = (\beta_1, \beta_2)</span>.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>death_intensity <span class="ot">&lt;-</span> <span class="st">"</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="st">    if (I.male) result = alpha_1 * exp(beta_1 * I.age(t));</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="st">    else result = alpha_2 * exp(beta_2 * I.age(t));</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="st">"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="event-creation-with-interaction-intensity" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="event-creation-with-interaction-intensity">Event creation with interaction intensity</h4>
<p>An event <span class="math inline">e\in \mathcal{E}_W</span> is an event which occurs to an individual at a frequency which is the result of interactions with other members of the population (see <a href="#eq-intensity-interaction" class="quarto-xref">Equation&nbsp;6</a>), and which can be written as <span class="math inline">\lambda^e_t(I, Z_t)=\sum_{J\in Z_t} W^e(t, I, J)</span> where <span class="math inline">W^e(t, I, J)</span> is the intensity of the interaction between individual <span class="math inline">I</span> and individual <span class="math inline">J</span>.</p>
<p>An event <span class="math inline">e\in \mathcal{E}_W</span> with such intensity is created by calling the function</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mk_event_interaction</span>(<span class="at">type =</span> <span class="st">"TYPE"</span>,</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>                     <span class="at">name =</span> <span class="st">"NAME"</span>,</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>                     <span class="at">interaction_code =</span> <span class="st">"INTERACTION_CODE"</span>,</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>                     <span class="at">interaction_type =</span> <span class="st">"random"</span>, ...)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The <code>interaction_code</code> argument contains few lines of <code>C++</code> code describing the interaction function <span class="math inline">W^e(t, I, J)</span>. The interaction function value has to be stored in a variable called <code>result</code> and the available variables for the intensity code are given in <a href="#tbl-intensity-variables" class="quarto-xref">Table&nbsp;3</a>. For example, if we set</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>death_interaction_code <span class="ot">&lt;-</span> <span class="st">"result = max(J.size - I.size, 0.);"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>the death intensity of an individual <code>I</code> is the result of the competition between individuals, depending on a characteristic named <code>size</code>, as defined in <a href="#eq-ex-interaction" class="quarto-xref">Equation&nbsp;8</a>.</p>
<p>The argument <code>interaction_type</code>, set by default at <code>random</code>, is the algorithm choice for simulating the model. When <code>interaction_type=full</code>, the simulation follows <a href="#alg-interaction">Algorithm 2</a>, <code>interaction_type=random</code> it follows <a href="#alg-randomized">Algorithm 3</a>. In most cases, the <code>random</code> algorithm is much faster than the <code>full</code> algorithm, as we illustrate for instance in <a href="#sec-example-interaction" class="quarto-xref">Section&nbsp;6</a> , where we observe the gain of a factor of 40 between the two algorithms, on a set of standard parameters. This allows in particular to explore parameter sets that give larger population sizes, without reaching computation times that explode.</p>
</section>
<section id="events-creation-with-poisson-and-inhomogeneous-poisson-intensity" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="events-creation-with-poisson-and-inhomogeneous-poisson-intensity">Events creation with Poisson and Inhomogeneous Poisson intensity</h4>
<p>For events <span class="math inline">e\in\mathcal{P}</span> with an intensity <span class="math inline">\mu^e(t)</span> which does not depend on the population, the event intensity is of class <code>inhomogeneous_poisson</code> or <code>poisson</code> depending on whether or not the intensity depends on time (in the second case the intensity is constant).</p>
<p>For Poisson (constant) intensities the events are created with the function</p>
<p>The following example creates a death event, where individuals die at a constant intensity <code>lambda</code> (which has to be in the list of model parameters):</p>
<p>TODO</p>
</section>
</section>
</section>
</section>
<section id="sec-insurance-portfolio" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Insurance portfolio</h1>
<p>This section provides an example of how to use the <code>IBMPopSim</code> package to simulate a heterogeneous life insurance portfolio (see also&nbsp;<code>vignette(IBMPopSim_insurance_portfolio)</code>).</p>
<p>We consider an insurance portfolio consisting of male policyholders, of age greater than 65. These policyholders are characterized by their age, assumed to be less than <span class="math inline">a_{max} = 110</span>, and risk class <span class="math inline">x\in \mathcal X =\{1,2\}</span>.</p>
<p><strong>Entries in the portfolio</strong> New policyholders enter the population at a constant Poisson rate <span class="math inline">\mu^{en}=\lambda</span>, which means that on average, <span class="math inline">\lambda</span> individuals enter the portfolio each year. A new individual enters the population at an age a that is uniformly distributed between 65 and 70, and is in risk class 1 with probability <span class="math inline">p</span>.</p>
<p><strong>Death events</strong> A baseline age and time specific death rate is first calibrated on “England and Wales (EW)” males mortality historic data[^1], and projected for 30 years using the Lee-Carter model with the package <code>StMoMo</code> (see&nbsp;<span class="citation" data-cites="stmomo">(<a href="#ref-stmomo" role="doc-biblioref">A. M. Villegas, Kaishev, and Millossovich 2018</a>)</span>). The forecasted baseline death intensity is denoted by <span class="math inline">d(t,a)</span>, defined by: <span id="eq-insurance-baseline"><span class="math display">
d(t,a) = \sum_{k=0}^{29}\mathbf{1}_{\{k\leq t &lt; k+1\}} d_k(a), \quad \forall \; t\in [0,30] \text{ and } a \in [65, a_{max}],
\tag{16}</span></span> with <span class="math inline">d_k(a)</span> the point estimate of the forecasted mortality rate for age <span class="math inline">a</span> and year <span class="math inline">k</span>.<br>
Individuals in risk class 1 are assumed to have mortality rates that are 20% higher than the baseline mortality (for instance, the risk class could refer to smokers), while individuals in risk class 2 are assumed to have mortality rates that are 20% lower than the baseline (non smokers). The death intensity of an individual <span class="math inline">I= (\tau_b, \infty, x)</span>, of age <span class="math inline">a(I,t) = t - \tau_b</span> at time <span class="math inline">t</span> and in risk class <span class="math inline">x \in \{1, 2\}</span> is thus the function <span class="math display">\label{eq-insurance-deathrates}
\lambda^d(t,I) = \alpha_x d(t,a(I,t)), \quad \alpha_1 = 1.2, \quad \alpha_2 = 0.8.</span> In particular, the death intensity verifies Assumption TODO <a href="#AssumptionIntensity1" data-reference-type="ref" data-reference="AssumptionIntensity1">2</a> since: <span id="eq-insurance-bound-deathrates"><span class="math display">
\lambda^d(t,I) \leq \bar d : = \alpha_1 \sup_{t \in [0,30]} d(t,a_{max}).
\tag{17}</span></span></p>
<p><strong>Exits from the portfolio</strong> Individuals exit the portfolio at a constant (individual) rate <span class="math inline">\lambda^{ex}(t,I) = \mu^{i}</span> only depending on their risk class <span class="math inline">i\in \{1,2\}</span>.</p>
<section id="insurance-population" class="level2" data-number="5.1">
<h2 data-number="5.1" class="anchored" data-anchor-id="insurance-population"><span class="header-section-number">5.1</span> Population</h2>
<p>We start with an initial population of <span class="math inline">30\,000</span> males of age 65, distributed uniformly in each risk class. The population data frame has thus the two (mandatory) columns <code>birth</code> (here the initial time is <span class="math inline">t_0=0</span>) and <code>death</code> (<code>NA</code> if alive), and an additional column <code>risk_cls</code> corresponding to the policyholders risk class. Since there are entry and exit events, the <code>entry</code> and <code>out</code> flags of the population constructor are set to <code>TRUE</code>.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>N <span class="ot">&lt;-</span> <span class="dv">30000</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>pop_df <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="st">"birth"</span> <span class="ot">=</span> <span class="fu">rep</span>(<span class="sc">-</span><span class="dv">65</span>,N), <span class="st">"death"</span> <span class="ot">=</span> <span class="fu">rep</span>(<span class="cn">NA</span>,N),</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>                     <span class="st">"risk_cls"</span> <span class="ot">=</span> <span class="fu">rep</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>,<span class="at">each=</span>N<span class="sc">/</span><span class="dv">2</span>))</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>pop_init <span class="ot">&lt;-</span> <span class="fu">population</span>(pop_df, <span class="at">entry=</span><span class="cn">TRUE</span>, <span class="at">out=</span><span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="insurance-events" class="level2" data-number="5.2">
<h2 data-number="5.2" class="anchored" data-anchor-id="insurance-events"><span class="header-section-number">5.2</span> Events</h2>
<section id="entry-events" class="level4" data-number="5.2.0.1">
<h4 data-number="5.2.0.1" class="anchored" data-anchor-id="entry-events"><span class="header-section-number">5.2.0.1</span> Entry events</h4>
<p>The age of the new individual is determined by the <code>kernel_code</code> argument in the <code>mk_event_poisson</code> function.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>entry_params <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="st">"lambda"</span> <span class="ot">=</span> <span class="dv">30000</span>, <span class="st">"p"</span> <span class="ot">=</span> <span class="fl">0.5</span>)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>entry_event <span class="ot">&lt;-</span> <span class="fu">mk_event_poisson</span>(</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">type =</span> <span class="st">"entry"</span>,</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">intensity =</span> <span class="st">"lambda"</span>,</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">kernel_code =</span> <span class="st">"if (CUnif() &lt; p) newI.risk_cls =1;</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="st">                   else newI.risk_cls= 2;</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="st">                   double a = CUnif(65, 70);</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="st">                   newI.set_age(a, t);"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Note that the variables <code>newI</code> and <code>t</code>, as well as the function <code>CUnif()</code>, are implicitly defined and usable in the <code>kernel_code</code>. The field <code>risk_cls</code> comes from the names of characteristics of individuals in the population. The names <code>lambda</code> and <code>p</code> are parameter names that will be specified in the <code>R</code> named list <code>params</code>.</p>
<p>Here we use a constant <span class="math inline">\lambda</span> as the event intensity, but we could also use a rate <span class="math inline">\lambda(t)</span> that depends on time, using the function <code>mk_event_poisson_inhomogeneous</code>.</p>
</section>
<section id="death-and-exit-events" class="level4" data-number="5.2.0.2">
<h4 data-number="5.2.0.2" class="anchored" data-anchor-id="death-and-exit-events"><span class="header-section-number">5.2.0.2</span> Death and exit events</h4>
<p>The baseline death intensity defined in <a href="#eq-insurance-baseline" class="quarto-xref">Equation&nbsp;16</a> and obtained with the package <code>StMoMo</code> is stored in the variable <code>death_male</code>.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co"># StMoMo death rates</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">'StMoMo'</span>)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">'reshape2'</span>)</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>EWStMoMoMale <span class="ot">&lt;-</span> <span class="fu">StMoMoData</span>(EWdata_hmd, <span class="at">series =</span> <span class="st">"male"</span>)</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>LC <span class="ot">&lt;-</span> <span class="fu">lc</span>()</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>ages.fit <span class="ot">&lt;-</span> <span class="dv">65</span><span class="sc">:</span><span class="dv">100</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>years.fit <span class="ot">&lt;-</span> <span class="dv">1950</span><span class="sc">:</span><span class="dv">2016</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>LCfitMale <span class="ot">&lt;-</span> <span class="fu">fit</span>(LC, <span class="at">data =</span> EWStMoMoMale, <span class="at">ages.fit =</span> ages.fit, <span class="at">years.fit =</span> years.fit)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>StMoMo: Start fitting with gnm
Initialising
Running start-up iterations..
Running main iterations.....
Done
StMoMo: Finish fitting with gnm</code></pre>
</div>
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>t <span class="ot">&lt;-</span> <span class="dv">30</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>LCforecastMale <span class="ot">&lt;-</span> <span class="fu">forecast</span>(LCfitMale, <span class="at">h =</span> t)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>d_k <span class="ot">&lt;-</span> <span class="fu">apply</span>(LCforecastMale<span class="sc">$</span>rates, <span class="dv">2</span>, <span class="cf">function</span>(x) <span class="fu">stepfun</span>(<span class="dv">66</span><span class="sc">:</span><span class="dv">100</span>, x))</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>breaks <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">29</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>death_male <span class="ot">&lt;-</span> <span class="fu">piecewise_xy</span>(breaks,d_k)</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>death_max <span class="ot">&lt;-</span> <span class="fu">max</span>(<span class="fu">sapply</span>(d_k, <span class="cf">function</span>(x) { <span class="fu">max</span>(x) }))</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>death_params <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="st">"death_male"</span> <span class="ot">=</span> death_male, <span class="st">"alpha"</span> <span class="ot">=</span> <span class="fu">c</span>(<span class="fl">1.2</span>, <span class="fl">0.8</span>))</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>death_event <span class="ot">&lt;-</span> <span class="fu">mk_event_individual</span>(</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>    <span class="at">type =</span> <span class="st">"death"</span>,</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>    <span class="at">intensity_code =</span> <span class="st">"result = alpha[I.risk_cls-1] * death_male(t, I.age(t));"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The death and exit intensities are of class <code>individual</code> TODO(see Table <span class="citation" data-cites="tab">(<a href="#ref-tab" role="doc-biblioref"><strong>tab?</strong></a>)</span>::intensity_classes ). Hence, the death and exit events are created with the <code>mk_event_individual</code> function.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>death_params <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="st">"death_male"</span> <span class="ot">=</span> death_male, <span class="st">"alpha"</span> <span class="ot">=</span> <span class="fu">c</span>(<span class="fl">1.2</span>, <span class="fl">0.8</span>))</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>death_event <span class="ot">&lt;-</span> <span class="fu">mk_event_individual</span>(</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">type =</span> <span class="st">"death"</span>,</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">intensity_code =</span> <span class="st">"result = alpha[I.risk_cls-1] * death_male(t, I.age(t));"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>exit_params <span class="ot">=</span> <span class="fu">list</span>(<span class="st">"mu"</span> <span class="ot">=</span> <span class="fu">c</span>(<span class="fl">0.001</span>, <span class="fl">0.06</span>))</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>exit_event <span class="ot">&lt;-</span> <span class="fu">mk_event_individual</span>(</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">type =</span> <span class="st">"exit"</span>,</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">intensity_code =</span> <span class="st">"result = mu[I.risk_cls-1]; "</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
</section>
<section id="insurance-simulation" class="level2" data-number="5.3">
<h2 data-number="5.3" class="anchored" data-anchor-id="insurance-simulation"><span class="header-section-number">5.3</span> Model creation and simulation</h2>
<p>The model is created from all the previously defined building blocks, by calling the <code>mk_model</code>.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>model <span class="ot">&lt;-</span> <span class="fu">mk_model</span>(</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">characteristics =</span> <span class="fu">get_characteristics</span>(pop_init),</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">events =</span> <span class="fu">list</span>(entry_event, death_event, exit_event),</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">parameters =</span> <span class="fu">c</span>(entry_params, death_params, exit_params))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Once the model is compiled, it can be used with different parameters and run simulations for various scenarios. Similarly, the initial population (here <code>pop_df</code>) can be modified without rerunning the <code>mk_model</code> function. The bounds for entry events is simply the intensity <span class="math inline">\lambda</span>. For death events, the bound is given by <span class="math inline">\bar{d}</span> defined in <a href="#eq-insurance-bound-deathrates" class="quarto-xref">Equation&nbsp;17</a>, which is stored in the <code>death_max</code> variable.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>bounds <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"entry"</span> <span class="ot">=</span> entry_params<span class="sc">$</span>lambda,</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>            <span class="st">"death"</span> <span class="ot">=</span> death_max,</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>            <span class="st">"exit"</span> <span class="ot">=</span> <span class="fu">max</span>(exit_params<span class="sc">$</span>mu))</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>sim_out <span class="ot">&lt;-</span> <span class="fu">popsim</span>(</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">model =</span> model,</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">initial_population =</span> pop_init,</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>    <span class="at">events_bounds =</span> bounds,</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>    <span class="at">parameters =</span> <span class="fu">c</span>(entry_params, death_params, exit_params),</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>    <span class="at">time =</span> <span class="dv">30</span>,</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>    <span class="at">age_max =</span> <span class="dv">110</span>,</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>    <span class="at">multithreading =</span> <span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="outputs" class="level2" data-number="5.4">
<h2 data-number="5.4" class="anchored" data-anchor-id="outputs"><span class="header-section-number">5.4</span> Outputs</h2>
<p>The data frame <code>sim_out$population</code> consists of all individuals present in the portfolio during the period of <span class="math inline">[0, 30]</span>, including the individuals in the initial population and those who entered the portfolio. Each row represents an individual, with their date of birth, date of death (<code>NA</code> if still alive at the end of the simulation), risk class, and characteristics <code>entry</code> and <code>out</code>. Recall that if an individual enters the population at time <span class="math inline">t</span>, his <code>entry</code> characteristic is automatically set up to be equal to <span class="math inline">t</span>. The characteristics <code>out</code> is set to <code>TRUE</code> for individuals who left the portfolio due to an exit event.</p>
<p>In this example, the simulation time over 30 years, starting from an initial population of 30 000 individuals is of <span class="math inline">2\times 10^{-4}</span> seconds, for an acceptance rate of proposed event of approximately 25%. At the end of the simulation, the number of alive individuals is approximately 430 000.</p>
<p>Initially in the portfolio (at <span class="math inline">t=0</span>), there is the same number of 65 years old policyholders in each risk class. However, policyholders in the risk class 2 with lower mortality rates leave the portfolio at higher rate than policyholders in the risk class 1 : <span class="math inline">\mu^2 &gt; \mu^1</span>. Therefore, the heterogeneous portfolio composition changes with time, including more and more individuals in risk class 1 with higher mortality rates, but with variations across age classes. To illustrate the composition of the total population at the end of the simulation (<span class="math inline">t=30</span>), we present in Figure <a href="#fig-insur-a" class="quarto-xref">Figure&nbsp;2</a> the age pyramid of the final composition of the portfolio obtained with the <code>age_pyramid</code> and <code>plot</code> function of the <code>pyramid</code> class.</p>
<p><code>IBMPopSim</code> also allows the fast computation of exact life tables from truncated and censored individual data (due to entry and exit events), using the functions <code>death_table</code> and <code>exposure_table</code>. These function are particularly efficient, since the computations are made using the <code>Rccp</code> library.</p>
<p>In Figure <a href="#fig-insur-b" class="quarto-xref">Figure&nbsp;3</a>, we illustrate the central death rates in the simulated portfolio at final time. Due to the mortality differential between risk class 1 and 2, one would expect to observe more individuals in risk class 2 at higher ages. However, due to exit events, a higher proportion of individuals in risk class 1 exit the portfolio over time, resulting in a greater proportion of individuals in risk class 1 at higher ages than what would be expected in the absence of exit events. Consequently, the mortality rates in the portfolio are more aligned with those of risk class 1 at higher ages. This is a simple example of how composition changes in the portfolio can impact aggregated mortality rates and potentially compensate or reduce an overall mortality reduction (see also <span class="citation" data-cites="KAAKAI201916">(<a href="#ref-KAAKAI201916" role="doc-biblioref">Kaakaï et al. 2019</a>)</span>).</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>[1] 427367      5</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.1915915</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.247435</code></pre>
</div>
<div class="cell-output-display">
<div id="fig-insur-a" class="quarto-figure quarto-figure-center quarto-float anchored" data-fig-pos="h">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-insur-a-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="article_files/figure-html/fig-insur-a-1.svg" class="img-fluid figure-img" data-fig-pos="h">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-insur-a-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: Portfolio age pyramid at t = 30 for individuals in risk class 1 (blue) and 2 (red).
</figcaption>
</figure>
</div>
</div>
</div>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>StMoMo: The following cohorts have been zero weigthed: -93 -92 -91 -90 -89 -88 -87 -86 -85 -84 -83 -82 -81 -80 -79 -78 -77 -76 -75 -74 -73 -72 -71 -70 
StMoMo: Start fitting with gnm
Initialising
Running start-up iterations..
Running main iterations......................
Done
StMoMo: Finish fitting with gnm</code></pre>
</div>
<div class="cell-output-display">
<div id="fig-insur-b" class="quarto-figure quarto-figure-center quarto-float anchored" data-fig-pos="h">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-insur-b-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="article_files/figure-html/fig-insur-b-1.svg" class="img-fluid figure-img" data-fig-pos="h">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-insur-b-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3: Portfolio central death rates at t = 30 (black).
</figcaption>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="sec-example-interaction" class="level1" data-number="6">
<h1 data-number="6"><span class="header-section-number">6</span> Population with genetically variable traits</h1>
<p>This section provides an example of how to use the <code>IBMPopSim</code> package to simulate an age-structured population with interactions, based on the model proposed in Example 1 of <span class="citation" data-cites="FerTra09">Ferrière and Tran (<a href="#ref-FerTra09" role="doc-biblioref">2009</a>)</span> (see also <span class="citation" data-cites="meleard2009trait">Méléard and Tran (<a href="#ref-meleard2009trait" role="doc-biblioref">2009</a>)</span>).</p>
<p>In this model, individuals are characterized by their body size at birth <span class="math inline">x_0 \in [0,4]</span> and by their physical age <span class="math inline">a \in [0,2]</span>. The body size of an individual <span class="math inline">I=(\tau^b,\infty, x_0)</span> at time <span class="math inline">t</span> is a linear function of its age <span class="math inline">a(I,t) = t-\tau^b</span>: <span class="math display">x(t)= x_0 + ga(I,t),</span> where <span class="math inline">g</span> is a constant growth rate assumed to be identical for all individuals.</p>
<p><strong>Birth events</strong> The birth intensity of each individual <span class="math inline">I=(\tau^b, \infty, x_0)</span> depends on a parameter <span class="math inline">\alpha &gt; 0</span> and on its initial size, as given by the equation <span id="eq-interaction-birth-intensity"><span class="math display">
\lambda^b(t,I) = \alpha (4 - x_0) \leq \bar \lambda^b = 4\alpha.
\tag{18}</span></span> Thus, smaller individuals have a higher birth intensity. When a birth occurs, the new individual inherit the same birth size <span class="math inline">x_0</span> as its parent with high probability <span class="math inline">1-p</span>, or a mutation can occur with probability <span class="math inline">p</span>, resulting in a birth size given by <span id="eq-interaction-birth-kernel"><span class="math display">
    x_0' = \min(\max(0, x_0 + G), 4),
\tag{19}</span></span> where <span class="math inline">G</span> is a Gaussian random variable with mean 0 and variance <span class="math inline">\sigma^2</span>.</p>
<p><strong>Death events</strong> Due to competition between individuals, the death intensity of an individual depends on the size of other individuals in the population. Bigger individuals have a better chance of survival. If an individual <span class="math inline">I= (\tau^b, \infty, x_0)</span> of size <span class="math inline">x(t)= x_0 +ga(I,t)</span> encounters an individual <span class="math inline">J= (\tau^{b}_J, \infty, x_0')</span> of size <span class="math inline">x'(t) = x_0'+ ga(J,t)</span>, then it can die with the intensity <span class="math display">W(t, I,J) = U(x(t),x'(t)),</span> where the interaction function <span class="math inline">U</span> is defined by <span id="eq-interaction-death-intensity"><span class="math display">
    U(x,y) = \beta \left(1- \frac{1}{1+ c\exp(-4(x-y))}\right) \leq \bar W = \beta.
\tag{20}</span></span> The death intensity of an individual <span class="math inline">I</span> at time <span class="math inline">t</span> and in a population <span class="math inline">Z</span> is the result of interactions with all individuals in the population, including itself, and is given by <span class="math display">\lambda^d_t(I,Z) = \sum_{J = (\tau^b,\infty, x_0') \in Z}  W (x_0 + g a(I,t), x_0' + g a(J,t)),</span></p>
<section id="population" class="level2" data-number="6.1">
<h2 data-number="6.1" class="anchored" data-anchor-id="population"><span class="header-section-number">6.1</span> Population</h2>
<p>We use an initial population of 900 living individuals, all of whom have the same size and ages uniformly distributed between 0 and 2 years.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>N <span class="ot">&lt;-</span> <span class="dv">900</span> </span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>x0 <span class="ot">&lt;-</span> <span class="fl">1.06</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>agemin <span class="ot">&lt;-</span> <span class="fl">0.</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>agemax <span class="ot">&lt;-</span> <span class="fl">2.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>pop_df <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>  <span class="st">"birth"</span> <span class="ot">=</span> <span class="sc">-</span><span class="fu">runif</span>(N, agemin, agemax), <span class="co"># Uniform age in [0,2]</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>  <span class="st">"death"</span> <span class="ot">=</span> <span class="fu">as.double</span>(<span class="cn">NA</span>), <span class="co"># All individuals are alive</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>  <span class="st">"birth_size"</span> <span class="ot">=</span> x0) <span class="co"># All individuals have the same initial birth size x0</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>pop_init <span class="ot">&lt;-</span> <span class="fu">population</span>(pop_df)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="events" class="level2" data-number="6.2">
<h2 data-number="6.2" class="anchored" data-anchor-id="events"><span class="header-section-number">6.2</span> Events</h2>
<section id="birth-events" class="level3" data-number="6.2.1">
<h3 data-number="6.2.1" class="anchored" data-anchor-id="birth-events"><span class="header-section-number">6.2.1</span> Birth events</h3>
<p>The parameters involved in a birth event are the probability of mutation <span class="math inline">p</span>, the variance of the Gaussian random variable and the coefficient <span class="math inline">\alpha</span> of the intensity.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>params_birth <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="st">"p"</span> <span class="ot">=</span> <span class="fl">0.03</span>, <span class="st">"sigma"</span> <span class="ot">=</span> <span class="fu">sqrt</span>(<span class="fl">0.01</span>), <span class="st">"alpha"</span> <span class="ot">=</span> <span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The birth intensity <a href="#eq-interaction-birth-intensity" class="quarto-xref">Equation&nbsp;18</a> is of class <code>individual</code>. Hence, the event is created by calling the <code>mk_event_individual</code> function. The size of the new individual is given in the kernel following <a href="#eq-interaction-birth-kernel" class="quarto-xref">Equation&nbsp;19</a>.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>birth_event <span class="ot">&lt;-</span> <span class="fu">mk_event_individual</span>( </span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">type =</span> <span class="st">"birth"</span>,</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">intensity_code =</span> <span class="st">"result = alpha*(4 - I.birth_size);"</span>,</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">kernel_code =</span> <span class="st">"if (CUnif() &lt; p)</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a><span class="st">                   newI.birth_size = min(max(0.,CNorm(I.birth_size,sigma)),4.);</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a><span class="st">                 else</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a><span class="st">                   newI.birth_size = I.birth_size;"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="death-events" class="level3" data-number="6.2.2">
<h3 data-number="6.2.2" class="anchored" data-anchor-id="death-events"><span class="header-section-number">6.2.2</span> Death events</h3>
<p>The death intensity <a href="#eq-interaction-death-intensity" class="quarto-xref">Equation&nbsp;20</a> is of class <code>interaction</code>. Hence, the event is created by calling the <code>mk_event_interaction</code> function. The parameters used for this event are the growth rate <span class="math inline">g</span>, the amplitude of the interaction function <span class="math inline">\beta</span>, and the strength of competition <span class="math inline">c</span>.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>params_death <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="st">"g"</span> <span class="ot">=</span> <span class="dv">1</span>, <span class="st">"beta"</span> <span class="ot">=</span> <span class="fl">2.</span><span class="sc">/</span><span class="fl">300.</span>, <span class="st">"c"</span> <span class="ot">=</span> <span class="fl">1.2</span>)</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>death_event <span class="ot">&lt;-</span> <span class="fu">mk_event_interaction</span>(</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">type =</span> <span class="st">"death"</span>,</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">interaction_code =</span> <span class="st">"double x_I = I.birth_size + g * age(I,t);</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a><span class="st">                      double x_J = J.birth_size + g * age(J,t);</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a><span class="st">                      result = beta*(1.-1./(1.+c*exp(-4.*(x_I-x_J))));"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
</section>
<section id="model-creation-and-simulation" class="level2" data-number="6.3">
<h2 data-number="6.3" class="anchored" data-anchor-id="model-creation-and-simulation"><span class="header-section-number">6.3</span> Model creation and simulation</h2>
<p>The model is created using the <code>mk_model</code> function.</p>
<p>The simulation of one scenario can then be launched with the call of the <code>popsim</code> function, after computing the events bounds <span class="math inline">\bar \lambda^b=4 \alpha</span> and <span class="math inline">\bar W= \beta</span>.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>model <span class="ot">&lt;-</span> <span class="fu">mk_model</span>(</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">characteristics =</span> <span class="fu">get_characteristics</span>(pop_init),</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">events =</span> <span class="fu">list</span>(birth_event, death_event),</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">parameters =</span> <span class="fu">c</span>(params_birth, params_death))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The simulation of one scenario can then be launched with the call of the <code>popsim</code> function, after computing the events bounds <span class="math inline">\bar \lambda^b=4 \alpha</span> and <span class="math inline">\bar W= \beta</span>.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>sim_out <span class="ot">&lt;-</span> <span class="fu">popsim</span>(<span class="at">model =</span> model,</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">initial_population =</span> pop_init,</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">events_bounds =</span> <span class="fu">c</span>(<span class="st">"birth"</span> <span class="ot">=</span> <span class="dv">4</span> <span class="sc">*</span> params_birth<span class="sc">$</span>alpha, </span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>                      <span class="st">"death"</span> <span class="ot">=</span> params_death<span class="sc">$</span>beta),</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">parameters =</span> <span class="fu">c</span>(params_birth, params_death),</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">age_max =</span> <span class="dv">2</span>,</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">time =</span> <span class="dv">500</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Based on the results of a simulation, we can reproduce the numerical results of <span class="citation" data-cites="FerTra09">Ferrière and Tran (<a href="#ref-FerTra09" role="doc-biblioref">2009</a>)</span>. In <a href="#fig-birth-size" class="quarto-xref">Figure&nbsp;4</a>, we draw a line for each individual in the population to represent their birth size during their lifetime.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-birth-size" class="quarto-figure quarto-figure-center quarto-float anchored" data-fig-pos="h">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-birth-size-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="article_files/figure-html/fig-birth-size-1.svg" class="img-fluid figure-img" data-fig-pos="h">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-birth-size-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4: Evolution of birth size
</figcaption>
</figure>
</div>
</div>
</div>
<p>In this example, the randomized <a href="#alg-randomized">Algorithm 3</a> allows for much faster computation times than the model implemented below with <a href="#alg-interaction">Algorithm 2</a> (“full” algorithm):</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>death_event_full <span class="ot">&lt;-</span> <span class="fu">mk_event_interaction</span>(<span class="at">type =</span> <span class="st">"death"</span>,</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>                             <span class="at">interaction_type=</span> <span class="st">"full"</span>,</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>                             <span class="at">interaction_code =</span> <span class="st">"double x_I = I.birth_size + g * age(I,t);</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="st">                                                 double x_J = J.birth_size + g * age(J,t);</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a><span class="st">                                result = beta * ( 1.- 1./(1. + c * exp(-4. * (x_I-x_J))));"</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>model_full <span class="ot">&lt;-</span> <span class="fu">mk_model</span>(<span class="at">characteristics =</span> <span class="fu">get_characteristics</span>(pop_init),</span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>                       <span class="at">events =</span> <span class="fu">list</span>(birth_event, death_event_full),</span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>                       <span class="at">parameters =</span> <span class="fu">c</span>(params_birth, params_death))</span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>sim_out_full <span class="ot">&lt;-</span> <span class="fu">popsim</span>(<span class="at">model =</span> model_full,</span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a>                       <span class="at">initial_population =</span> pop_init,</span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a>                       <span class="at">events_bounds =</span><span class="fu">c</span>(<span class="st">"birth"</span> <span class="ot">=</span> <span class="dv">4</span> <span class="sc">*</span> params_birth<span class="sc">$</span>alpha,</span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a>                                        <span class="st">"death"</span> <span class="ot">=</span> params_death<span class="sc">$</span>beta),</span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true" tabindex="-1"></a>                       <span class="at">parameters =</span> <span class="fu">c</span>(params_birth, params_death),</span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true" tabindex="-1"></a>                       <span class="at">age_max =</span> <span class="dv">2</span>,</span>
<span id="cb33-18"><a href="#cb33-18" aria-hidden="true" tabindex="-1"></a>                       <span class="at">time =</span> <span class="dv">500</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>[1] "The full algorithm is 19.9464867965266 times slower than the randomized version"</code></pre>
</div>
</div>
<p>In <a href="#fig-fullvsrandom" class="quarto-xref">Figure&nbsp;5</a>, the two algorithms are compared for different population sizes.<br>
We progressively decrease the value of the mortality rate parameter <span class="math inline">\beta</span> and increase the birth rate parameter <span class="math inline">\alpha</span>. Starting with the values provided in&nbsp;<span class="citation" data-cites="FerTra09">Ferrière and Tran (<a href="#ref-FerTra09" role="doc-biblioref">2009</a>)</span>, <span class="math inline">\alpha=1</span> and <span class="math inline">\beta=2/300</span>, resulting in a stationary population size of approximately <span class="math inline">N=360</span> individuals for a sample of 50 simulations, we can easily increase the stationary population size to approximately <span class="math inline">N=2600</span> individuals with <span class="math inline">\alpha=2</span> and <span class="math inline">\beta=1/300</span> .<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> In the log-scaled figure, we can observe the trend of computation time as a function of the population size <span class="math inline">N</span>, which is linear for the randomized algorithm and quadratic for the full one ( <a href="#alg-interaction">Algorithm 2</a>). We can also see that the randomized version of the algorithm is between 17 to 100 times faster than the full one in this example, taking only 2 seconds in average for the randomized version versus 211 seconds for <a href="#alg-interaction">Algorithm 2</a> for the biggest population size (<span class="math inline">N=2600</span>) and <span class="math inline">T=500</span>.</p>
<div id="fig-fullvsrandom" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-fullvsrandom-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/time_pop_size.png" class="img-fluid figure-img" style="width:80.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-fullvsrandom-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5: Full vs random algorithm computztion time
</figcaption>
</figure>
</div>
</section>
</section>

<section id="references" class="level1 unnumbered">
<h1 class="unnumbered">References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-BanMel15" class="csl-entry" role="listitem">
Bansaye, Vincent, and Sylvie Méléard. 2015. <em>Stochastic Models for Structured Populations</em>. Springer International Publishing.
</div>
<div id="ref-barrieu2012understanding" class="csl-entry" role="listitem">
Barrieu, Pauline, Harry Bensusan, Nicole El Karoui, Caroline Hillairet, Stéphane Loisel, Claudia Ravanelli, and Yahia Salhi. 2012. <span>“Understanding, Modelling and Managing Longevity Risk: Key Issues and Main Challenges.”</span> <em>Scandinavian Actuarial Journal</em> 2012 (3): 203–31.
</div>
<div id="ref-Ben10" class="csl-entry" role="listitem">
Bensusan, Harry. 2010. <span>“<span class="nocase">Interest rate and longevity risk: dynamic model and applications to derivative products and life insurance</span>.”</span> Theses, <span>Ecole Polytechnique X</span>.
</div>
<div id="ref-billiard2016effect" class="csl-entry" role="listitem">
Billiard, Sylvain, Pierre Collet, Régis Ferrière, Sylvie Méléard, and Viet Chi Tran. 2016. <span>“The Effect of Competition and Horizontal Trait Inheritance on Invasion, Fixation, and Polymorphism.”</span> <em>Journal of Theoretical Biology</em> 411: 48–58.
</div>
<div id="ref-Bou16" class="csl-entry" role="listitem">
Boumezoued, Alexandre. 2016. <span>“<span class="nocase">Micro-macro analysis of heterogenous age-structured populations dynamics.Application to self-exciting processes and demography.</span>”</span> Theses, <span>Universit<span>é</span> Pierre et Marie Curie</span>.
</div>
<div id="ref-bremaud1981point" class="csl-entry" role="listitem">
Brémaud, Pierre. 1981. <em>Point Processes and Queues: Martingale Dynamics</em>. Vol. 66. Springer.
</div>
<div id="ref-calvez2020horizontal" class="csl-entry" role="listitem">
Calvez, Vincent, Susely Figueroa Iglesias, Hélène Hivert, Sylvie Méléard, Anna Melnykova, and Samuel Nordmann. 2020. <span>“Horizontal Gene Transfer: Numerical Comparison Between Stochastic and Deterministic Approaches.”</span> <em>ESAIM: Proceedings and Surveys</em> 67: 135–60.
</div>
<div id="ref-Cin11" class="csl-entry" role="listitem">
Çinlar, Erhan. 2011. <em><span class="nocase">Probability and Stochastics</span></em>. Springer New York.
</div>
<div id="ref-collet2013rigorous" class="csl-entry" role="listitem">
Collet, Pierre, Sylvie Méléard, and Johan AJ Metz. 2013. <span>“A Rigorous Model Study of the Adaptive Dynamics of Mendelian Diploids.”</span> <em>Journal of Mathematical Biology</em> 67: 569–607.
</div>
<div id="ref-costa2016stochastic" class="csl-entry" role="listitem">
Costa, Manon, Céline Hauzy, Nicolas Loeuille, and Sylvie Méléard. 2016. <span>“Stochastic Eco-Evolutionary Model of a Prey-Predator Community.”</span> <em>Journal of Mathematical Biology</em> 72: 573–622.
</div>
<div id="ref-Dev86" class="csl-entry" role="listitem">
Devroye, Luc. 1986. <em>Nonuniform Random Variate Generation</em>. Springer-Verlag, New York.
</div>
<div id="ref-JSSv040i08" class="csl-entry" role="listitem">
Eddelbuettel, Dirk, and Romain Francois. 2011. <span>“Rcpp: Seamless r and c++ Integration.”</span> <em>Journal of Statistical Software</em> 40 (8): 1–18. <a href="https://doi.org/10.18637/jss.v040.i08">https://doi.org/10.18637/jss.v040.i08</a>.
</div>
<div id="ref-karoui2021simulating" class="csl-entry" role="listitem">
El Karoui, Nicole, Kaouther Hadji, and Sarah Kaakai. 2021. <span>“Simulating Long-Term Impacts of Mortality Shocks: Learning from the Cholera Pandemic.”</span> <em>arXiv Preprint arXiv:2111.08338</em>.
</div>
<div id="ref-FerTra09" class="csl-entry" role="listitem">
Ferrière, Régis, and Viet Chi Tran. 2009. <span>“Stochastic and Deterministic Models for Age-Structured Populations with Genetically Variable Traits.”</span> In, 27:289–310. ESAIM Proc. EDP Sci., Les Ulis.
</div>
<div id="ref-FouMel04" class="csl-entry" role="listitem">
Fournier, Nicolas, and Sylvie Méléard. 2004. <span>“A Microscopic Probabilistic Description of a Locally Regulated Population and Macroscopic Approximations.”</span> <em>Ann. Appl. Probab.</em> 14 (4): 1880–1919.
</div>
<div id="ref-Rdemography" class="csl-entry" role="listitem">
Hyndman, Rob, Heather Booth Booth, Leonie Tickle Tickle, John Maindonald, Simon Wood Wood, and R Core Team. 2023. <em><span class="nocase">demography</span>: Forecasting Mortality, Fertility, Migration and Population Data</em>. <a href="https://cran.r-project.org/package=demography">https://cran.r-project.org/package=demography</a>.
</div>
<div id="ref-KaaElK20" class="csl-entry" role="listitem">
Kaakai, Sarah, and Nicole El Karoui. 2023. <span>“Birth Death Swap Population in Random Environment and Aggregation with Two Timescales.”</span> <em>Stochastic Processes and Their Applications</em> 162: 218–48. https://doi.org/<a href="https://doi.org/10.1016/j.spa.2023.04.017">https://doi.org/10.1016/j.spa.2023.04.017</a>.
</div>
<div id="ref-KAAKAI201916" class="csl-entry" role="listitem">
Kaakaï, Sarah, Héloïse Labit Hardy, Séverine Arnold, and Nicole El Karoui. 2019. <span>“How Can a Cause-of-Death Reduction Be Compensated for by the Population Heterogeneity? A Dynamic Approach.”</span> <em>Insurance: Mathematics and Economics</em> 89: 16–37. https://doi.org/<a href="https://doi.org/10.1016/j.insmatheco.2019.07.005">https://doi.org/10.1016/j.insmatheco.2019.07.005</a>.
</div>
<div id="ref-Kal17" class="csl-entry" role="listitem">
Kallenberg, Olav. 2017. <em>Random Measures, Theory and Applications</em>. Vol. 77. Probability Theory and Stochastic Modelling. Springer, Cham.
</div>
<div id="ref-lavallee2019stochastic" class="csl-entry" role="listitem">
Lavallée, François, Charline Smadi, Isabelle Alvarez, Björn Reineking, François-Marie Martin, Fanny Dommanget, and Sophie Martin. 2019. <span>“A Stochastic Individual-Based Model for the Growth of a Stand of Japanese Knotweed Including Mowing as a Management Technique.”</span> <em>Ecological Modelling</em> 413: 108828.
</div>
<div id="ref-LewShe79" class="csl-entry" role="listitem">
Lewis, Peter, and Gerald Shedler. 1979. <span>“Simulation of Nonhomogeneous Poisson Processes by Thinning.”</span> <em>Naval Research Logistics Quarterly</em> 26 (3): 403–13.
</div>
<div id="ref-meleard2019birth" class="csl-entry" role="listitem">
Méléard, Sylvie, Michael Rera, and Tristan Roget. 2019. <span>“A Birth–Death Model of Ageing: From Individual-Based Dynamics to Evolutive Differential Inclusions.”</span> <em>Journal of Mathematical Biology</em> 79: 901–39.
</div>
<div id="ref-meleard2009trait" class="csl-entry" role="listitem">
Méléard, Sylvie, and Viet Chi Tran. 2009. <span>“Trait Substitution Sequence Process and Canonical Equation for Age-Structured Populations.”</span> <em>Journal of Mathematical Biology</em> 58: 881–921.
</div>
<div id="ref-roget2022positive" class="csl-entry" role="listitem">
Roget, Tristan, Pierre Jolivet, Sylvie Méléard, and Michael Rera. 2022. <span>“Positive Selection of Senescence Through Increased Evolvability: Ageing Is Not a by-Product of Evolution.”</span> <em>bioRxiv</em>, 2022–03.
</div>
<div id="ref-tran_2008" class="csl-entry" role="listitem">
Tran, Viet Chi. 2008. <span>“Large Population Limit and Time Behaviour of a Stochastic Particle Model Describing an Age-Structured Population.”</span> <em>ESAIM: Probability and Statistics</em> 12: 345–86. <a href="https://doi.org/10.1051/ps:2007052">https://doi.org/10.1051/ps:2007052</a>.
</div>
<div id="ref-stmomo" class="csl-entry" role="listitem">
Villegas, Andrés M., Vladimir K. Kaishev, and Pietro Millossovich. 2018. <span>“<span class="nocase">StMoMo: An R Package for Stochastic Mortality Modelling</span>.”</span> <em>Journal of Statistical Software</em> 84: 1–38.
</div>
<div id="ref-Rstmomo" class="csl-entry" role="listitem">
Villegas, Andres, Pietro Millossovich, and Vladimir Kaishev Hyndman. 2018. <em><span>StMoMo</span>: Stochastic Mortality Modelling</em>. <a href="https://cran.r-project.org/package=StMoMo">https://cran.r-project.org/package=StMoMo</a>.
</div>
<div id="ref-Zin14" class="csl-entry" role="listitem">
Zinn, Sabine. 2014. <span>“<span class="nocase">The MicSim package of R: an entry-level toolkit for continuous-time microsimulation</span>.”</span> <em>International Journal of Microsimulation</em> 7 (3): 3–32.
</div>
<div id="ref-zinn2009mic" class="csl-entry" role="listitem">
Zinn, Sabine, Jutta Gampe, Jan Himmelspach, and Adelinde M Uhrmacher. 2009. <span>“MIC-CORE: A Tool for Microsimulation.”</span> In <em>Proceedings of the 2009 Winter Simulation Conference (WSC)</em>, 992–1002. IEEE.
</div>
</div>
</section>



<div id="quarto-appendix" class="default"><section id="appendix" class="level1 appendix" data-number="7"><h2 class="anchored quarto-appendix-heading"><span class="header-section-number">7</span> Appendix</h2><div class="quarto-appendix-contents">

<section id="sec-recall-poisson" class="level2" data-number="7.1">
<h2 data-number="7.1" class="anchored" data-anchor-id="sec-recall-poisson"><span class="header-section-number">7.1</span> Recall on Poisson random measures</h2>
<p>We recall below some useful properties of Poisson random measures, mainly following Chapter&nbsp;6 of&nbsp;<span class="citation" data-cites="Cin11">(<a href="#ref-Cin11" role="doc-biblioref">Çinlar 2011</a>)</span>. We also refer to&nbsp;<span class="citation" data-cites="Kal17">(<a href="#ref-Kal17" role="doc-biblioref">Kallenberg 2017</a>)</span> for a more comprehensive presentation of random counting measures.</p>
<div id="def-poisson-random-measure" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 1 (Poisson Random Measures)</strong></span> Let <span class="math inline">\mu</span> be a <span class="math inline">\sigma</span>-finite diffuse measure on a Borel subspace <span class="math inline">(E,\mathcal{E})</span> of <span class="math inline">({\mathbb{R}}^d, \mathcal{B}({\mathbb{R}}^d))</span>. A random counting measure <span class="math inline">Q= \sum_{k\geq 1} \delta_{X_k}</span> is a Poisson (counting) random measure of <em>mean measure</em> <span class="math inline">\mu</span> if</p>
<ol type="1">
<li><span class="math inline">\forall A \in \mathcal{E}</span>, <span class="math inline">Q(A)</span> is a Poisson random variable with <span class="math inline">{\mathbb{E}}[Q(A)]= \mu(A)</span>.</li>
<li>For all disjoints subsets <span class="math inline">A_1, \dots, A_n \in \mathcal{E}</span>, <span class="math inline">Q(A_1), \dots, Q(A_n)</span> are independent Poisson random variables.</li>
</ol>
</div>
<p>Let us briefly recall here some simple but useful operations on Poisson measures. In the following, <span class="math inline">Q</span> is a Poisson measure of mean measure <span class="math inline">\mu</span>, unless stated otherwise.</p>
<div id="prp-restriction-poisson-measure" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 4 (Restricted Poisson measure)</strong></span> If <span class="math inline">B \in \mathcal{E}</span>, then, the restriction of <span class="math inline">Q</span> to <span class="math inline">B</span> defined by <span class="math display">
    Q^B = \boldsymbol{1}_B Q = \sum_{k \ge 1} \mathbf{1}_{B}(X_k) \delta_{X_k}
</span> is also a Poisson random measure, of mean measure <span class="math inline">\mu^B = \mu(\cdot \cap B)</span>.</p>
</div>
<div id="prp-proj-poisson-measure" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 5 (Projection of Poisson measure)</strong></span> If <span class="math inline">E = F_1 \times F_2</span> is a product space, then the projection <span class="math display">
    Q_1(\mathrm{d}x) = \int_{F_2} Q(\mathrm{d}x , \mathrm{d}y)
</span> is a Poisson random measure of mean measure <span class="math inline">\mu_1 (\mathrm{d}x ) = \int_{F_2} \mu(\mathrm{d}x, \mathrm{d}y)</span>.</p>
</div>
<section id="link-with-poisson-processes" class="level3" data-number="7.1.1">
<h3 data-number="7.1.1" class="anchored" data-anchor-id="link-with-poisson-processes"><span class="header-section-number">7.1.1</span> Link with Poisson processes</h3>
<p>Let <span class="math inline">Q= \sum_{k\geq 1} \delta_{T_k}</span> a Poisson random measure on <span class="math inline">E={\mathbb{R}}^+</span> with mean measure <span class="math inline">\mu(\mathrm{d}t) = \Lambda (t) \mathrm{d}t</span> absolutely continuous with respect to the Lebesgue measure, <span class="math inline">\mu(A) = \int_A \Lambda(t) \mathrm{d}t</span>. The counting process <span class="math inline">(N_t)_{t \ge 0}</span> defined by <span id="eq-inhomogeneous-pp"><span class="math display">
    N_t = Q([0,t]) = \sum_{k \geq 1} \boldsymbol{1}_{\{T_k \leq t\}}, \quad \forall \; t\geq 0,
\tag{21}</span></span> is an inhomogeneous Poisson process with intensity function (or rate) <span class="math inline">t \mapsto \Lambda(t)</span>. In particular, when <span class="math inline">\Lambda(t) \equiv c</span> is a constant, <span class="math inline">N</span> is a homogeneous Poisson process with rate <span class="math inline">c</span>. Assuming that the atoms are ordered <span class="math inline">T_1&lt; T_2&lt; \dots</span>, we recall that the sequence <span class="math inline">(T_{k+1}-T_k)_{k\geq 1}</span> is a sequence of <em>i.i.d.</em> exponential variables of parameter <span class="math inline">c</span>.</p>
</section>
<section id="marked-poisson-measures-on-e-mathbbr-times-f" class="level3" data-number="7.1.2">
<h3 data-number="7.1.2" class="anchored" data-anchor-id="marked-poisson-measures-on-e-mathbbr-times-f"><span class="header-section-number">7.1.2</span> Marked Poisson measures on <span class="math inline">E = {\mathbb{R}}^+ \times F</span></h3>
<p>We are interested in the particular case when <span class="math inline">E</span> is the product space <span class="math inline">{\mathbb{R}}^+ \times F</span>, with <span class="math inline">(F,\mathcal{F})</span> a Borel subspace of <span class="math inline">{\mathbb{R}}^d</span>. Then, a random counting measure is defined by a random set <span class="math inline">S =\{ (T_k, \Theta_k ), k \geq 1\}</span>. The random variables <span class="math inline">T_k\geq 0</span> can be considered as time variables, and constitute the jump times of the random measure, while the variables <span class="math inline">\Theta_k \in F</span> represent space variables.</p>
<p>We recall in this special case the Theorem&nbsp;VI.3.2 in&nbsp;<span class="citation" data-cites="Cin11">(<a href="#ref-Cin11" role="doc-biblioref">Çinlar 2011</a>)</span>.</p>
<div id="prp-marked-poisson" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 6 (Marked Poisson measure)</strong></span> Let <span class="math inline">m</span> be a <span class="math inline">\sigma</span>–finite diffuse measure on <span class="math inline">{\mathbb{R}}^+</span>, and <span class="math inline">K</span> a transition probability kernel from <span class="math inline">({\mathbb{R}}^+,\mathcal{B}({\mathbb{R}}^+))</span> into <span class="math inline">(F, \mathcal{F})</span>. Assume that the collection <span class="math inline">(T_k)_{k \ge 1}</span> forms a Poisson process <span class="math inline">(N_t) =(\sum_{k\geq 1} \mathsf{1}_{\{T_k \leq t\}})</span> with mean <span class="math inline">m(\mathrm{d}t) =\Lambda(t) \mathrm{d}t</span>, and that given <span class="math inline">(T_k)_{k \ge 1}</span>, the variables <span class="math inline">\Theta_k</span> are conditionally independent and have the respective distributions <span class="math inline">K(T_k, \cdot)</span>.</p>
<ol type="1">
<li><p>Then, <span class="math inline">\{ (T_k, \Theta_k) ;\; k \ge 1\}</span> forms a Poisson random measure <span class="math inline">Q = \sum_{k\ge 1} \delta_{(T_k, \Theta_k)}</span> on <span class="math inline">({\mathbb{R}}^+ \times F, \mathcal{B}({\mathbb{R}}^+) \otimes \mathcal{F})</span>, called a <em>Marked point process</em> , with mean <span class="math inline">\mu</span> defined by <span class="math display">
\mu(\mathrm{d}t, \mathrm{d}y) = \Lambda(t) \mathrm{d}t K(t, \mathrm{d}y).
</span></p></li>
<li><p>Reciprocally let <span class="math inline">Q</span> be a Poisson random measure of mean measure <span class="math inline">\mu(\mathrm{d}t, \mathrm{d}y)</span>, admitting the following disintegration with respect to the first coordinate: <span class="math inline">\mu(\mathrm{d}t , \mathrm{d}y) =\tilde  \Lambda(t) \mathrm{d}t \nu(t, \mathrm{d}y)</span>, with <span class="math inline">\nu(t, F)&lt;\infty</span>. Let <span class="math inline">K(t, \mathrm{d}y) = \dfrac{\nu(t,\mathrm{d}y) }{\nu(t, F) }</span> and <span class="math inline">\Lambda(t) = \nu(t, F)\tilde  \Lambda(t)</span>. Then, <span class="math inline">Q = \sum_{k\ge 1} \delta_{(T_k, \Theta_k)}</span> is a marked Poisson measure with <span class="math inline">(T_k,\Theta_k)_{k\in {\mathbb{N}}^*}</span> defined as above. In particular, the projection <span class="math inline">N= (N_t)_{t\geq0}</span> of the Poisson measure on the first coordinate, <span class="math display">
N_t = Q([0,t] \times F) = \sum_{k\geq 1} \boldsymbol{1}_{[0,t] \times F} (T_k, \Theta_k)  = \sum_{k\geq 1} \boldsymbol{1}_{\{T_k \leq t\}}, \quad \forall \; t \geq 0,
</span> is an inhomogeneous Poisson process of rate <span class="math inline">\Lambda(t)= \nu(t, F)\tilde  \Lambda(t)</span>.</p></li>
</ol>
</div>
<div id="rem">
<p>When the transition probability kernel <span class="math inline">K</span> does not depend on the time: <span class="math inline">K(t, A) = \nu(A)</span> for some probability measure <span class="math inline">\nu</span>, then the marks <span class="math inline">(\Theta_k)_{k \ge 1}</span> form an <em>i.i.d.</em> sequence with distribution <span class="math inline">\nu</span>, independent of <span class="math inline">(T_k)_{k \ge 1}</span>.</p>
</div>
<p>The preceding proposition thus yields a straight forward iterative simulation procedure for a Marked Poisson process on <span class="math inline">[0,T]\times F</span> with mean measure <span class="math inline">\mu(\mathrm{d}t, \mathrm{d}y) = c \mathrm{d}t K(t, \mathrm{d}y)</span> and <span class="math inline">c&gt;0</span>. The procedure is described in <span class="citation" data-cites="alg-marked-poisson">(<a href="#ref-alg-marked-poisson" role="doc-biblioref"><strong>alg-marked-poisson?</strong></a>)</span>.</p>
<div id="fig-poisson" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-poisson-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<embed src="img/plot_poisson.tex" class="img-fluid">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-poisson-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;6: Example of Marked Poisson measure on <span class="math inline">[0,T]</span> with <span class="math inline">m(\mathrm{d} t) = L \mathrm{d} t</span> (jump times occur at Poisson arrival times of rate <span class="math inline">L</span>) and with <span class="math inline">\nu(\mathrm{d} y) = \frac{1}{L} \mathbf{1}_{[0, L]}(y) \mathrm{d} y</span> (marks are drawn uniformly on <span class="math inline">[0,L]</span>). The mean measure is then <span class="math inline">\mu(\mathrm{d} t, \mathrm{d} y) = \mathrm{d} t {1}_{[0,L]}(y) \mathrm{d} y</span>.
</figcaption>
</figure>
</div>
</section>
</section>
<section id="sec-pathwise-representation" class="level2" data-number="7.2">
<h2 data-number="7.2" class="anchored" data-anchor-id="sec-pathwise-representation"><span class="header-section-number">7.2</span> Pathwise representation of IBMs</h2>
<section id="notation-reminder" class="level3" data-number="7.2.1">
<h3 data-number="7.2.1" class="anchored" data-anchor-id="notation-reminder"><span class="header-section-number">7.2.1</span> Notation reminder</h3>
<p>The population’s evolution is described by the measure valued process <span class="math inline">(Z_t)_{t\geq 0}</span>. Several types of events <span class="math inline">e</span> can occur to individuals denoted by <span class="math inline">I</span>. In an event of type <span class="math inline">e</span> occur to the individual <span class="math inline">I</span> at time <span class="math inline">t</span>, then the population state <span class="math inline">Z_{t^-}</span> is modified by <span class="math inline">\phi^e(t,I)</span>. If <span class="math inline">e\in \mathcal{E} \cup \mathcal{E}_W</span>, then events of type <span class="math inline">e</span> occur with an intensity <span class="math inline">\sum_{k=1}^{N_t} \lambda_t^e(I,Z_t)</span>, with <span class="math inline">\lambda_t^e(I,Z_t)</span> defined by <a href="#eq-individual-intensity" class="quarto-xref">Equation&nbsp;7</a>. If <span class="math inline">e \in \mathcal{P}</span>, then events of type <span class="math inline">e</span> occur in the population at a Poisson intensity of <span class="math inline">(\mu^e_t)</span>.</p>
</section>
<section id="sec-prf-thm-eq-Z" class="level3" data-number="7.2.2">
<h3 data-number="7.2.2" class="anchored" data-anchor-id="sec-prf-thm-eq-Z"><span class="header-section-number">7.2.2</span> Proof of <a href="#thm-eq-Z" class="quarto-xref">Theorem&nbsp;1</a></h3>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>For ease of notation, we prove the case when <span class="math inline">\mathcal{P} =\emptyset</span> (there are no events with Poisson intensity).</p>
<ul>
<li>Step 1. The existence of a solution to <a href="#eq-sde-eq-Z" class="quarto-xref">Equation&nbsp;12</a> is obtained by induction. Let <span class="math inline">Z^1</span> be the unique solution the thinning equation: <span class="math display">
  Z_t^1 = Z_0 + \int_0^t \int_{ \mathcal{J}\times \mathbb R^+ }\phi^e (s , I_k)  \mathbf{1}_{\{k \leq N_{0}\} }\mathbf{1}_{\{\theta \leq \lambda_s^e(I_k, Z_{0})\}} Q (\mathrm{d}s,\mathrm{d}k , \mathrm{d}e, \mathrm{d}\theta ), \quad \forall  0 \leq t \leq T.
</span> Let <span class="math inline">T_1</span> be the first jump time of <span class="math inline">Z^1</span>. Since <span class="math inline">Z_{s^-}^1 = Z_{0}</span> and <span class="math inline">N_{s^-}=N_{0}</span> on <span class="math inline">[0, T_1]</span>, <span class="math inline">Z^1</span> is solution of <a href="#eq-sde-eq-Z" class="quarto-xref">Equation&nbsp;12</a> on <span class="math inline">[0,T_1]</span>.</li>
</ul>
<p>Let us now assume that <a href="#eq-sde-eq-Z" class="quarto-xref">Equation&nbsp;12</a> admits a solution <span class="math inline">Z^n</span> on <span class="math inline">[0,T_n]</span>, with <span class="math inline">T_n</span> the <span class="math inline">n</span>–th event time in the population. Let <span class="math inline">Z^{n+1}</span> be the unique solution of the thinning equation: <span class="math display">
    Z^{n+1}_t  =  Z_{t\wedge T_n}^n + \int_{t\wedge T_n}^{t} \int_{ \mathcal{J}\times \mathbb R^+ }\phi^e (s , I_k)  \mathbf{1}_{\{\theta \leq \lambda_s^e(I_k, Z_{T_n}^n)\}} \mathbf{1}_{\{k \leq N_{T_n}^n \} }Q (\mathrm{d}s ,\mathrm{d}k , \mathrm{d}e, \mathrm{d}\theta ).
</span> First, observe that <span class="math inline">Z^{n+1}</span> coincides with <span class="math inline">Z^n</span> on <span class="math inline">[0,T_n]</span>. Let <span class="math inline">T_{n+1}</span> be the <span class="math inline">(n+1)</span>–th jump of <span class="math inline">Z^{n+1}</span>. Furthermore, <span class="math inline">Z_{s^-}^{n+1} = Z_{T_n}^n</span> and <span class="math inline">N_{s^-}^{n+1}=N_{T_n}^{n}</span> on <span class="math inline">[T_n, T_{n+1}]</span> (nothing happens between two successive event times), <span class="math inline">Z^{n+1}</span> verifies for all <span class="math inline">t\leq T_{n+1}</span>: <span class="math display">
\begin{aligned}
    Z^{n+1}_t  =  Z_{t\wedge T_n}^n +\int_{t\wedge T_n}^{t} \int_{ \mathcal{J}\times \mathbb R^+ }\phi^e (s , I_k)  \mathbf{1}_{\{\theta \leq \lambda_s^e(I_k, Z_{s^-}^{n+1} )\}} \mathbf{1}_{\{k \leq N_{s^-}^{n+1} \} }Q (\mathrm{d}s ,\mathrm{d}k , \mathrm{d}e, \mathrm{d}\theta ).
\end{aligned}
</span> Since, <span class="math inline">Z^n</span> is a solution of <a href="#eq-sde-eq-Z" class="quarto-xref">Equation&nbsp;12</a> on <span class="math inline">[0,T_n]</span> coinciding with <span class="math inline">Z^{n+1}</span>, this achieves to prove that <span class="math inline">Z^{n+1}</span> is solution of <a href="#eq-sde-eq-Z" class="quarto-xref">Equation&nbsp;12</a> on <span class="math inline">[0,T_{n+1}]</span>. Finally, let <span class="math inline">Z =\lim_{n\to \infty } Z^n</span>. For all <span class="math inline">n\geq 1</span>, <span class="math inline">T_n</span> is the <span class="math inline">n</span>–th event time of <span class="math inline">Z</span>, and <span class="math inline">Z</span> is solution of <a href="#eq-sde-eq-Z" class="quarto-xref">Equation&nbsp;12</a> on all time intervals <span class="math inline">[0,T_n\wedge T]</span> by construction.</p>
<p>By <a href="#lem-non-explosion" class="quarto-xref">Lemma&nbsp;1</a> <span class="math inline">T_n \underset{n\to \infty}{\longrightarrow} \infty</span>. Thus, by letting <span class="math inline">n\to \infty</span> we can conclude that <span class="math inline">Z</span> is a solution of <a href="#eq-sde-eq-Z" class="quarto-xref">Equation&nbsp;12</a> on <span class="math inline">[0,T]</span>.</p>
<ul>
<li>Step 2. Let <span class="math inline">\tilde Z</span> be a solution of <a href="#eq-sde-eq-Z" class="quarto-xref">Equation&nbsp;12</a>. Using the same arguments than in Step 1, it is straight forward to show that <span class="math inline">\tilde Z</span> coincides with <span class="math inline">Z^n</span> on <span class="math inline">[0,T_n]</span>, for all <span class="math inline">n \geq 1</span>. Thus, <span class="math inline">\tilde{Z} = Z</span>, with achieves to prove uniqueness.</li>
</ul>
</div>
</section>
<section id="sec-prf-lem-non-explosion" class="level3" data-number="7.2.3">
<h3 data-number="7.2.3" class="anchored" data-anchor-id="sec-prf-lem-non-explosion"><span class="header-section-number">7.2.3</span> Proof of <a href="#lem-non-explosion" class="quarto-xref">Lemma&nbsp;1</a></h3>
<p>The proof is obtained using pathwise comparison result, generalizing those obtained in <span class="citation" data-cites="KaaElK20">(<a href="#ref-KaaElK20" role="doc-biblioref">Kaakai and El Karoui 2023</a>)</span>.</p>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>TODO</p>
</div>
</section>
<section id="alternative-pathwise-representation" class="level3" data-number="7.2.4">
<h3 data-number="7.2.4" class="anchored" data-anchor-id="alternative-pathwise-representation"><span class="header-section-number">7.2.4</span> Alternative pathwise representation</h3>
<p>TODO</p>
</section>
</section>
<section id="sec-prf-thm-interaction" class="level2" data-number="7.3">
<h2 data-number="7.3" class="anchored" data-anchor-id="sec-prf-thm-interaction"><span class="header-section-number">7.3</span> Proof of <a href="#thm-interaction" class="quarto-xref">Theorem&nbsp;2</a></h2>
<p>TODO</p>
</section>
</div></section><section id="session-information" class="level1 appendix unnumbered"><h2 class="anchored quarto-appendix-heading">Session information</h2><div class="quarto-appendix-contents">

<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sessionInfo</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>R version 4.3.2 (2023-10-31)
Platform: x86_64-pc-linux-gnu (64-bit)
Running under: Debian GNU/Linux trixie/sid

Matrix products: default
BLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.11.0 
LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.11.0

locale:
 [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       
 [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   
 [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          
[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   

time zone: Europe/Paris
tzcode source: system (glibc)

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base     

other attached packages:
[1] reshape2_1.4.4  StMoMo_0.4.1    forecast_8.21.1 gnm_1.1-5      
[5] IBMPopSim_1.0.0 ggplot2_3.4.4  

loaded via a namespace (and not attached):
 [1] dotCall64_1.1-1          gtable_0.3.4             spam_2.10-0             
 [4] xfun_0.41                htmlwidgets_1.6.4        lattice_0.22-5          
 [7] tzdb_0.4.0               quadprog_1.5-8           vctrs_0.6.5             
[10] tools_4.3.2              generics_0.1.3           curl_5.2.0              
[13] parallel_4.3.2           tibble_3.2.1             fansi_1.0.6             
[16] xts_0.13.1               pkgconfig_2.0.3          Matrix_1.6-5            
[19] checkmate_2.3.1          RColorBrewer_1.1-3       lifecycle_1.0.4         
[22] rootSolve_1.8.2.4        farver_2.1.1             stringr_1.5.1           
[25] compiler_4.3.2           fields_15.2              munsell_0.5.0           
[28] htmltools_0.5.7          maps_3.4.2               yaml_2.3.8              
[31] pillar_1.9.0             MASS_7.3-60.0.1          nlme_3.1-164            
[34] fracdiff_1.5-2           tidyselect_1.2.0         fanplot_4.0.0           
[37] digest_0.6.34            stringi_1.8.3            dplyr_1.1.4             
[40] labeling_0.4.3           qvcalc_1.0.3             tseries_0.10-55         
[43] RcppArmadillo_0.12.6.6.1 fastmap_1.1.1            grid_4.3.2              
[46] colorspace_2.1-0         cli_3.6.2                magrittr_2.0.3          
[49] relimp_1.0-5             utf8_1.2.4               readr_2.1.5             
[52] withr_3.0.0              scales_1.3.0             backports_1.4.1         
[55] TTR_0.24.4               rmarkdown_2.25           quantmod_0.4.25         
[58] nnet_7.3-19              timeDate_4032.109        zoo_1.8-12              
[61] hms_1.1.3                urca_1.3-3               evaluate_0.23           
[64] knitr_1.45               lmtest_0.9-40            viridisLite_0.4.2       
[67] rlang_1.1.3              Rcpp_1.0.12              glue_1.7.0              
[70] jsonlite_1.8.8           plyr_1.8.9               R6_2.5.1                </code></pre>
</div>
</div>
<!-- -->

</div></section><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>The choices <span class="math inline">(\alpha, \beta) \in \{(1,2/300),(1, 1/300), (1.5, 1/300), (2, 1/300)\}</span> lead to the stationary population sizes <span class="math inline">N \in \{360, 900, 1800, 2600\}</span>. For each set of parameters, we generated a new initial population, which was used for a benchmark of 50 simulations with both randomized and full algorithm. The simulations run on a Intel Core i7-8550U CPU 1.80GHz × 8 processor, with 15.3 GiB of RAM, under Debian GNU/Linux 11.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section><section class="quarto-appendix-contents" id="quarto-reuse"><h2 class="anchored quarto-appendix-heading">Reuse</h2><div class="quarto-appendix-contents"><div><a rel="license" href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a></div></div></section><section class="quarto-appendix-contents" id="quarto-citation"><h2 class="anchored quarto-appendix-heading">Citation</h2><div><div class="quarto-appendix-secondary-label">BibTeX citation:</div><pre class="sourceCode code-with-copy quarto-appendix-bibtex"><code class="sourceCode bibtex">@article{giorgi2024,
  author = {Giorgi, Daphné and Lemaire, Vincent and Kaakai, Sarah},
  publisher = {Société Française de Statistique},
  title = {Efficient Simulation of Individual-Based Population Models},
  journal = {Computo},
  date = {2024-03-26},
  url = {https://computo.sfds.asso.fr/template-computo-quarto},
  doi = {xxxx},
  issn = {2824-7795},
  langid = {en},
  abstract = {The `R` Package `IBMPopSim` aims to simulate the random
    evolution of heterogeneous populations using stochastic
    Individual-Based Models (IBMs). The package enables users to
    simulate population evolution, in which individuals are
    characterized by their age and some characteristics, and the
    population is modified by different types of events, including
    births/arrivals, death/exit events, or changes of characteristics.
    The frequency at which an event can occur to an individual can
    depend on their age and characteristics, but also on the
    characteristics of other individuals (interactions). Such models
    have a wide range of applications in fields including actuarial
    science, biology, ecology or epidemiology. `IBMPopSim` overcomes the
    limitations of time-consuming IBMs simulations by implementing new
    efficient algorithms based on thinning methods, which are compiled
    using the `Rcpp` package while providing a user-friendly interface.}
}
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre><div class="quarto-appendix-secondary-label">For attribution, please cite this work as:</div><div id="ref-giorgi2024" class="csl-entry quarto-appendix-citeas" role="listitem">
Giorgi, Daphné, Vincent Lemaire, and Sarah Kaakai. 2024.
<span>“Efficient Simulation of Individual-Based Population
Models.”</span> <em>Computo</em>, March. <a href="https://doi.org/xxxx">https://doi.org/xxxx</a>.
</div></div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
          // target, if specified
          link.setAttribute("target", "_blank");
          if (link.getAttribute("rel") === null) {
            link.setAttribute("rel", "noopener");
          }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb37" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> "Efficient simulation of individual-based population models"</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a><span class="an">subtitle:</span><span class="co"> "The `R` package `IBMPopSim`"</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a><span class="an">author:</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a><span class="co">  - name: Daphné Giorgi </span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a><span class="co">    email: daphne.giorgi@sorbonne-universite.fr</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a><span class="co">    url: https://perso.lpsm.paris/~giorgi/</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a><span class="co">    affiliations:</span></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a><span class="co">      - name: Sorbonne Université, CNRS</span></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a><span class="co">        department: Laboratoire de Probabilités, Statistique et Modélisation</span></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a><span class="co">        url: https://www.lpsm.paris/</span></span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a><span class="co">  - name: Vincent Lemaire </span></span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a><span class="co">    corresponding: true</span></span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a><span class="co">    email: vincent.lemaire@sorbonne-universite.fr</span></span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a><span class="co">    url: https://perso.lpsm.paris/~vlemaire/</span></span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true" tabindex="-1"></a><span class="co">    orcid: 0000-0002-0433-7722</span></span>
<span id="cb37-17"><a href="#cb37-17" aria-hidden="true" tabindex="-1"></a><span class="co">    affiliations:</span></span>
<span id="cb37-18"><a href="#cb37-18" aria-hidden="true" tabindex="-1"></a><span class="co">      - name: Sorbonne Université, CNRS</span></span>
<span id="cb37-19"><a href="#cb37-19" aria-hidden="true" tabindex="-1"></a><span class="co">        department: Laboratoire de Probabilités, Statistique et Modélisation</span></span>
<span id="cb37-20"><a href="#cb37-20" aria-hidden="true" tabindex="-1"></a><span class="co">        url: https://www.lpsm.paris/</span></span>
<span id="cb37-21"><a href="#cb37-21" aria-hidden="true" tabindex="-1"></a><span class="co">  - name: Sarah Kaakai</span></span>
<span id="cb37-22"><a href="#cb37-22" aria-hidden="true" tabindex="-1"></a><span class="co">    corresponding: true</span></span>
<span id="cb37-23"><a href="#cb37-23" aria-hidden="true" tabindex="-1"></a><span class="co">    email: sarah.kaakai@univ-lemans.fr</span></span>
<span id="cb37-24"><a href="#cb37-24" aria-hidden="true" tabindex="-1"></a><span class="co">    url: https://perso.univ-lemans.fr/~skaakai/</span></span>
<span id="cb37-25"><a href="#cb37-25" aria-hidden="true" tabindex="-1"></a><span class="co">    affiliations:</span></span>
<span id="cb37-26"><a href="#cb37-26" aria-hidden="true" tabindex="-1"></a><span class="co">      - name: Le Mans Université, CNRS, Institut du Risque et de l'Assurance </span></span>
<span id="cb37-27"><a href="#cb37-27" aria-hidden="true" tabindex="-1"></a><span class="co">        department: Laboratoire Manceau de Mathématiques</span></span>
<span id="cb37-28"><a href="#cb37-28" aria-hidden="true" tabindex="-1"></a><span class="co">        url: https://lmm.univ-lemans.fr/fr/</span></span>
<span id="cb37-29"><a href="#cb37-29" aria-hidden="true" tabindex="-1"></a><span class="an">date:</span><span class="co"> last-modified</span></span>
<span id="cb37-30"><a href="#cb37-30" aria-hidden="true" tabindex="-1"></a><span class="an">date-modified:</span><span class="co"> last-modified</span></span>
<span id="cb37-31"><a href="#cb37-31" aria-hidden="true" tabindex="-1"></a><span class="an">description:</span><span class="co"> |</span></span>
<span id="cb37-32"><a href="#cb37-32" aria-hidden="true" tabindex="-1"></a><span class="co">    TODO</span></span>
<span id="cb37-33"><a href="#cb37-33" aria-hidden="true" tabindex="-1"></a><span class="an">abstract:</span><span class="co"> &gt;+</span></span>
<span id="cb37-34"><a href="#cb37-34" aria-hidden="true" tabindex="-1"></a><span class="co">    The `R` Package `IBMPopSim` aims to simulate the random evolution of heterogeneous populations using stochastic Individual-Based Models (IBMs). The package enables users to simulate population evolution, in which individuals are characterized by their age and some characteristics, and the population is modified by different types of events, including births/arrivals, death/exit events, or changes of characteristics. The frequency at which an event can occur to an individual can depend on their age and characteristics, but also on the characteristics of other individuals (interactions). Such models have a wide range of applications in fields including  actuarial science, biology, ecology or epidemiology. `IBMPopSim` overcomes the limitations of time-consuming IBMs simulations by implementing new efficient algorithms  based on thinning methods, which are compiled using the `Rcpp` package while providing a user-friendly interface.</span></span>
<span id="cb37-35"><a href="#cb37-35" aria-hidden="true" tabindex="-1"></a><span class="an">keywords:</span><span class="co"> [Individual-based models, stochastic simulation, population dynamics, Poisson measures, thinning method, actuarial science, insurance portfolio simulation]</span></span>
<span id="cb37-36"><a href="#cb37-36" aria-hidden="true" tabindex="-1"></a><span class="an">citation:</span></span>
<span id="cb37-37"><a href="#cb37-37" aria-hidden="true" tabindex="-1"></a><span class="co">  type: article-journal</span></span>
<span id="cb37-38"><a href="#cb37-38" aria-hidden="true" tabindex="-1"></a><span class="co">  container-title: "Computo"</span></span>
<span id="cb37-39"><a href="#cb37-39" aria-hidden="true" tabindex="-1"></a><span class="co">  doi: "xxxx"</span></span>
<span id="cb37-40"><a href="#cb37-40" aria-hidden="true" tabindex="-1"></a><span class="co">  url: https://computo.sfds.asso.fr/template-computo-quarto</span></span>
<span id="cb37-41"><a href="#cb37-41" aria-hidden="true" tabindex="-1"></a><span class="co">  publisher: "Société Française de Statistique"</span></span>
<span id="cb37-42"><a href="#cb37-42" aria-hidden="true" tabindex="-1"></a><span class="co">  issn: "2824-7795"</span></span>
<span id="cb37-43"><a href="#cb37-43" aria-hidden="true" tabindex="-1"></a><span class="an">bibliography:</span><span class="co"> references.bib</span></span>
<span id="cb37-44"><a href="#cb37-44" aria-hidden="true" tabindex="-1"></a><span class="an">github-user:</span><span class="co"> VincentLemaire</span></span>
<span id="cb37-45"><a href="#cb37-45" aria-hidden="true" tabindex="-1"></a><span class="an">repo:</span><span class="co"> "ibmpopsim_computo"</span></span>
<span id="cb37-46"><a href="#cb37-46" aria-hidden="true" tabindex="-1"></a><span class="an">draft:</span><span class="co"> true # set to false once the build is running</span></span>
<span id="cb37-47"><a href="#cb37-47" aria-hidden="true" tabindex="-1"></a><span class="an">published:</span><span class="co"> false # will be set to true once accepted</span></span>
<span id="cb37-48"><a href="#cb37-48" aria-hidden="true" tabindex="-1"></a><span class="an">format:</span></span>
<span id="cb37-49"><a href="#cb37-49" aria-hidden="true" tabindex="-1"></a><span class="co">  computo-html: default</span></span>
<span id="cb37-50"><a href="#cb37-50" aria-hidden="true" tabindex="-1"></a><span class="co">  computo-pdf: default</span></span>
<span id="cb37-51"><a href="#cb37-51" aria-hidden="true" tabindex="-1"></a><span class="an">crossref:</span></span>
<span id="cb37-52"><a href="#cb37-52" aria-hidden="true" tabindex="-1"></a><span class="co">    cnj-title: Assumption</span></span>
<span id="cb37-53"><a href="#cb37-53" aria-hidden="true" tabindex="-1"></a><span class="co">    cnj-prefix: Assumption </span></span>
<span id="cb37-54"><a href="#cb37-54" aria-hidden="true" tabindex="-1"></a><span class="an">execute:</span></span>
<span id="cb37-55"><a href="#cb37-55" aria-hidden="true" tabindex="-1"></a><span class="co">    eval: true</span></span>
<span id="cb37-56"><a href="#cb37-56" aria-hidden="true" tabindex="-1"></a><span class="co">    echo: true</span></span>
<span id="cb37-57"><a href="#cb37-57" aria-hidden="true" tabindex="-1"></a><span class="co">    warning: false</span></span>
<span id="cb37-58"><a href="#cb37-58" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb37-59"><a href="#cb37-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-60"><a href="#cb37-60" aria-hidden="true" tabindex="-1"></a><span class="in">```{r echo=FALSE}</span></span>
<span id="cb37-61"><a href="#cb37-61" aria-hidden="true" tabindex="-1"></a><span class="in">library(ggplot2)</span></span>
<span id="cb37-62"><a href="#cb37-62" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb37-63"><a href="#cb37-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-64"><a href="#cb37-64" aria-hidden="true" tabindex="-1"></a><span class="fu"># Introduction</span></span>
<span id="cb37-65"><a href="#cb37-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-66"><a href="#cb37-66" aria-hidden="true" tabindex="-1"></a>In various fields, advances in probability have contributed to the development of a new mathematical framework for so-called individual-based stochastic population dynamics, also called stochastic Individual-Based Models (IBMs).</span>
<span id="cb37-67"><a href="#cb37-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-68"><a href="#cb37-68" aria-hidden="true" tabindex="-1"></a>Stochastic IBMs allow the modeling in continuous time of populations dynamics structured by age and/or characteristics. In the field of mathematical biology and ecology, a large community has used this formalism for the study of the evolution of structured populations (see e.g. <span class="co">[</span><span class="ot">@FerTra09; @collet2013rigorous; @BanMel15; @costa2016stochastic; @billiard2016effect; @lavallee2019stochastic; @meleard2019birth; @calvez2020horizontal</span><span class="co">]</span>), after the pioneer works&nbsp;<span class="co">[</span><span class="ot">@FouMel04;@tran_2008;@meleard2009trait</span><span class="co">]</span>.</span>
<span id="cb37-69"><a href="#cb37-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-70"><a href="#cb37-70" aria-hidden="true" tabindex="-1"></a>IBMs are also useful in demography and actuarial sciences, for the modeling of human populations dynamics (see e.g. <span class="co">[</span><span class="ot">@Ben10; @Bou16; @karoui2021simulating</span><span class="co">]</span>). They allow the modeling of heterogeneous and complex population dynamics, which can be used to compute demographic indicators or simulate the evolution of insurance portfolios in order to study the basis risk, compute cash flows for annuity products or pension schemes, or for a fine assessment of mortality models <span class="co">[</span><span class="ot">@barrieu2012understanding</span><span class="co">]</span>. There are other domains in which stochastic IBMs can be used, for example in epidemiology with stochastic compartmental models, neurosciences, cyber risk, or Agent-Based Models (ABMs) in economy and social sciences, which can be seen as IBMs.</span>
<span id="cb37-71"><a href="#cb37-71" aria-hidden="true" tabindex="-1"></a>Many mathematical results have been obtained in the literature cited above, for quantifying the limit behaviors of IBMs in long time or in large population. In particular, pathwise representations of IBMs have been introduced in <span class="co">[</span><span class="ot">@FouMel04</span><span class="co">]</span> (and extended to age-structured populations in <span class="co">[</span><span class="ot">@tran_2008;@meleard2009trait</span><span class="co">]</span>), as measure-valued pure jumps Markov processes, solutions of SDEs driven by Poisson measures. These pathwise representations are based on the *thinning* and projection of Poisson random measures defined on extended spaces. However, the simulation of large and interacting populations is often referred as computationally expensive.</span>
<span id="cb37-72"><a href="#cb37-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-73"><a href="#cb37-73" aria-hidden="true" tabindex="-1"></a>The aim of the <span class="in">`R`</span> package <span class="in">`IBMPopSim`</span> is to meet the needs of the various communities for efficient tools in order to simulate the evolution of stochastic IBMs. <span class="in">`IBMPopSim`</span> provides a general framework for the simulation of a wide class of IBMs, where individuals are characterized by their age and/or a set of characteristics. Different types of events can be included in the modeling by users, depending on their needs: births, deaths, entry or exit in/to the population and changes of characteristics (swap events). Furthermore, the various events that can happen to individuals in the population can occur at a non-stationary frequency, depending on the individuals' characteristics and time, and also including potential interactions between individuals.</span>
<span id="cb37-74"><a href="#cb37-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-75"><a href="#cb37-75" aria-hidden="true" tabindex="-1"></a>We introduce a unified mathematical and simulation framework for this class of IBMs, generalizing the pathwise representation of IBMs by thinning of Poisson measures, as well as the associated population simulation algorithm, based on an acceptance/rejection procedure. In particular, we provide general sufficient conditions on the event intensities under which the simulation of a particular model is possible.</span>
<span id="cb37-76"><a href="#cb37-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-77"><a href="#cb37-77" aria-hidden="true" tabindex="-1"></a>We opted to implement the algorithms of the <span class="in">`IBMPopSim`</span> package using the <span class="in">`Rcpp`</span> package, a tool facilitating the seamless integration of high-performance <span class="in">`C++`</span> code into easily callable <span class="in">`R`</span> functions <span class="co">[</span><span class="ot">@JSSv040i08</span><span class="co">]</span>. With just a few lines of <span class="in">`C++`</span> code, <span class="in">`IBMPopSim`</span> offers user-friendly R functions for defining IBMs. Once events and their associated intensities are specified, an automated procedure creates the model. This involves integrating the user's source code into the primary <span class="in">`C++`</span> code using a template mechanism. Subsequently, <span class="in">`Rcpp`</span> is invoked to compile the model and integrate it into the <span class="in">`R`</span> session. Following this process, the model becomes callable with varying parameters, enabling the generation of diverse population evolution scenarios. Combined with the design of the simulation algorithms, the package structure yields very competitive simulation runtimes for IBMs, while staying user-friendly for <span class="in">`R`</span> users. Several outputs function are also implemented in <span class="in">`IBMPopSim`</span>. For instance the package allows the construction and visualization of age pyramids, as well as the construction of death and exposures table from the censored individual data, compatible with <span class="in">`R`</span> packages concerned with mortality modelling, such as <span class="co">[</span><span class="ot">@Rdemography</span><span class="co">]</span> or <span class="co">[</span><span class="ot">@Rstmomo</span><span class="co">]</span>. Several examples are provided in the form of <span class="in">`R`</span> vignettes on the <span class="co">[</span><span class="ot">website</span><span class="co">](https://daphnegiorgi.github.io/IBMPopSim/)</span>, and in recent works of <span class="co">[</span><span class="ot">@karoui2021simulating</span><span class="co">]</span> and <span class="co">[</span><span class="ot">@roget2022positive</span><span class="co">]</span>.</span>
<span id="cb37-78"><a href="#cb37-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-79"><a href="#cb37-79" aria-hidden="true" tabindex="-1"></a>Designed for applications in social sciences, the <span class="in">`R`</span> package <span class="in">`MicSim`</span>&nbsp;<span class="co">[</span><span class="ot">@Zin14</span><span class="co">]</span> can be used for continuous time microsimulation. In continuous-time microsimulation, individual life-courses are usually specified by sequences of state transitions (events) and the time spans between these transitions. The state space is usually discrete and finite, which is no necessarily the case in <span class="in">`IBMPopSim`</span>, where individuals can have continuous characteristics. But most importantly, microsimulation does not allow for interactions between individuals. Indeed, microsimulation produces separately the life courses of all individuals in the populations, based on the computation of the distribution functions of the waiting times in the distinct states of the state space, for each individual <span class="co">[</span><span class="ot">@Zin14</span><span class="co">]</span>. This can be slow in comparison to the simulation by thinning of event times occurring in the population, which is based on selecting event times among some competing proposed event times. Finally, <span class="in">`MicSim`</span> simplifies the Mic-Core microsimulation tool implemented in Java <span class="co">[</span><span class="ot">@zinn2009mic</span><span class="co">]</span>. However, the implementation in <span class="in">`R`</span> of simulation algorithms yields longer simulation run times than when using <span class="in">`Rcpp`</span>. To the best of our knowledge, there are no other <span class="in">`R`</span> packages currently available addressing the issue of IBMs efficient simulation.</span>
<span id="cb37-80"><a href="#cb37-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-81"><a href="#cb37-81" aria-hidden="true" tabindex="-1"></a>In @sec-ibm, we introduce the mathematical framework that characterizes the class of Stochastic Individual-Based Models (IBMs) that can be implemented in the <span class="in">`IBMPopSim`</span> package. In particular, a general pathwise representation of IBMs is presented. The population dynamics is obtained as the solution of an SDE driven by Poisson measures, for which we obtain existence and uniqueness results in @thm-eq-Z. Additionally, a succinct overview of the package is provided. </span>
<span id="cb37-82"><a href="#cb37-82" aria-hidden="true" tabindex="-1"></a>In @sec-simulation the two main algorithms for simulating the population evolution of an IBM across the interval $<span class="co">[</span><span class="ot">0, T</span><span class="co">]</span>$ are detailed. </span>
<span id="cb37-83"><a href="#cb37-83" aria-hidden="true" tabindex="-1"></a>In @sec-package we present the main functions of the <span class="in">`IBMPopSim`</span> package, which allow for the definition of events and their intensities, the creation of a model, and the simulation of scenarios. </span>
<span id="cb37-84"><a href="#cb37-84" aria-hidden="true" tabindex="-1"></a>Two examples are detailed in @sec-insurance-portfolio and @sec-example-interaction, featuring applications involving an heterogeneous insurance portfolio characterized by entry and exit events, and an age and size-structured population with intricate interactions.</span>
<span id="cb37-85"><a href="#cb37-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-86"><a href="#cb37-86" aria-hidden="true" tabindex="-1"></a><span class="fu"># Stochastic Individual-Based Models (IBMs) in IBMPopSim {#sec-ibm}</span></span>
<span id="cb37-87"><a href="#cb37-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-88"><a href="#cb37-88" aria-hidden="true" tabindex="-1"></a>Stochastic Individual-Based Models (IBMs) represent a broad class of random population dynamics models, allowing the description of populations evolution on a microscopic scale. Informally, an IBM can be summarized by the description of the individuals constituting the population, the various types of events that can occur to these individuals, along with their respective frequencies. In <span class="in">`IBMPopSim`</span>, individuals can be characterized by their age and/or a collection of discrete or continuous characteristics. Moreover, the package enables users to simulate efficiently populations in which one or more of the following event types may occur:</span>
<span id="cb37-89"><a href="#cb37-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-90"><a href="#cb37-90" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Birth event**: addition of an individual of age 0 to the population.</span>
<span id="cb37-91"><a href="#cb37-91" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Death event**: removal of an individual from the population.</span>
<span id="cb37-92"><a href="#cb37-92" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Entry event**: arrival of an individual in the population.</span>
<span id="cb37-93"><a href="#cb37-93" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Exit (emigration) event**: exit from the population (other than death).</span>
<span id="cb37-94"><a href="#cb37-94" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Swap event**: an individual changes characteristics.</span>
<span id="cb37-95"><a href="#cb37-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-96"><a href="#cb37-96" aria-hidden="true" tabindex="-1"></a>Each event type is linked to an associated event kernel, describing how the population is modified following the occurrence of the event. For some event types, the event kernel requires explicit specification. This is the case for entry events when a new individual joins the population. Then,the model should specify how the age and characteristics of this new individual are chosen. For instance, the characteristics of a new individual in the population can be chosen uniformly in the space of all characteristics, or can depend on the distribution of his parents or those of the other individuals composing the population.</span>
<span id="cb37-97"><a href="#cb37-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-98"><a href="#cb37-98" aria-hidden="true" tabindex="-1"></a>The last component of an IBM are the event intensities. Informally, an event intensity is a function $\lambda^e_t(I, Z)$ describing the frequency at which an event $e$ can occur to an individual $I$ in a population $Z$ at a time $t$. Given a history of the population $(\mathcal{F}_t)$, the probability of event $e$ occurring to individual $I$ during a small interval of time $(t,t+dt]$ is proportional to $\lambda^e(I,t)$:</span>
<span id="cb37-99"><a href="#cb37-99" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-100"><a href="#cb37-100" aria-hidden="true" tabindex="-1"></a>    \mathbb{P}(\text{event } e \text{ occurring to $I$ during } (t,t+dt] | \mathcal{F}_t) \simeq \lambda^e_t(I, Z)dt.</span>
<span id="cb37-101"><a href="#cb37-101" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-102"><a href="#cb37-102" aria-hidden="true" tabindex="-1"></a>The intensity function $\lambda^e$ can include dependency on the individual's $I$ age and characteristics, the time $t$, or the population composition $Z$ in the presence of interactions.</span>
<span id="cb37-103"><a href="#cb37-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-104"><a href="#cb37-104" aria-hidden="true" tabindex="-1"></a><span class="fu">## Brief package overview</span></span>
<span id="cb37-105"><a href="#cb37-105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-106"><a href="#cb37-106" aria-hidden="true" tabindex="-1"></a>Prior to providing a detailed description of an Individual-Based Model (IBM), we present a simple model of birth and death in an age-structured _human_ population. We assume no interactions between individuals, and individuals are characterized by their gender, in addition to their age.</span>
<span id="cb37-107"><a href="#cb37-107" aria-hidden="true" tabindex="-1"></a>In this simple model, all individuals, regardless of gender, can give birth when their age falls between 15 and 40 years, with a constant birth rate of 0.05. The death intensity is assumed to follow a Gompertz-type intensity depending on age. </span>
<span id="cb37-108"><a href="#cb37-108" aria-hidden="true" tabindex="-1"></a>The birth and death intensities are then given by  </span>
<span id="cb37-109"><a href="#cb37-109" aria-hidden="true" tabindex="-1"></a>\begin{equation*}</span>
<span id="cb37-110"><a href="#cb37-110" aria-hidden="true" tabindex="-1"></a>    \lambda^b(t, I) = 0.05 \times \mathbf{1}_{<span class="co">[</span><span class="ot">15,40</span><span class="co">]</span>}(a(I,t)), \quad </span>
<span id="cb37-111"><a href="#cb37-111" aria-hidden="true" tabindex="-1"></a>    \lambda^d(t, I) = \alpha\exp(\beta a(I,t)), </span>
<span id="cb37-112"><a href="#cb37-112" aria-hidden="true" tabindex="-1"></a>\end{equation*} </span>
<span id="cb37-113"><a href="#cb37-113" aria-hidden="true" tabindex="-1"></a>with $a(I,t)$ the age of individual $I$ at time $t$. </span>
<span id="cb37-114"><a href="#cb37-114" aria-hidden="true" tabindex="-1"></a>Birth events are also characterized with a kernel determining the gender of the newborn, who is male with probability $p_{male}$. </span>
<span id="cb37-115"><a href="#cb37-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-116"><a href="#cb37-116" aria-hidden="true" tabindex="-1"></a><span class="fu">### Model creation </span></span>
<span id="cb37-117"><a href="#cb37-117" aria-hidden="true" tabindex="-1"></a>To implement this model in IBMPopSim, it is necessary to individually define each event type. In this example, the <span class="in">`mk_event_individual`</span> function is used. The creation of an event involves  a few lines of <span class="in">`cpp`</span> instructions defining the intensity and, if applicable, the kernel of the event. For a more in depth description of the event creation step and its parameters, we refer to @sec-package-events.</span>
<span id="cb37-118"><a href="#cb37-118" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-119"><a href="#cb37-119" aria-hidden="true" tabindex="-1"></a>The events of this simple model are for example defined through the following calls.</span>
<span id="cb37-122"><a href="#cb37-122" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb37-123"><a href="#cb37-123" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb37-124"><a href="#cb37-124" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-125"><a href="#cb37-125" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(IBMPopSim)</span>
<span id="cb37-126"><a href="#cb37-126" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb37-127"><a href="#cb37-127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-130"><a href="#cb37-130" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb37-131"><a href="#cb37-131" aria-hidden="true" tabindex="-1"></a>birth_event <span class="ot">&lt;-</span> <span class="fu">mk_event_individual</span>(</span>
<span id="cb37-132"><a href="#cb37-132" aria-hidden="true" tabindex="-1"></a>  <span class="at">type =</span> <span class="st">"birth"</span>, </span>
<span id="cb37-133"><a href="#cb37-133" aria-hidden="true" tabindex="-1"></a>  <span class="at">intensity_code =</span> <span class="st">"result = birth_rate(I.age(t));"</span>,</span>
<span id="cb37-134"><a href="#cb37-134" aria-hidden="true" tabindex="-1"></a>  <span class="at">kernel_code =</span> <span class="st">"newI.male = CUnif(0,1) &lt; p_male;"</span>)</span>
<span id="cb37-135"><a href="#cb37-135" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-136"><a href="#cb37-136" aria-hidden="true" tabindex="-1"></a>death_event <span class="ot">&lt;-</span> <span class="fu">mk_event_individual</span>(</span>
<span id="cb37-137"><a href="#cb37-137" aria-hidden="true" tabindex="-1"></a>  <span class="at">type =</span> <span class="st">"death"</span>,</span>
<span id="cb37-138"><a href="#cb37-138" aria-hidden="true" tabindex="-1"></a>  <span class="at">intensity_code =</span> <span class="st">"result = alpha * exp(beta * I.age(t));"</span>)</span>
<span id="cb37-139"><a href="#cb37-139" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb37-140"><a href="#cb37-140" aria-hidden="true" tabindex="-1"></a>In the <span class="in">`cpp`</span> codes, the names <span class="in">`birth_rate`</span>, <span class="in">`p_male`</span>, <span class="in">`alpha`</span> and <span class="in">`beta`</span> refer to the model parameters defined in the following list. </span>
<span id="cb37-143"><a href="#cb37-143" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb37-144"><a href="#cb37-144" aria-hidden="true" tabindex="-1"></a>params <span class="ot">&lt;-</span> <span class="fu">list</span>(</span>
<span id="cb37-145"><a href="#cb37-145" aria-hidden="true" tabindex="-1"></a>  <span class="st">"alpha"</span> <span class="ot">=</span> <span class="fl">0.008</span>, <span class="st">"beta"</span> <span class="ot">=</span> <span class="fl">0.02</span>, </span>
<span id="cb37-146"><a href="#cb37-146" aria-hidden="true" tabindex="-1"></a>  <span class="st">"p_male"</span> <span class="ot">=</span> <span class="fl">0.51</span>,</span>
<span id="cb37-147"><a href="#cb37-147" aria-hidden="true" tabindex="-1"></a>  <span class="st">"birth_rate"</span> <span class="ot">=</span> <span class="fu">stepfun</span>(<span class="fu">c</span>(<span class="dv">15</span>, <span class="dv">40</span>), <span class="fu">c</span>(<span class="dv">0</span>, <span class="fl">0.05</span>, <span class="dv">0</span>)))</span>
<span id="cb37-148"><a href="#cb37-148" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb37-149"><a href="#cb37-149" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-150"><a href="#cb37-150" aria-hidden="true" tabindex="-1"></a>In a second step, the model is created by calling the function <span class="in">`mk_model`</span>. A <span class="in">`cpp`</span> source code is automatically created through a template mechanism based on the events and parameters, subsequently compiled using the <span class="in">`sourceCpp`</span> function from the <span class="in">`Rcpp`</span> package.</span>
<span id="cb37-153"><a href="#cb37-153" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb37-154"><a href="#cb37-154" aria-hidden="true" tabindex="-1"></a>birth_death_model <span class="ot">&lt;-</span> <span class="fu">mk_model</span>(</span>
<span id="cb37-155"><a href="#cb37-155" aria-hidden="true" tabindex="-1"></a>  <span class="at">characteristics =</span> <span class="fu">c</span>(<span class="st">"male"</span> <span class="ot">=</span> <span class="st">"bool"</span>),</span>
<span id="cb37-156"><a href="#cb37-156" aria-hidden="true" tabindex="-1"></a>  <span class="at">events =</span> <span class="fu">list</span>(death_event, birth_event),</span>
<span id="cb37-157"><a href="#cb37-157" aria-hidden="true" tabindex="-1"></a>  <span class="at">parameters =</span> params)</span>
<span id="cb37-158"><a href="#cb37-158" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb37-159"><a href="#cb37-159" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-160"><a href="#cb37-160" aria-hidden="true" tabindex="-1"></a><span class="fu">### Simulation </span></span>
<span id="cb37-161"><a href="#cb37-161" aria-hidden="true" tabindex="-1"></a>Once the model is created and compiled, the <span class="in">`popsim`</span> function is called to simulate the evolution of a population according to this model. To achieve this, an initial population must be defined. In this example, we extract a population from a dataset specified in the package (a sample of $100\,000$ individuals based on the population of England and Wales in 2014). It is also necessary to set bounds for the events intensities. In this example, they are obtained by assuming that the maximum age for an individual is 115 years. </span>
<span id="cb37-164"><a href="#cb37-164" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb37-165"><a href="#cb37-165" aria-hidden="true" tabindex="-1"></a>a_max <span class="ot">&lt;-</span> <span class="dv">115</span></span>
<span id="cb37-166"><a href="#cb37-166" aria-hidden="true" tabindex="-1"></a>events_bounds <span class="ot">=</span> <span class="fu">c</span>(</span>
<span id="cb37-167"><a href="#cb37-167" aria-hidden="true" tabindex="-1"></a>  <span class="st">"death"</span> <span class="ot">=</span> params<span class="sc">$</span>alpha <span class="sc">*</span> <span class="fu">exp</span>(params<span class="sc">$</span>beta <span class="sc">*</span> a_max),</span>
<span id="cb37-168"><a href="#cb37-168" aria-hidden="true" tabindex="-1"></a>  <span class="st">"birth"</span> <span class="ot">=</span> <span class="fu">max</span>(params<span class="sc">$</span>birth_rate))</span>
<span id="cb37-169"><a href="#cb37-169" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb37-170"><a href="#cb37-170" aria-hidden="true" tabindex="-1"></a>The function <span class="in">`popsim`</span> can now be called to simulate the population starting from the initial population <span class="in">`population(EW_pop_14$sample)`</span> up to time $T = 30$. </span>
<span id="cb37-173"><a href="#cb37-173" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb37-174"><a href="#cb37-174" aria-hidden="true" tabindex="-1"></a>sim_out <span class="ot">&lt;-</span> <span class="fu">popsim</span>(</span>
<span id="cb37-175"><a href="#cb37-175" aria-hidden="true" tabindex="-1"></a>  birth_death_model, </span>
<span id="cb37-176"><a href="#cb37-176" aria-hidden="true" tabindex="-1"></a>  <span class="fu">population</span>(EW_pop_14<span class="sc">$</span>sample), </span>
<span id="cb37-177"><a href="#cb37-177" aria-hidden="true" tabindex="-1"></a>  events_bounds, </span>
<span id="cb37-178"><a href="#cb37-178" aria-hidden="true" tabindex="-1"></a>  <span class="at">parameters =</span> params, <span class="at">age_max =</span> a_max, </span>
<span id="cb37-179"><a href="#cb37-179" aria-hidden="true" tabindex="-1"></a>  <span class="at">time =</span> <span class="dv">30</span>)</span>
<span id="cb37-180"><a href="#cb37-180" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb37-181"><a href="#cb37-181" aria-hidden="true" tabindex="-1"></a>The data frame <span class="in">`sim_out$population`</span> contains the information (birth, death, gender) on individuals who lived in the population over the period $<span class="co">[</span><span class="ot">0,30</span><span class="co">]</span>$. Functions of the package allows to provide aggregated information on the population.</span>
<span id="cb37-182"><a href="#cb37-182" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-183"><a href="#cb37-183" aria-hidden="true" tabindex="-1"></a>In the remainder of this section,  we define rigorously the class of IBMs that can be simulated in <span class="in">`IBMPopSim`</span>, along with the assumptions that are required in order for the population to be simulatable. The representation of age-structured IBMs based on measure-valued processes, as introduced in @tran_2008, is generalized to a wider class of abstract population dynamics. The modeling differs slightly here, since individuals are _kept in the population_ after their death (or exit), by including the death/exit date as an individual trait. </span>
<span id="cb37-184"><a href="#cb37-184" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-185"><a href="#cb37-185" aria-hidden="true" tabindex="-1"></a><span class="fu">## Population {#sec-population}</span></span>
<span id="cb37-186"><a href="#cb37-186" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-187"><a href="#cb37-187" aria-hidden="true" tabindex="-1"></a><span class="fu">### Notations</span></span>
<span id="cb37-188"><a href="#cb37-188" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-189"><a href="#cb37-189" aria-hidden="true" tabindex="-1"></a>In the remainder of the paper, the filtered probability space is denoted by $(\Omega,<span class="sc">\{</span>\mathcal{F}_t \},{\mathbb{P}})$, under the usual assumptions. All processes are assumed to be càdlàg and adapted to the filtration $\{\mathcal{F}_t \}$ (for instance the history of the population) on a time interval $[0,T]$. For a càdlàg process $X$, we denote $X_{t^-} := \lim_{\genfrac{}{}{0pt}{2}{s\to t}{s&lt;t}} X_s$.</span>
<span id="cb37-190"><a href="#cb37-190" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-191"><a href="#cb37-191" aria-hidden="true" tabindex="-1"></a><span class="fu">### Individuals</span></span>
<span id="cb37-192"><a href="#cb37-192" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-193"><a href="#cb37-193" aria-hidden="true" tabindex="-1"></a>An individual is represented by a triplet $I = (\tau^b, \tau^d, x) \in \mathcal{I}= {\mathbb{R}}\times \bar {\mathbb{R}}\times {\mathcal{X}}$ with:</span>
<span id="cb37-194"><a href="#cb37-194" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-195"><a href="#cb37-195" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$\tau^b \in {\mathbb{R}}$ the date of birth,</span>
<span id="cb37-196"><a href="#cb37-196" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$\tau^d \in \bar {\mathbb{R}}$ the death date, with $\tau^d = \infty$ if the individual is still alive,</span>
<span id="cb37-197"><a href="#cb37-197" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>a collection $x \in {\mathcal{X}}$ of characteristics where ${\mathcal{X}}$ is the space of characteristics.</span>
<span id="cb37-198"><a href="#cb37-198" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-199"><a href="#cb37-199" aria-hidden="true" tabindex="-1"></a>Note that in IBMs, individuals are usually characterized by their age $a(t) =t-\tau^b$ instead of their date of birth $\tau^b$. However, using the latter is actually easier for the simulation, as it remains constant over time.</span>
<span id="cb37-200"><a href="#cb37-200" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-201"><a href="#cb37-201" aria-hidden="true" tabindex="-1"></a><span class="fu">### Population process</span></span>
<span id="cb37-202"><a href="#cb37-202" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-203"><a href="#cb37-203" aria-hidden="true" tabindex="-1"></a>The population at a given time $t$ is a random set</span>
<span id="cb37-204"><a href="#cb37-204" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-205"><a href="#cb37-205" aria-hidden="true" tabindex="-1"></a>    Z_t=<span class="sc">\{</span> I_k \in \mathcal{I}; \; k= 1,\dots, N_t<span class="sc">\}</span>,</span>
<span id="cb37-206"><a href="#cb37-206" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-207"><a href="#cb37-207" aria-hidden="true" tabindex="-1"></a>composed of all individuals (alive or dead) who have lived in the population before time $t$. As a random set, $Z_t$ can be represented by a random counting measure on $\mathcal{I}$ , that is an integer-valued measure $Z: \Omega \times \mathcal{I}\to \bar {\mathbb{N}}$ where for $A \in \mathcal{I}$, $Z(A)$ is the (random) number of individuals $I$ in the subset $A$. With this representation: </span>
<span id="cb37-208"><a href="#cb37-208" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-209"><a href="#cb37-209" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb37-210"><a href="#cb37-210" aria-hidden="true" tabindex="-1"></a>    Z_t (\mathrm{d}\tau^b, \mathrm{d}\tau^d , \mathrm{d}x) &amp;= \sum_{k=1}^{N_t} \delta_{I_k} (\tau^b, \tau^d,x), \nonumber <span class="sc">\\</span></span>
<span id="cb37-211"><a href="#cb37-211" aria-hidden="true" tabindex="-1"></a>    \text{ with }  \int_{\mathcal{I}} f(\tau^b, \tau^d, x) Z_t (\mathrm{d}\tau^b, \mathrm{d}\tau^d , \mathrm{d}x) &amp;= \sum_{k=1}^{N_t} f(I_k).</span>
<span id="cb37-212"><a href="#cb37-212" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb37-213"><a href="#cb37-213" aria-hidden="true" tabindex="-1"></a>$$ {#eq-popZ}</span>
<span id="cb37-214"><a href="#cb37-214" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-215"><a href="#cb37-215" aria-hidden="true" tabindex="-1"></a>The number of individuals present in the population *before time* $t$ is obtained by taking $f\equiv 1$:</span>
<span id="cb37-216"><a href="#cb37-216" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-217"><a href="#cb37-217" aria-hidden="true" tabindex="-1"></a>    N_t =  \int_{\mathcal{I}}  Z_t(\mathrm{d}\tau^b, \mathrm{d}\tau^d, \mathrm{d}x) = \sum_{k=1}^{N_t} \boldsymbol{1}_{\mathcal{I}} (I_k).</span>
<span id="cb37-218"><a href="#cb37-218" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-219"><a href="#cb37-219" aria-hidden="true" tabindex="-1"></a>Note that $(N_t)_{t\geq 0}$ is an increasing process since dead/exited individuals are kept in the population $Z$. The number of alive individuals in the population at time $t$ is: </span>
<span id="cb37-220"><a href="#cb37-220" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-221"><a href="#cb37-221" aria-hidden="true" tabindex="-1"></a>    N_t^a =  \int_{\mathcal{I}}  \mathsf{1}_{\{\tau^d &gt; t \} }Z_t(\mathrm{d}\tau^b, \mathrm{d}\tau^d, \mathrm{d}x) = \sum_{k=1}^{N_t} \mathsf{1}_{<span class="sc">\{</span>\tau^d_k &gt; t <span class="sc">\}</span> }.</span>
<span id="cb37-222"><a href="#cb37-222" aria-hidden="true" tabindex="-1"></a>$$ {#eq-Nta}</span>
<span id="cb37-223"><a href="#cb37-223" aria-hidden="true" tabindex="-1"></a>Another example is the number of alive individuals of age over $a$ is</span>
<span id="cb37-224"><a href="#cb37-224" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-225"><a href="#cb37-225" aria-hidden="true" tabindex="-1"></a>    N_t(<span class="co">[</span><span class="ot">a,+\infty)) :=  \int_{\mathcal{I}}  \boldsymbol{1}_{[a,+\infty)}(t-\tau^b)\mathsf{1}_{]t,\infty</span><span class="co">]</span>}(\tau^d) Z_t(\mathrm{d}\tau^b, \mathrm{d}\tau^d, \mathrm{d}x) = \sum_{k=1}^{N_t}  \boldsymbol{1}_{\{ t -\tau_k^b \geq a \}}\mathsf{1}_{<span class="sc">\{</span>\tau^d_k \geq t <span class="sc">\}</span> }.</span>
<span id="cb37-226"><a href="#cb37-226" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-227"><a href="#cb37-227" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-228"><a href="#cb37-228" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-229"><a href="#cb37-229" aria-hidden="true" tabindex="-1"></a><span class="fu">## Events {#sec-events}</span></span>
<span id="cb37-230"><a href="#cb37-230" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-231"><a href="#cb37-231" aria-hidden="true" tabindex="-1"></a>The population composition changes at random dates following different types of events. <span class="in">`IBMPopSim`</span> allows the simulation of IBMs with the following events types:</span>
<span id="cb37-232"><a href="#cb37-232" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-233"><a href="#cb37-233" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>A **birth** event at time $t$ is the addition of a new individual $I'=(t,\infty, X)$ of age $0$ to the population. Their date of birth is $\tau^b =t$, and characteristics is $X$, a random variable of distribution defined by the birth kernel $k^b(t,I,\mathrm{d}x)$ on ${\mathcal{X}}$, depending on $t$ and its parent $I$. The population size becomes $N_t = N_{t^-} + 1$, and the population composition after the event is $$Z_t  = Z_{t^-} +  \delta_{(t,\infty, X)}.$$</span>
<span id="cb37-234"><a href="#cb37-234" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-235"><a href="#cb37-235" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>An **entry** event at time $t$ is also the addition of an individual $I'$ in the population. However, this individual is not of age $0$. The date of birth and characteristics of the new individual $I'= (\tau^b, \infty, X)$ are random variables of probability distribution defined by the entry kernel $k^{en}(t, \mathrm{d}s, \mathrm{d}x)$ on ${\mathbb{R}}\times {\mathcal{X}}$. The population size becomes $N_t = N_{t^-} + 1$, and the population composition after the event is: </span>
<span id="cb37-236"><a href="#cb37-236" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-237"><a href="#cb37-237" aria-hidden="true" tabindex="-1"></a>    Z_t  = Z_{t^-} +  \delta_{(\tau^b, \infty, X)}.</span>
<span id="cb37-238"><a href="#cb37-238" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-239"><a href="#cb37-239" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-240"><a href="#cb37-240" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>A **death** or **exit** event of an individual $I= (\tau^b,\infty, x)\in Z_{t^-}$ at time $t$ is the modification of its death date $\tau^d$ from $+\infty$ to $t$. This event results in the simultaneous addition of the individual $(\tau^b,t,x)$ and removal of the individual $I$ from the population. The population size is not modified, and the population composition after the event is </span>
<span id="cb37-241"><a href="#cb37-241" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-242"><a href="#cb37-242" aria-hidden="true" tabindex="-1"></a>    Z_t  = Z_{t^-} +\delta_{(\tau^b,t,x)}- \delta_{I}.</span>
<span id="cb37-243"><a href="#cb37-243" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-244"><a href="#cb37-244" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-245"><a href="#cb37-245" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>A **swap** event (change of characteristics) results in the simultaneous addition and removal of an individual. If an individual $I= (\tau^b,\infty, x) \in Z_{t^-}$ changes of characteristics at time $t$, then it is removed from the population and replaced by $I' = (\tau^b,\infty, X)$. The new characteristics $X$ is a random variable of distribution $k^s(t, I,\mathrm{d}x)$ on ${\mathcal{X}}$, depending on time, the individual's age and previous characteristics $x$. In this case, the population size is not modified and the population becomes:</span>
<span id="cb37-246"><a href="#cb37-246" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-247"><a href="#cb37-247" aria-hidden="true" tabindex="-1"></a>    Z_t  = Z_{t^-}   +  \delta_{(\tau^b,  \infty, X)} -  \delta_{(\tau^b, \infty, x)}.</span>
<span id="cb37-248"><a href="#cb37-248" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-249"><a href="#cb37-249" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-250"><a href="#cb37-250" aria-hidden="true" tabindex="-1"></a>To summarize, the space of event types is $E = <span class="sc">\{</span> b, en, d, s <span class="sc">\}</span>$, and the jump $\Delta Z_t = Z_t - Z_{t^-}$ (change in the population composition) generated by an event of type $e \in <span class="sc">\{</span> b, en, d, s <span class="sc">\}</span>$ is denoted by $\phi^e(t, I)$. We thus have the following rules summarized in the table @tbl-event-action.</span>
<span id="cb37-251"><a href="#cb37-251" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-252"><a href="#cb37-252" aria-hidden="true" tabindex="-1"></a>Event | Type | $\phi^e(t, I)$ | New individual</span>
<span id="cb37-253"><a href="#cb37-253" aria-hidden="true" tabindex="-1"></a>------|:----:|----------------|---------------</span>
<span id="cb37-254"><a href="#cb37-254" aria-hidden="true" tabindex="-1"></a>Birth | $b$ | $\delta_{(t, \infty,  X)}$ | $\tau^b =t, \; X \sim k^b(t,I,\mathrm{d}x)$ </span>
<span id="cb37-255"><a href="#cb37-255" aria-hidden="true" tabindex="-1"></a>Entry | $en$ | $\delta_{(\tau^b, \infty,  X)}$ | $(\tau^b, X) \sim k^{en}(t,\mathrm{d}s, \mathrm{d}x)$ </span>
<span id="cb37-256"><a href="#cb37-256" aria-hidden="true" tabindex="-1"></a>Death/Exit | $d$ | $\delta_{(\tau^b, t,x)} - \delta_{(\tau^b, \infty, x)}$ | $\tau^d = t$</span>
<span id="cb37-257"><a href="#cb37-257" aria-hidden="true" tabindex="-1"></a>Swap | $s$ | $\delta_{(\tau^b, \infty , X)} - \delta_{(\tau^b, \infty, x)}$ | $X \sim k^s(t,I,\mathrm{d}x)$</span>
<span id="cb37-258"><a href="#cb37-258" aria-hidden="true" tabindex="-1"></a>: Action in the population for a given event name {#tbl-event-action}</span>
<span id="cb37-259"><a href="#cb37-259" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-260"><a href="#cb37-260" aria-hidden="true" tabindex="-1"></a>::: {#rem-popfinale}</span>
<span id="cb37-261"><a href="#cb37-261" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-262"><a href="#cb37-262" aria-hidden="true" tabindex="-1"></a><span class="fu">## Composition of the population </span></span>
<span id="cb37-263"><a href="#cb37-263" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-264"><a href="#cb37-264" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>At time $T$, the population $Z_T$ contains all individuals who lived in the population before $T$, including dead/exited individuals. If there are no swap events, or entries,the population state $Z_t$ for any time $t\leq T$ can be obtained from $Z_T$. Indeed, if $Z_T = \sum_{k=1}^{N_T}  \delta_{I_k}$, then the population at time $t\leq T$ is simply composed of the individuals born before $t$: $$</span>
<span id="cb37-265"><a href="#cb37-265" aria-hidden="true" tabindex="-1"></a>    Z_t = \sum_{k=1}^{N_T} \boldsymbol{1}_{\{\tau^b_k \leq t \}} \delta_{I_k}.</span>
<span id="cb37-266"><a href="#cb37-266" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-267"><a href="#cb37-267" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>In the presence of entries (open population), a characteristic $x$ can track the individuals' entry dates. Then, the previous equation can be easily modified in order to obtain the population $Z_t$ at time $t\leq T$ from $Z_T$.</span>
<span id="cb37-268"><a href="#cb37-268" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-269"><a href="#cb37-269" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb37-270"><a href="#cb37-270" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-271"><a href="#cb37-271" aria-hidden="true" tabindex="-1"></a><span class="fu">## Events intensity {#sec-event-intensity}</span></span>
<span id="cb37-272"><a href="#cb37-272" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-273"><a href="#cb37-273" aria-hidden="true" tabindex="-1"></a>Once the different event types have been defined in the population model, the frequency at which each event occur in the population $e$ have to be specified.</span>
<span id="cb37-274"><a href="#cb37-274" aria-hidden="true" tabindex="-1"></a>Informally, the intensity $\Lambda^e_t(Z_t)$ at which an event $e$ can occur is defined by</span>
<span id="cb37-275"><a href="#cb37-275" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-276"><a href="#cb37-276" aria-hidden="true" tabindex="-1"></a>    \mathbb P\big( \text{event } e \text { occurs in the population }  Z_t  \in (t,t+\mathrm{d}t] | \mathcal{F}_t \big) \simeq  \Lambda^e_t (Z_t)\mathrm{d}t.</span>
<span id="cb37-277"><a href="#cb37-277" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-278"><a href="#cb37-278" aria-hidden="true" tabindex="-1"></a>For a more formal definition of stochastic intensities, we refer to <span class="co">[</span><span class="ot">@bremaud1981point</span><span class="co">]</span> or <span class="co">[</span><span class="ot">@KaaElK20</span><span class="co">]</span>. The form of the intensity function $(\Lambda^e_t (Z_t))$ determines the population simulation algorithm in <span class="in">`IBMPopSim`</span>:</span>
<span id="cb37-279"><a href="#cb37-279" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-280"><a href="#cb37-280" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>When the event intensity does not depend on the population state, </span>
<span id="cb37-281"><a href="#cb37-281" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-282"><a href="#cb37-282" aria-hidden="true" tabindex="-1"></a>    \big(\Lambda^e_t (Z_t)\big)_{t\in [0,T]} = \big(\mu^e(t)\big)_{t \in <span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>},</span>
<span id="cb37-283"><a href="#cb37-283" aria-hidden="true" tabindex="-1"></a>$$ {#eq-poisson-intensity}</span>
<span id="cb37-284"><a href="#cb37-284" aria-hidden="true" tabindex="-1"></a>with $\mu^e$ a deterministic function, the events of type $e$ occur at the jump times of an inhomogeneous Poisson process of intensity function $(\mu^e(t))_{t \in <span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>}$. When such an event occurs, the individual to whom the event happens to is drawn uniformly among alive individuals in the population.</span>
<span id="cb37-285"><a href="#cb37-285" aria-hidden="true" tabindex="-1"></a>In a given model, the set of events $e\in E$ with Poisson intensities will be denoted by $\mathcal{P}$.</span>
<span id="cb37-286"><a href="#cb37-286" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Otherwise, we assume that the global intensity $\Lambda^e_t(Z_t)$ at which the events of type $e$ occur in the population can be written as the sum of individual intensities $\lambda^e_t(I,Z_t)$:</span>
<span id="cb37-287"><a href="#cb37-287" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-288"><a href="#cb37-288" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb37-289"><a href="#cb37-289" aria-hidden="true" tabindex="-1"></a>    &amp;\Lambda^e_t (Z_t) = \sum_{k=1}^{N_t} \lambda^e_t ( I_k,Z_t),  <span class="sc">\\</span></span>
<span id="cb37-290"><a href="#cb37-290" aria-hidden="true" tabindex="-1"></a>    &amp; \nonumber \text{with } \mathbb P\big( \text{event } e \text { occurs to an individual } I \in (t,t+\mathrm{d}t] | \mathcal{F}_t \big) \simeq  \lambda^e_t (I,Z_t)\mathrm{d}t.</span>
<span id="cb37-291"><a href="#cb37-291" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb37-292"><a href="#cb37-292" aria-hidden="true" tabindex="-1"></a>$$ {#eq-global-intensity}</span>
<span id="cb37-293"><a href="#cb37-293" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-294"><a href="#cb37-294" aria-hidden="true" tabindex="-1"></a>Obviously, nothing can happen to dead or exited individuals, i.e. individuals $I= (\tau^b, \tau^d, x)$ with $\tau^d \leq t$. Thus, individual event intensities are assumed to be null for dead/exited individuals:</span>
<span id="cb37-295"><a href="#cb37-295" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-296"><a href="#cb37-296" aria-hidden="true" tabindex="-1"></a>    \lambda^e_t ( I,Z_t) = 0, \text{ if }\tau^d \leq t, \text{ so that } \Lambda^e_t (Z_t) = \sum_{k=1}^{N_t^a} \lambda^e_t ( I_k,Z_t),</span>
<span id="cb37-297"><a href="#cb37-297" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-298"><a href="#cb37-298" aria-hidden="true" tabindex="-1"></a>with $N^a_t$ the number of alive individuals at time $t$.</span>
<span id="cb37-299"><a href="#cb37-299" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-300"><a href="#cb37-300" aria-hidden="true" tabindex="-1"></a>The event's individual intensity $\lambda^e_t (I,Z_t)$ can depend on time (for instance when there is a mortality reduction over time), on the individual's age $t-\tau^b$ and characteristics, but also on the population composition $Z_t$. The dependence of $\lambda^e$ on the population $Z$ models interactions between individuals in the populations. Hence, two types of individual intensity functions can be implemented in <span class="in">`IBMPopSim`</span>:</span>
<span id="cb37-301"><a href="#cb37-301" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-302"><a href="#cb37-302" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>*No interactions:* The intensity function $\lambda^e$ does not depend on the population composition. The intensity at which the event of type $e$ occur to an individual $I$ only depends on its date of birth and characteristics: </span>
<span id="cb37-303"><a href="#cb37-303" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-304"><a href="#cb37-304" aria-hidden="true" tabindex="-1"></a>    \lambda^e_t (I,Z_t) = \lambda^e(t, I),</span>
<span id="cb37-305"><a href="#cb37-305" aria-hidden="true" tabindex="-1"></a>$$ {#eq-intensity-no-interaction}</span>
<span id="cb37-306"><a href="#cb37-306" aria-hidden="true" tabindex="-1"></a>where $\lambda^e: \mathbb{R}_+ \times \mathcal{I}\to {\mathbb{R}}^+$ is a deterministic function. In a given model, we denote by $\mathcal{E}$ the set of event types with individual intensity @eq-intensity-no-interaction.</span>
<span id="cb37-307"><a href="#cb37-307" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-308"><a href="#cb37-308" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>*"Quadratic" interactions:* The intensity at which an event of type $e$ occurs to an individual $I$ depends on $I$ and on the population composition, through an interaction function $W^e$. The quantity $W^e(t, I,J)$ describes the intensity of interactions between two alive individuals $I$ and $J$ at time $t$, for instance in the presence of competition or cooperation. In this case, we have</span>
<span id="cb37-309"><a href="#cb37-309" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-310"><a href="#cb37-310" aria-hidden="true" tabindex="-1"></a>    \lambda^e_t(I,Z_t)=\sum_{j=1}^{N_t} W^e(t, I, I_j) = \int_{\mathcal{I}} W^e(t, I, (\tau^b,\tau^d,x)) Z_t (\mathrm{d}\tau^b,\mathrm{d}\tau^d, \mathrm{d}x),</span>
<span id="cb37-311"><a href="#cb37-311" aria-hidden="true" tabindex="-1"></a>$$ {#eq-intensity-interaction}</span>
<span id="cb37-312"><a href="#cb37-312" aria-hidden="true" tabindex="-1"></a>where $W^e(t, I, (\tau^b,\tau^d,x))  = 0$ if the individual $J =(\tau^b,\tau^d,x)$ is dead, i.e. $\tau^d \leq t$.\ In a given model, we denote by $\mathcal{E}_W$ the set of event types with individual intensity @eq-intensity-interaction.</span>
<span id="cb37-313"><a href="#cb37-313" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-314"><a href="#cb37-314" aria-hidden="true" tabindex="-1"></a>To summarize, an individual intensity in IBMPopSim can be written as:</span>
<span id="cb37-315"><a href="#cb37-315" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-316"><a href="#cb37-316" aria-hidden="true" tabindex="-1"></a>    \lambda^e_t(I,Z_t) = \lambda^e(t, I) \mathbf{1}_{\{e \in \mathcal{E}\}} + \biggl( \sum_{j=1}^{N_t} W^e(t, I, I_j) \biggr) \mathbf{1}_{<span class="sc">\{</span>e \in \mathcal{E}_W<span class="sc">\}</span>}.</span>
<span id="cb37-317"><a href="#cb37-317" aria-hidden="true" tabindex="-1"></a>$$ {#eq-individual-intensity}</span>
<span id="cb37-318"><a href="#cb37-318" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-319"><a href="#cb37-319" aria-hidden="true" tabindex="-1"></a>::: {#exm-popfinale}</span>
<span id="cb37-320"><a href="#cb37-320" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-321"><a href="#cb37-321" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>An example of death intensity without interaction for an individual $I=(\tau^b, \tau^d, x)$ alive at time $t$, $t &lt; \tau^d$, is:</span>
<span id="cb37-322"><a href="#cb37-322" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-323"><a href="#cb37-323" aria-hidden="true" tabindex="-1"></a>    \lambda^d(t,I) =  \alpha_x \exp(\beta_x a(I,t)), \text{ where }  a(I,t) = t-\tau^b</span>
<span id="cb37-324"><a href="#cb37-324" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-325"><a href="#cb37-325" aria-hidden="true" tabindex="-1"></a>is the age of the individual $I$ at time $t$. In this classical case, the death rate of an individual $I$ is an exponential (Gompertz) function of the individual's age, with coefficients depending on the individual's characteristics $x$.</span>
<span id="cb37-326"><a href="#cb37-326" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-327"><a href="#cb37-327" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>In the presence of competition between individuals, the death intensity of an individual $I$ also depend on other individuals $J$ in the population. For example, if $I=(\tau^b,\tau^d, x)$, with $x$ its size, then we can have: </span>
<span id="cb37-328"><a href="#cb37-328" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-329"><a href="#cb37-329" aria-hidden="true" tabindex="-1"></a>    W^d(t,I,J) = (x_J - x)^+ \mathbf{1}_{<span class="sc">\{</span>\tau^d_J &gt; t<span class="sc">\}</span>}, \quad \forall \; J=(\tau^b_J,\tau^d_J , x_J).</span>
<span id="cb37-330"><a href="#cb37-330" aria-hidden="true" tabindex="-1"></a>$$ {#eq-ex-interaction}</span>
<span id="cb37-331"><a href="#cb37-331" aria-hidden="true" tabindex="-1"></a>This can be interpreted as follows: if the individual $I$ meets randomly an individual $J$ alive at time $t$, and of bigger size $x_J &gt; x$, then he can die at the intensity $x_J-x$. If $J$ is smaller than $I$, then he cannot kill $I$. The bigger is the size $x$ of $I$, the lower is his death intensity $\lambda^d_t(I,Z_t)$ defined by </span>
<span id="cb37-332"><a href="#cb37-332" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-333"><a href="#cb37-333" aria-hidden="true" tabindex="-1"></a>    \lambda^d_t(I,Z_t) = \sum_{\genfrac{}{}{0pt}{2}{J\in Z_t,}{x_J &gt; x}} (x_J -x)\mathbf{1}_{<span class="sc">\{</span>\tau^d_J &gt; t<span class="sc">\}</span>}.</span>
<span id="cb37-334"><a href="#cb37-334" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-335"><a href="#cb37-335" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-336"><a href="#cb37-336" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span><span class="in">`IBMPopSim`</span> can simulate IBMs that include intensities expressed as a sum of Poisson intensities and individual intensities of the form $\Lambda^e(Z_t) =\mu^e_t + \sum_{k=1}^{N_t} \lambda^e(I_k, Z_t)$. Other examples are provided in @sec-insurance-portfolio and @sec-example-interaction.</span>
<span id="cb37-337"><a href="#cb37-337" aria-hidden="true" tabindex="-1"></a>Finally, the global intensity at which an event can occur in the population is defined by: </span>
<span id="cb37-338"><a href="#cb37-338" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-339"><a href="#cb37-339" aria-hidden="true" tabindex="-1"></a>    \Lambda_t(Z_t) = \sum_{e\in \mathcal{P}} \mu^e(t) + \sum_{e \in \mathcal E} \Big(\sum_{k=1}^{N_t} \lambda^e(t, I_k)\Big) + \sum_{e \in \mathcal E_W} \Big(\sum_{k=1}^{N_t}\sum_{j=1}^{N_t} W^e(t, I_k, I_j)\Big).</span>
<span id="cb37-340"><a href="#cb37-340" aria-hidden="true" tabindex="-1"></a>$$ {#eq-global-ev-intensity}</span>
<span id="cb37-341"><a href="#cb37-341" aria-hidden="true" tabindex="-1"></a>An important point is that for events $e \in \mathcal E$ without interactions, the global event intensity $\Lambda^e_t(Z_t) = \sum_{k=1}^{N_t} \lambda^e(t, I_k)$ is _of order_ $N_t^a$ defined in @eq-Nta (number of alive individuals at time $t$). On the other hand, for events $e \in \mathcal{E}_W$ with interactions, $\Lambda^e_t(Z_t) = \sum_{k=1}^{N_t}\sum_{j=1}^{N_t} W^e(t, I_k, I_j)$ is of order $(N_t^a)^2$. </span>
<span id="cb37-342"><a href="#cb37-342" aria-hidden="true" tabindex="-1"></a>Informally, this means that when the population size increases, events with interaction are more costly to simulate. Furthermore, the numerous computations of the interaction kernel $W^e$ can also be quite costly. The randomized Algorithm @alg-randomized, detailed in Section <span class="co">[</span><span class="ot">2.3</span><span class="co">](#sec::simulation_algo_randomized)</span>{reference-type="ref" reference="sec::simulation_algo_randomized"}, allows us to overcome these limitations.</span>
<span id="cb37-343"><a href="#cb37-343" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-344"><a href="#cb37-344" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb37-345"><a href="#cb37-345" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-346"><a href="#cb37-346" aria-hidden="true" tabindex="-1"></a><span class="fu">### Events intensity bounds</span></span>
<span id="cb37-347"><a href="#cb37-347" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-348"><a href="#cb37-348" aria-hidden="true" tabindex="-1"></a>The simulation algorithms implemented in <span class="in">`IBMPopSim`</span> are based on an acceptance/rejection procedure, which requires to specify bounds for the various events intensities $\Lambda^e_t(Z_t)$. These bounds are defined differently depending on the expression of the intensity.</span>
<span id="cb37-349"><a href="#cb37-349" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-350"><a href="#cb37-350" aria-hidden="true" tabindex="-1"></a>::: {#cnj-intensity-poisson} </span>
<span id="cb37-351"><a href="#cb37-351" aria-hidden="true" tabindex="-1"></a>For all events $e \in \mathcal{P}$ with Poisson intensity @eq-poisson-intensity, the intensity is assumed to be bounded on $<span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>$:</span>
<span id="cb37-352"><a href="#cb37-352" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-353"><a href="#cb37-353" aria-hidden="true" tabindex="-1"></a>    \forall t \in <span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>, \quad \Lambda^e_t(Z_t) = \mu^e(t) \leq \bar \mu^e.</span>
<span id="cb37-354"><a href="#cb37-354" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-355"><a href="#cb37-355" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb37-356"><a href="#cb37-356" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-357"><a href="#cb37-357" aria-hidden="true" tabindex="-1"></a>When $e \in \mathcal{E} \cup \mathcal{E}_W$, $\Lambda^e_t(Z_t) =\sum_{k=1}^{N_t} \lambda^e_t(I_k,Z_t)$, assuming that $\Lambda^e_t(Z_t)$ is uniformly bounded is too restrictive since the event intensity depends on the population size. In this case, the assumption is made on the individual intensity $\lambda^e$ or on the interaction function $W^e$, depending on the situation.</span>
<span id="cb37-358"><a href="#cb37-358" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-359"><a href="#cb37-359" aria-hidden="true" tabindex="-1"></a>::: {#cnj-intensity1}</span>
<span id="cb37-360"><a href="#cb37-360" aria-hidden="true" tabindex="-1"></a>For all event types $e \in \mathcal{E}$, the associated individual event intensity $\lambda^e$ with no interactions, _i.e._ $\lambda^e$ verifies @eq-intensity-no-interaction, is assumed to be uniformly bounded:</span>
<span id="cb37-361"><a href="#cb37-361" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-362"><a href="#cb37-362" aria-hidden="true" tabindex="-1"></a>    \lambda^e(t, I) \leq \bar \lambda^e, \quad \forall \;  t\in <span class="co">[</span><span class="ot">0, T</span><span class="co">]</span>,  \;   I \in \mathcal{I}.</span>
<span id="cb37-363"><a href="#cb37-363" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-364"><a href="#cb37-364" aria-hidden="true" tabindex="-1"></a>In particular, </span>
<span id="cb37-365"><a href="#cb37-365" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-366"><a href="#cb37-366" aria-hidden="true" tabindex="-1"></a>    \forall t \in <span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>, \quad \Lambda^e_t (Z_t) = \sum_{k=1}^{N_t} \lambda^e(t, I) \leq \bar \lambda^e  N_t .</span>
<span id="cb37-367"><a href="#cb37-367" aria-hidden="true" tabindex="-1"></a>$$ {#eq-def-bar-Lambda}</span>
<span id="cb37-368"><a href="#cb37-368" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb37-369"><a href="#cb37-369" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-370"><a href="#cb37-370" aria-hidden="true" tabindex="-1"></a>::: {#cnj-intensity2}</span>
<span id="cb37-371"><a href="#cb37-371" aria-hidden="true" tabindex="-1"></a>For all event types $e \in \mathcal{E}_W$, the associated interaction function $W^e$ is assumed to be uniformly bounded:</span>
<span id="cb37-372"><a href="#cb37-372" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-373"><a href="#cb37-373" aria-hidden="true" tabindex="-1"></a>    W^e(t, I, J) \leq \bar W^e, \quad \forall \; t\in <span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>, \;   I, J \in \mathcal{I}.</span>
<span id="cb37-374"><a href="#cb37-374" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-375"><a href="#cb37-375" aria-hidden="true" tabindex="-1"></a>In particular, $\forall t \in <span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>$,</span>
<span id="cb37-376"><a href="#cb37-376" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-377"><a href="#cb37-377" aria-hidden="true" tabindex="-1"></a>    \lambda^e_t (I,Z_t) = \sum_{j=1}^{N_t} W^e(t, I, I_j)  \leq  \bar W^e N_t, \quad \text{and} \quad \Lambda^e_t (Z_t) \leq \bar W^e (N_t)^2.</span>
<span id="cb37-378"><a href="#cb37-378" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-379"><a href="#cb37-379" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb37-380"><a href="#cb37-380" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-381"><a href="#cb37-381" aria-hidden="true" tabindex="-1"></a>@cnj-intensity-poisson, @cnj-intensity1 and @cnj-intensity2 yield that events in the population occur with the global event intensity&nbsp;$\Lambda_t(Z_t)$, given in @eq-global-ev-intensity, which is dominated by a polynomial function in the population size: </span>
<span id="cb37-382"><a href="#cb37-382" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-383"><a href="#cb37-383" aria-hidden="true" tabindex="-1"></a>    \Lambda_t(Z_t) \leq \bar \Lambda(N_t), \quad \text{with }  \bar \Lambda (n) = \sum_{e \in \mathcal{P}} \bar \mu^e + \sum_{e\in \mathcal{E}}\bar \lambda^e  n + \sum_{e \in \mathcal E_W} \bar W^e n^2.</span>
<span id="cb37-384"><a href="#cb37-384" aria-hidden="true" tabindex="-1"></a>$$ {#eq-def-bar-Lambda}</span>
<span id="cb37-385"><a href="#cb37-385" aria-hidden="true" tabindex="-1"></a>This bound is linear in the population size if there are no interactions, and quadratic if there at least is an event including interactions. This assumption is the key to the algorithms implemented in <span class="in">`IBMPopSim`</span>. Before presenting the simulation algorithm, we close this section with a rigorous definition of an IBM, based on the pathwise representation of its dynamics a Stochastic Differential Equation (SDE) driven by Poisson random measures.</span>
<span id="cb37-386"><a href="#cb37-386" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-387"><a href="#cb37-387" aria-hidden="true" tabindex="-1"></a><span class="fu">## Pathwise representation</span></span>
<span id="cb37-388"><a href="#cb37-388" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-389"><a href="#cb37-389" aria-hidden="true" tabindex="-1"></a>Since the seminal paper of <span class="co">[</span><span class="ot">@FouMel04</span><span class="co">]</span>, it has been shown in many examples that a stochastic IBM dynamics can be defined rigorously as the unique solution of an SDE driven by Poisson measures, under reasonable non explosion conditions. In the following, we introduce a unified framework for the pathwise representation of the class of stochastic IBMs introduced above. </span>
<span id="cb37-390"><a href="#cb37-390" aria-hidden="true" tabindex="-1"></a>Some recalls on Poisson random measures are presented in the Appendix @sec-recall-poisson, and for more details on these representations on particular examples, we refer to the abundant literature on the subject.</span>
<span id="cb37-391"><a href="#cb37-391" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-392"><a href="#cb37-392" aria-hidden="true" tabindex="-1"></a>In the following we consider an individual-based stochastic population $(Z_t)_{t\in <span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>}$, keeping the notations introduced in @sec-events and @sec-event-intensity for the events and their intensities.</span>
<span id="cb37-393"><a href="#cb37-393" aria-hidden="true" tabindex="-1"></a>In particular, the set of events types that define the population evolution is denoted by $\mathcal{P} \cup \mathcal{E} \cup \mathcal{E}_W \subset E$, with $\mathcal{P}$ the set of events types with Poisson intensity verifying @cnj-intensity-poisson, $\mathcal{E}$ the set of events types with individual intensity and no interaction, verifying @cnj-intensity1 and finally $\mathcal{E}_W$ the set of event types with interactions, verifying @cnj-intensity2.</span>
<span id="cb37-394"><a href="#cb37-394" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-395"><a href="#cb37-395" aria-hidden="true" tabindex="-1"></a><span class="fu">### Non explosion criterion</span></span>
<span id="cb37-396"><a href="#cb37-396" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-397"><a href="#cb37-397" aria-hidden="true" tabindex="-1"></a>First, one has to ensure that the number of events occurring in the population will not explode in finite time, leading to an infinite simulation time. @cnj-intensity1 and @cnj-intensity2 are not sufficient to guarantee the non explosion of the event number, due to the potential explosion of the population size in the presence of interactions. An example is the case when only birth events occur, with an intensity $\Lambda^b_t(Z_t) = C_b (N_t^a)^2$ ($W^b(t, I,J) =C_b$). Then, the number of alive individuals $(N_t^a)_{t\geq 0}$ is a well-known pure birth process of intensity function $g(n) = C_b n^2$ (intensity of moving from state $n$ to $n+1$). This process explodes in finite time, since $g$ does not verify the necessary and sufficient non explosion criterion for pure birth Markov processes: $\sum_{n=1}^\infty \frac{1}{g(n)} = \infty$ (see e.g. Theorem 2.2 in <span class="co">[</span><span class="ot">@BanMel15</span><span class="co">]</span>). There is thus an explosion in finite time of birth events.</span>
<span id="cb37-398"><a href="#cb37-398" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-399"><a href="#cb37-399" aria-hidden="true" tabindex="-1"></a>This example shows that the important point for non explosion is to control the population size. We give below a general sufficient condition on birth and entry event intensities, in order for the population size to stay finite in finite time. This ensures that the number of events does not explode in finite time. Informally, the idea is to control the intensities by a pure birth intensity function verifying the non-explosion criterion.</span>
<span id="cb37-400"><a href="#cb37-400" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-401"><a href="#cb37-401" aria-hidden="true" tabindex="-1"></a>::: {#cnj-non-explosion} </span>
<span id="cb37-402"><a href="#cb37-402" aria-hidden="true" tabindex="-1"></a>Let $e=b$ or $en$, a birth or entry event type. If the intensity at which the events of type $e$ occur in the population are not Poissonian, i.e. $e \in \mathcal{E} \cup \mathcal{E}_W$, then there exists a function $f^e : {\mathbb{N}}\to (0, +\infty)$, such that</span>
<span id="cb37-403"><a href="#cb37-403" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-404"><a href="#cb37-404" aria-hidden="true" tabindex="-1"></a>    \sum_{n=1}^{\infty} \frac{1}{nf^e(n)} = \infty,</span>
<span id="cb37-405"><a href="#cb37-405" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-406"><a href="#cb37-406" aria-hidden="true" tabindex="-1"></a>and for all individual $I \in \mathcal{I}$ and population measure $Z = \sum_{k=1}^{n} \delta_{I_k}$ of size $n$,</span>
<span id="cb37-407"><a href="#cb37-407" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-408"><a href="#cb37-408" aria-hidden="true" tabindex="-1"></a>    \lambda^e_t (I, Z) \leq f^e(n), \; \forall \; 0\leq t \leq T.</span>
<span id="cb37-409"><a href="#cb37-409" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-410"><a href="#cb37-410" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb37-411"><a href="#cb37-411" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-412"><a href="#cb37-412" aria-hidden="true" tabindex="-1"></a>::: {#rem}</span>
<span id="cb37-413"><a href="#cb37-413" aria-hidden="true" tabindex="-1"></a>If $e \in \mathcal{E}$, $\lambda_t^e(I,Z) = \lambda^e(t,I) \leq \bar{\lambda}^e$ by the domination @cnj-intensity2, then @cnj-non-explosion is always verified with $f^e(n) = \bar{\lambda}^e$.</span>
<span id="cb37-414"><a href="#cb37-414" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb37-415"><a href="#cb37-415" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-416"><a href="#cb37-416" aria-hidden="true" tabindex="-1"></a>@cnj-non-explosion yields that the global intensity $\Lambda_t^e(\cdot)$ of event $e$ is bounded by a function $g^e$ only depending on the population size:</span>
<span id="cb37-417"><a href="#cb37-417" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-418"><a href="#cb37-418" aria-hidden="true" tabindex="-1"></a>    \Lambda_t^e (Z) \leq g^e(n) := nf^e(n), \quad \text{with }\sum_{n=1}^{\infty} \frac{1}{g^e(n)} = \infty.</span>
<span id="cb37-419"><a href="#cb37-419" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-420"><a href="#cb37-420" aria-hidden="true" tabindex="-1"></a>If $e\in \mathcal{P}$ has a Poisson intensity, then $\Lambda_t^e(Z) =\mu^e_t$ always verifies the previous equation with $g^e(n) = \bar \mu^e$.</span>
<span id="cb37-421"><a href="#cb37-421" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-422"><a href="#cb37-422" aria-hidden="true" tabindex="-1"></a>Before introducing the IBM SDE, let us give an idea of the equation construction. Between two successive events, the population composition $Z_t$ stays constant, since the population process $(Z_t)_{t \geq 0}$ is a pure jump process.</span>
<span id="cb37-423"><a href="#cb37-423" aria-hidden="true" tabindex="-1"></a>Furthermore, since each event type is characterized by an intensity function, the jumps occurring in the population can be represented by restriction and projection of a Poisson measure defined on a larger state space. </span>
<span id="cb37-424"><a href="#cb37-424" aria-hidden="true" tabindex="-1"></a>More precisely, we introduce a random Poisson measure $Q$ on $\mathbb R^+ \times \mathcal{J}\times \mathbb{R}^+$, with $\mathcal{J}= \mathbb N \times(\mathcal E \cup \mathcal{E}_W)$. $Q$ is composed of random quadruplets $(\tau, k , e, \theta)$, where $\tau$ represents a potential event time for an individual $I_k$ and event type $e$. </span>
<span id="cb37-425"><a href="#cb37-425" aria-hidden="true" tabindex="-1"></a>The last variable $\theta$ is used to accept/reject this proposed event, depending on the event intensity. Hence, the Poisson measure is restricted to a certain random set and then projected on the space of interest ${\mathbb{R}}^+ \times \mathcal{J}$. If the event is accepted, then a jump $\phi^e(\tau,I_k)$ occurs.</span>
<span id="cb37-426"><a href="#cb37-426" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-427"><a href="#cb37-427" aria-hidden="true" tabindex="-1"></a>::: {#thm-eq-Z} </span>
<span id="cb37-428"><a href="#cb37-428" aria-hidden="true" tabindex="-1"></a><span class="fu">## Pathwise representation</span></span>
<span id="cb37-429"><a href="#cb37-429" aria-hidden="true" tabindex="-1"></a>Let $T\in {\mathbb{R}}^+$ and $\mathcal{J}= \mathbb N \times(\mathcal E \cup \mathcal{E}_W)$. </span>
<span id="cb37-430"><a href="#cb37-430" aria-hidden="true" tabindex="-1"></a>Let $Q$ be a random Poisson measure on $\mathbb R^+ \times \mathcal{J}\times \mathbb{R}^+$, of intensity $\mathrm{d}t \delta_{\mathcal{J}}(\mathrm{d}k,\mathrm{d}e)  \mathbf{1}_{[0,\bar \lambda^e]} (\theta)\mathrm{d}\theta$, with $\delta_{\mathcal{J}}$ the counting measure on $\mathcal{J}$. </span>
<span id="cb37-431"><a href="#cb37-431" aria-hidden="true" tabindex="-1"></a>Finally, let $Q^{\mathcal P}$ be a random Poisson measure on $\mathbb R^+ \times \mathcal{P}  \times \mathbb{R}^+$, of intensity $\mathrm{d}t \delta_{\cal P}(\mathrm{d}e)  \mathbf{1}_{[0,\bar \mu^e]} (\theta)\mathrm{d}\theta$, and $Z_0= \sum_{k=1}^{N_0} \delta_{I_k}$ an initial population.</span>
<span id="cb37-432"><a href="#cb37-432" aria-hidden="true" tabindex="-1"></a>Then, under @cnj-non-explosion</span>
<span id="cb37-433"><a href="#cb37-433" aria-hidden="true" tabindex="-1"></a>, there exists a unique</span>
<span id="cb37-434"><a href="#cb37-434" aria-hidden="true" tabindex="-1"></a>measure-valued population process $Z$, strong solution on the following</span>
<span id="cb37-435"><a href="#cb37-435" aria-hidden="true" tabindex="-1"></a>SDE driven by the Poisson measure $Q$: </span>
<span id="cb37-436"><a href="#cb37-436" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-437"><a href="#cb37-437" aria-hidden="true" tabindex="-1"></a>    \begin{aligned}</span>
<span id="cb37-438"><a href="#cb37-438" aria-hidden="true" tabindex="-1"></a>    Z_t = Z_0 &amp;+ \int_0^t \int_{ \mathcal{J}\times \mathbb R^+ }\phi^e (s , I_k)  \mathbf{1}_{\{k \leq N_{s^-}\} }\mathbf{1}_{\{\theta \leq \lambda_s^e(I_k, Z_{s^-})<span class="sc">\}</span>} Q (\mathrm{d}s ,\mathrm{d}k , \mathrm{d}e, \mathrm{d}\theta ) <span class="sc">\\</span></span>
<span id="cb37-439"><a href="#cb37-439" aria-hidden="true" tabindex="-1"></a>    \nonumber &amp;+   \int_0^t \int_{\mathcal{P} \times \mathbb R^+}  \phi^e(s, I_{s^-}) \mathbf{1}_{<span class="sc">\{</span>\theta \leq \mu^e(s) <span class="sc">\}</span>} Q^{\mathcal{P}} (\mathrm{d}s ,\mathrm{d}e,  \mathrm{d}\theta),  \qquad \forall  0 \leq t \leq T,</span>
<span id="cb37-440"><a href="#cb37-440" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb37-441"><a href="#cb37-441" aria-hidden="true" tabindex="-1"></a>$$ {#eq-sde-eq-Z}</span>
<span id="cb37-442"><a href="#cb37-442" aria-hidden="true" tabindex="-1"></a>and where $I_{s^-}$ is an individual, chosen uniformly among alive individuals in the population $Z_{s^-}$.</span>
<span id="cb37-443"><a href="#cb37-443" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb37-444"><a href="#cb37-444" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-445"><a href="#cb37-445" aria-hidden="true" tabindex="-1"></a>The proof of @thm-eq-Z is detailed in the Appendix, @sec-prf-thm-eq-Z. Note that @eq-sde-eq-Z is an SDE describing the evolution of the IBM, the intensity of the events in the right hand side of the equation depending on the population process $Z$ itself. </span>
<span id="cb37-446"><a href="#cb37-446" aria-hidden="true" tabindex="-1"></a>The main idea of the proof of @thm-eq-Z is to use the non explosion property of @lem-non-explosion, and to write the r.h.s of @eq-sde-eq-Z as a sum of simple equations between two successive events, solved by induction.</span>
<span id="cb37-447"><a href="#cb37-447" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-448"><a href="#cb37-448" aria-hidden="true" tabindex="-1"></a>::: {#lem-non-explosion}</span>
<span id="cb37-449"><a href="#cb37-449" aria-hidden="true" tabindex="-1"></a>Let $Z$ be a solution of @eq-sde-eq-Z on ${\mathbb{R}}^+$, with $(T_n)_{n\geq 0}$ its jump times, $T_0 = 0$. If @cnj-non-explosion is satisfied, then</span>
<span id="cb37-450"><a href="#cb37-450" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-451"><a href="#cb37-451" aria-hidden="true" tabindex="-1"></a>    \lim_{n \to \infty} T_n = \infty, \quad {\mathbb{P}}\text{-a.s.}</span>
<span id="cb37-452"><a href="#cb37-452" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-453"><a href="#cb37-453" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb37-454"><a href="#cb37-454" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-455"><a href="#cb37-455" aria-hidden="true" tabindex="-1"></a>The proof of @lem-non-explosion, detailed in Appendix @sec-prf-lem-non-explosion is more technical and rely on pathwise comparison result, generalizing those obtained in <span class="co">[</span><span class="ot">@KaaElK20</span><span class="co">]</span>. An alternative pathwise representation of the population process, inspired by the randomized @alg-randomized is given as well in @prp-randomized.</span>
<span id="cb37-456"><a href="#cb37-456" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-457"><a href="#cb37-457" aria-hidden="true" tabindex="-1"></a><span class="fu"># Population simulation {#sec-simulation}</span></span>
<span id="cb37-458"><a href="#cb37-458" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-459"><a href="#cb37-459" aria-hidden="true" tabindex="-1"></a>We now present the main algorithm for simulating the evolution of an IBM over $<span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>$.The algorithm implemented in <span class="in">`IBMPopSim`</span> allows the exact simulation of @eq-sde-eq-Z, based on an acceptance/reject algorithm for simulating random times called *thinning*. The exact simulation of event times with this acceptance/reject procedure is closely related to the simulations of inhomogeneous Poisson processes by the so-called thinning algorithm, often attributed to @LewShe79. </span>
<span id="cb37-460"><a href="#cb37-460" aria-hidden="true" tabindex="-1"></a>The simulation methods for inhomogeneous Poisson processes can be adapted to IBMs, and we introduce in this section a general algorithm extending those by @FouMel04 (see also @FerTra09, @Ben10).</span>
<span id="cb37-461"><a href="#cb37-461" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-462"><a href="#cb37-462" aria-hidden="true" tabindex="-1"></a>The algorithm is based on exponential "candidate" event times, chosen with a (constant) intensity which must be greater than the global event intensity $\Lambda_t(Z_t)$ (@eq-global-intensity). Starting from time $t$, once a candidate event time $t + \bar T_\ell$ has been proposed, a candidate event type $e$ (birth, death,<span class="sc">\.</span>..) is chosen with a probability $p^e$ depending on the event intensity bounds $\bar \mu^e$, $\bar \lambda^e$ and $\bar W^e$, as defined in @cnj-intensity1 and @cnj-intensity2. </span>
<span id="cb37-463"><a href="#cb37-463" aria-hidden="true" tabindex="-1"></a>An individual $I$ is then drawn from the population. </span>
<span id="cb37-464"><a href="#cb37-464" aria-hidden="true" tabindex="-1"></a>Finally, it remains to accept or reject the candidate event with a probability $q^e(t,I,Z_t)$ depending on the true event intensity. </span>
<span id="cb37-465"><a href="#cb37-465" aria-hidden="true" tabindex="-1"></a>If the candidate event time is accepted, then the event $e$ occurs at time $t + \bar T_\ell$ to the individual $I$. The main idea of the algorithm implemented can be summarized as follows:</span>
<span id="cb37-466"><a href="#cb37-466" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-467"><a href="#cb37-467" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Draw a candidate time $t + \bar T_\ell$ and candidate event type $e$.</span>
<span id="cb37-468"><a href="#cb37-468" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Draw a uniform variable $\theta \sim \mathcal{U}(<span class="co">[</span><span class="ot">0, 1</span><span class="co">]</span>)$ and individual $I$.</span>
<span id="cb37-469"><a href="#cb37-469" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>**If** $\theta \leq q^e(t,I,Z_t)$ **then** event $e$ occur to individual $I$, **else** Do nothing and start again from $t + \bar T_\ell$.</span>
<span id="cb37-470"><a href="#cb37-470" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-471"><a href="#cb37-471" aria-hidden="true" tabindex="-1"></a>Before introducing the main algorithms in more details, we recall briefly the thinning procedure for simulating inhomogeneous Poisson processes, as well as the links with pathwise representations. Some recalls on Poisson random measures are presented in @sec-recall-poisson.</span>
<span id="cb37-472"><a href="#cb37-472" aria-hidden="true" tabindex="-1"></a>For a more general presentation of thinning of a Poisson random measure, see <span class="co">[</span><span class="ot">@Dev86; @Cin11; @Kal17</span><span class="co">]</span>.</span>
<span id="cb37-473"><a href="#cb37-473" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-474"><a href="#cb37-474" aria-hidden="true" tabindex="-1"></a><span class="fu">## Thinning of Poisson measure {#sec-thinning}</span></span>
<span id="cb37-475"><a href="#cb37-475" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-476"><a href="#cb37-476" aria-hidden="true" tabindex="-1"></a>Let us start with the simulation and pathwise representation of an inhomogeneous Poisson process on $<span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>$ with intensity $(\Lambda(t))_{t\in <span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>}$. The thinning procedure is based on the fundamental assumption that $\Lambda(t) \leq  \bar \Lambda$ is bounded on $<span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>$. In this case, the inhomogeneous Poisson can be obtained from an homogeneous Poisson process of intensity $\bar \Lambda$, which can be simulated easily.</span>
<span id="cb37-477"><a href="#cb37-477" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-478"><a href="#cb37-478" aria-hidden="true" tabindex="-1"></a>First, the Poisson process can be extended to a Marked Poisson measure $\bar Q:= \sum_{\ell \ge 1} \delta_{(\bar T_\ell, \bar \Theta_\ell)}$ on $(\mathbb{R}^+)^2$, defined as follow:</span>
<span id="cb37-479"><a href="#cb37-479" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-480"><a href="#cb37-480" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The jump times of $(\bar T_\ell)_{\ell \ge 1}$ of $\bar Q$ are the jump times of a Poisson process of intensity $\bar \Lambda$.</span>
<span id="cb37-481"><a href="#cb37-481" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-482"><a href="#cb37-482" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The marks $(\bar \Theta_\ell)_{\ell \ge 1}$ are _i.i.d._ random variables, uniformly distributed on $<span class="co">[</span><span class="ot">0, \bar \Lambda</span><span class="co">]</span>$.</span>
<span id="cb37-483"><a href="#cb37-483" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-484"><a href="#cb37-484" aria-hidden="true" tabindex="-1"></a>By @prp-marked-poisson , $\bar{Q}$ is a Poisson random measure with mean measure</span>
<span id="cb37-485"><a href="#cb37-485" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-486"><a href="#cb37-486" aria-hidden="true" tabindex="-1"></a>    \bar \mu(\mathrm{d}t, \mathrm{d}\theta): = \bar \Lambda \mathrm{d}t</span>
<span id="cb37-487"><a href="#cb37-487" aria-hidden="true" tabindex="-1"></a>    \frac{\mathbf{1}_{[0, \bar \Lambda]}(\theta)}{\bar \Lambda} \mathrm{d}\theta= \mathrm{d}t  \mathbf{1}_{<span class="co">[</span><span class="ot">0, \bar \Lambda</span><span class="co">]</span>}(\theta) \mathrm{d}\theta.</span>
<span id="cb37-488"><a href="#cb37-488" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-489"><a href="#cb37-489" aria-hidden="true" tabindex="-1"></a>In particular, the average number of atoms $(\bar T_\ell, \bar \Theta_\ell)$ in $<span class="co">[</span><span class="ot">0,t</span><span class="co">]</span>\times <span class="co">[</span><span class="ot">0,h</span><span class="co">]</span>$ is</span>
<span id="cb37-490"><a href="#cb37-490" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-491"><a href="#cb37-491" aria-hidden="true" tabindex="-1"></a>    \mathbb{E}<span class="co">[</span><span class="ot">Q([0,t]\times [0,h])</span><span class="co">]</span>={\mathbb{E}}<span class="co">[</span><span class="ot">\sum_{\ell} \boldsymbol{1}_{[0,t]\times [0,h]} (\bar T_\ell, \bar \Theta_{\ell})</span><span class="co">]</span>  = \int_{(\mathbb{R}^+)^2}  \bar \mu(\mathrm{d}t, \mathrm{d}\theta)  = t (\bar \Lambda \wedge h).</span>
<span id="cb37-492"><a href="#cb37-492" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-493"><a href="#cb37-493" aria-hidden="true" tabindex="-1"></a>The thinning is based on the restriction property for Poisson measure: for a measurable set $\Delta\subset {\mathbb{R}}^+\times {\mathbb{R}}^+$, the restriction $Q^\Delta:= \boldsymbol{1}_{\Delta}\bar Q$ of $\bar Q$ to $\Delta$ (by taking only atoms in $\Delta$) is also a Poisson random measure of mean measure $\mu^{\Delta}(\mathrm{d}t, \mathrm{d}\theta)  = \boldsymbol{1}_{\Delta}(t,\theta) \bar \mu(\mathrm{d}t, \mathrm{d}\theta).$</span>
<span id="cb37-494"><a href="#cb37-494" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-495"><a href="#cb37-495" aria-hidden="true" tabindex="-1"></a>In order to obtain an inhomogeneous Poisson measure of intensity $(\Lambda(t))$, the "good" choice of $\Delta$ is the hypograph of $\Lambda$:</span>
<span id="cb37-496"><a href="#cb37-496" aria-hidden="true" tabindex="-1"></a>$\Delta =<span class="sc">\{</span> (t,\theta) \in <span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>\times <span class="co">[</span><span class="ot">0,\bar \Lambda</span><span class="co">]</span> ; \; \theta \leq \Lambda(t)<span class="sc">\}</span>$ </span>
<span id="cb37-497"><a href="#cb37-497" aria-hidden="true" tabindex="-1"></a>(see @fig-thinning). Then, </span>
<span id="cb37-498"><a href="#cb37-498" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-499"><a href="#cb37-499" aria-hidden="true" tabindex="-1"></a>    Q^\Delta = \sum_{\ell \ge 1} \mathbf{1}_{\left\{\bar \Theta_\ell \le \Lambda(\bar T_\ell)\right\}} \delta_{(\bar T_\ell, \bar \Theta_\ell)},</span>
<span id="cb37-500"><a href="#cb37-500" aria-hidden="true" tabindex="-1"></a>$$ </span>
<span id="cb37-501"><a href="#cb37-501" aria-hidden="true" tabindex="-1"></a>and since $\Lambda(t) \leq \bar \Lambda$, on $<span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>$:</span>
<span id="cb37-502"><a href="#cb37-502" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-503"><a href="#cb37-503" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb37-504"><a href="#cb37-504" aria-hidden="true" tabindex="-1"></a>    \mu^{\Delta}(\mathrm{d}t, \mathrm{d}\theta) &amp; = \boldsymbol{1}_{<span class="sc">\{</span> \theta \leq \Lambda(t)<span class="sc">\}</span>}  \mathrm{d}t</span>
<span id="cb37-505"><a href="#cb37-505" aria-hidden="true" tabindex="-1"></a>\mathbf{1}_{[0, \bar \Lambda]}(\theta)\mathrm{d}\theta = \boldsymbol{1}_{<span class="sc">\{</span>\theta \leq \Lambda(t)<span class="sc">\}</span>} \mathrm{d}t \mathrm{d}\theta.</span>
<span id="cb37-506"><a href="#cb37-506" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb37-507"><a href="#cb37-507" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-508"><a href="#cb37-508" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-509"><a href="#cb37-509" aria-hidden="true" tabindex="-1"></a>!<span class="co">[</span><span class="ot">Realization of a Marked Poisson measure $\bar Q$ on $[0,T]$ with mean measure $\bar \mu(\mathrm{d} t, \mathrm{d} \theta) = \mathrm{d} t \mathbf{1}_{[0, \bar \Lambda]}(\theta) \mathrm{d} \theta$ (red crosses), and realization of the restriction $\bar Q^\Delta$ where $\Delta = \{ (t,\theta)\in [0,T]\times[0, \bar \Lambda], \theta \leq \Lambda(t) \}$ (blue circles). The projection of $\bar Q^\Delta$ on first component is an inhomogeneous Poisson process on $[0,T]$ of intensity $(\Lambda(t))$ and jump times $(T_k)_{k \ge 1}$.</span><span class="co">](img/plot_thinning.tex)</span>{#fig-thinning}</span>
<span id="cb37-510"><a href="#cb37-510" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-511"><a href="#cb37-511" aria-hidden="true" tabindex="-1"></a>Finally, the inhomogeneous Poisson process is obtained by the projection @prp-proj-poisson-measure, which states that the jump times of $Q^\Delta$ are the jump times of an inhomogeneous Poisson process of intensity $(\Lambda(t))$.</span>
<span id="cb37-512"><a href="#cb37-512" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-513"><a href="#cb37-513" aria-hidden="true" tabindex="-1"></a>::: {#prp-thinning}</span>
<span id="cb37-514"><a href="#cb37-514" aria-hidden="true" tabindex="-1"></a>The counting process $N^\Lambda$, projection of $Q^{\Delta}$ on the time component and defined by,</span>
<span id="cb37-515"><a href="#cb37-515" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-516"><a href="#cb37-516" aria-hidden="true" tabindex="-1"></a>    N^{\Lambda}_t := Q^{\Delta}( [0,t] \times {\mathbb{R}}^+) = \int_0^t \int_{{\mathbb{R}}^+} \boldsymbol{1}_{\{\theta \leq \Lambda(s)\}} \bar Q(\mathrm{d}s, \mathrm{d}\theta) = \sum_{\ell \geq 1} \mathsf{1}_{\{ \bar T_\ell \leq t \}} \mathsf{1}_{\{\bar \Theta_\ell \leq  \Lambda(\bar T_\ell) <span class="sc">\}</span>},  \quad \forall t \in <span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>,</span>
<span id="cb37-517"><a href="#cb37-517" aria-hidden="true" tabindex="-1"></a>$$ {#eq-thinning-inhomogeneous-poisson}</span>
<span id="cb37-518"><a href="#cb37-518" aria-hidden="true" tabindex="-1"></a>is an inhomogeneous Poisson process on $<span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>$ of intensity function $(\Lambda(t))_{t\in <span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>}$. The thinning @eq-thinning-inhomogeneous-poisson is a pathwise representation of $N^\Lambda$ by *restriction and projection* of the Poisson measure $Q$ on $<span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>$.</span>
<span id="cb37-519"><a href="#cb37-519" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb37-520"><a href="#cb37-520" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-521"><a href="#cb37-521" aria-hidden="true" tabindex="-1"></a>The previous proposition yields a straightforward thinning algorithm to simulate the jump times $(T_k)_{k \ge 1}$ of an inhomogeneous Poisson process of intensity $\Lambda(t)$, by selecting jump times $\bar T_\ell$ such that $\bar \Theta_\ell \le \Lambda(\bar T_\ell)$.</span>
<span id="cb37-522"><a href="#cb37-522" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-523"><a href="#cb37-523" aria-hidden="true" tabindex="-1"></a><span class="fu">### Multivariate Poisson process {#sec-vector}</span></span>
<span id="cb37-524"><a href="#cb37-524" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-525"><a href="#cb37-525" aria-hidden="true" tabindex="-1"></a>This can be extended to the simulation of multivariate inhomogeneous Poisson processes, which is an important example before tackling the simulation of an IBM.</span>
<span id="cb37-526"><a href="#cb37-526" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-527"><a href="#cb37-527" aria-hidden="true" tabindex="-1"></a>Let $(N^j)_{j \in \mathcal{J}}$ be a (inhomogeneous) multivariate Poisson process indexed by a finite set $\mathcal{J}$, such that $\forall j \in \mathcal{J}$, the intensity $(\lambda_j(t))_{t\in <span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>}$ of $N_j$ is bounded on $<span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>$:</span>
<span id="cb37-528"><a href="#cb37-528" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-529"><a href="#cb37-529" aria-hidden="true" tabindex="-1"></a>    \sup_{t\in<span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>} \lambda_j(t) \le \bar \lambda_j, \text{ and let }</span>
<span id="cb37-530"><a href="#cb37-530" aria-hidden="true" tabindex="-1"></a>    \bar \Lambda = \sum_{j \in \mathcal{J}} \bar \lambda_j.</span>
<span id="cb37-531"><a href="#cb37-531" aria-hidden="true" tabindex="-1"></a>$$ </span>
<span id="cb37-532"><a href="#cb37-532" aria-hidden="true" tabindex="-1"></a>Recall that such multivariate counting process can be rewritten as a Poisson random measure $N= \sum_{k\geq 1} \delta_{(T_k,J_k)}$ on ${\mathbb{R}}^+\times \mathcal{J}$ (see e.g. Sec. 2 of Chapter 6 in&nbsp;<span class="co">[</span><span class="ot">@Cin11</span><span class="co">]</span>), where $T_k$ is the $k$th jump time of $\sum_{j\in \mathcal{J}} N^j$ and $J_k$ corresponds to the component of the the vector which jumps. In particular, $N^j_t = N(<span class="co">[</span><span class="ot">0,t</span><span class="co">]</span>\times <span class="sc">\{</span>j<span class="sc">\}</span>)$.</span>
<span id="cb37-533"><a href="#cb37-533" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-534"><a href="#cb37-534" aria-hidden="true" tabindex="-1"></a>Once again the simulation of such process can be obtained from the simulation of a (homogeneous) multivariate Poisson process of intensity vector $(\bar{\lambda}_j)_{j \in \mathcal{J}}$, extended into a Poisson measures by adding marks on ${\mathbb{R}}^+$. </span>
<span id="cb37-535"><a href="#cb37-535" aria-hidden="true" tabindex="-1"></a>Thus, we introduce the Marked Poisson measure $\bar Q = \sum \delta_{(\bar T_\ell, \bar J_\ell, \bar \Theta_\ell)}$ on ${\mathbb{R}}^+  \times \mathcal{J}\times {\mathbb{R}}^+$, such that:</span>
<span id="cb37-536"><a href="#cb37-536" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-537"><a href="#cb37-537" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The jump times $(\bar T_\ell)$ of $\bar Q$ are the jump times of a Poisson measure of intensity $\bar \Lambda$.</span>
<span id="cb37-538"><a href="#cb37-538" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The variables $(\bar J_\ell)$ are *i.i.d.* random variables on $\mathcal{J}$, with $\displaystyle p_j= {\mathbb{P}}(\bar J_1 = j)= \bar \lambda_j/\bar \Lambda$ and representing the component of the vector which jumps.</span>
<span id="cb37-539"><a href="#cb37-539" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The marks $(\bar \Theta_\ell)$ are independent variables with $\bar \Theta_\ell$ a uniform random variable on $[0,\bar \lambda_{{\bar J}_\ell}]$, $\forall \ell \geq 1$.</span>
<span id="cb37-540"><a href="#cb37-540" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-541"><a href="#cb37-541" aria-hidden="true" tabindex="-1"></a>By @prp-marked-poisson and @prp-proj-poisson-measure, each measure $\bar Q_j (\mathrm{d}t, \mathrm{d}\theta) = \bar Q(\mathrm{d}t, <span class="sc">\{</span>j<span class="sc">\}</span>, \mathrm{d}\theta) = \sum_{\ell \geq 1} \mathsf{1}_{\{\bar J_\ell=j \}} \delta_{(\bar T_\ell, \bar \Theta_\ell)}$ is a marked Poisson measure of intensity</span>
<span id="cb37-542"><a href="#cb37-542" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-543"><a href="#cb37-543" aria-hidden="true" tabindex="-1"></a>    \bar \mu_j ( \mathrm{d}t  ,\mathrm{d}\theta) = \bar{\Lambda}p_j \mathrm{d}t  \frac{\mathsf{1}_{\{\theta \leq \bar \lambda_{j}\}}(\theta)}{\bar \lambda_{j}} \mathrm{d}\theta = \mathrm{d}t  \mathsf{1}_{\{\theta \leq \bar \lambda_{j}<span class="sc">\}</span>}(\theta) \mathrm{d}\theta.</span>
<span id="cb37-544"><a href="#cb37-544" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-545"><a href="#cb37-545" aria-hidden="true" tabindex="-1"></a>As a direct application of @prp-thinning , the inhomogeneous multivariate Poisson process is obtained by restriction of each measures $\bar Q_j$ to $\Delta_j = <span class="sc">\{</span> (t, \theta) \in <span class="co">[</span><span class="ot">0,T</span><span class="co">]</span> \times <span class="co">[</span><span class="ot">0,\bar \lambda_j</span><span class="co">]</span> ;\; \theta \leq \lambda_j(t) <span class="sc">\}</span>$ and projection.</span>
<span id="cb37-546"><a href="#cb37-546" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-547"><a href="#cb37-547" aria-hidden="true" tabindex="-1"></a>::: {#prp-thinning-vector}</span>
<span id="cb37-548"><a href="#cb37-548" aria-hidden="true" tabindex="-1"></a>The multivariate counting process $(N^j)_{j \in \mathcal{J}}$, defined for all $j \in \mathcal{J}$ and $t \in <span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>$ by thinning and projection of $\bar Q$:</span>
<span id="cb37-549"><a href="#cb37-549" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-550"><a href="#cb37-550" aria-hidden="true" tabindex="-1"></a>    N^j_t  := \int_0^t \int_{ {\mathbb{R}}^+} \boldsymbol{1}_{\{\theta \leq \lambda_j(s)\}} \bar{Q}(\mathrm{d}s, \{j\}, \mathrm{d}\theta) = \sum_{\ell \geq 1} \mathsf{1}_{\{ \bar T_\ell \leq t \}}\mathsf{1}_{\{\bar J_\ell = j\}} \mathsf{1}_{\{\bar \Theta_\ell \leq  \lambda_j (\bar T_\ell ) <span class="sc">\}</span>},</span>
<span id="cb37-551"><a href="#cb37-551" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-552"><a href="#cb37-552" aria-hidden="true" tabindex="-1"></a>is an inhomogeneous Poisson process of intensity vector $(\lambda_j(t))_{j\in\mathcal{J}}$ on $<span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>$.</span>
<span id="cb37-553"><a href="#cb37-553" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb37-554"><a href="#cb37-554" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-555"><a href="#cb37-555" aria-hidden="true" tabindex="-1"></a>@prp-thinning-vector yields the following simulation @alg-thinning2 for multivariate Poisson processes.</span>
<span id="cb37-556"><a href="#cb37-556" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-557"><a href="#cb37-557" aria-hidden="true" tabindex="-1"></a><span class="in">```pseudocode</span></span>
<span id="cb37-558"><a href="#cb37-558" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: alg-thinning2</span></span>
<span id="cb37-559"><a href="#cb37-559" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-indent-size: "1.2em"</span></span>
<span id="cb37-560"><a href="#cb37-560" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-comment-delimiter: "//"</span></span>
<span id="cb37-561"><a href="#cb37-561" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-line-number: true</span></span>
<span id="cb37-562"><a href="#cb37-562" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-line-number-punc: ":"</span></span>
<span id="cb37-563"><a href="#cb37-563" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-no-end: false</span></span>
<span id="cb37-564"><a href="#cb37-564" aria-hidden="true" tabindex="-1"></a><span class="in">#| pdf-placement: "htb!"</span></span>
<span id="cb37-565"><a href="#cb37-565" aria-hidden="true" tabindex="-1"></a><span class="in">#| pdf-line-number: true</span></span>
<span id="cb37-566"><a href="#cb37-566" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-567"><a href="#cb37-567" aria-hidden="true" tabindex="-1"></a><span class="in">\begin{algorithm}</span></span>
<span id="cb37-568"><a href="#cb37-568" aria-hidden="true" tabindex="-1"></a><span class="in">\caption{Thinning algorithm for multivariate inhomogeneous Poisson processes.}</span></span>
<span id="cb37-569"><a href="#cb37-569" aria-hidden="true" tabindex="-1"></a><span class="in">\begin{algorithmic}</span></span>
<span id="cb37-570"><a href="#cb37-570" aria-hidden="true" tabindex="-1"></a><span class="in">    \State \textbf{Input:} Functions $\lambda_j: [0,T] \to [0,\bar \lambda]$ and $\bar \lambda_j$, $\bar \Lambda = \sum_{j \in \mathcal{J}} \bar \lambda_j$</span></span>
<span id="cb37-571"><a href="#cb37-571" aria-hidden="true" tabindex="-1"></a><span class="in">    \State \textbf{Output:} Points $(T_k, J_k)$ of Poisson measure $N$ on $[0,T] \times \mathcal{J}$</span></span>
<span id="cb37-572"><a href="#cb37-572" aria-hidden="true" tabindex="-1"></a><span class="in">    \State Initialization $T_0 \longleftarrow 0$, $\bar T_0 \longleftarrow 0$</span></span>
<span id="cb37-573"><a href="#cb37-573" aria-hidden="true" tabindex="-1"></a><span class="in">    \While{$T_k &lt; T$}</span></span>
<span id="cb37-574"><a href="#cb37-574" aria-hidden="true" tabindex="-1"></a><span class="in">        \Repeat</span></span>
<span id="cb37-575"><a href="#cb37-575" aria-hidden="true" tabindex="-1"></a><span class="in">            \State increment iterative variable $\ell \longleftarrow \ell+1$</span></span>
<span id="cb37-576"><a href="#cb37-576" aria-hidden="true" tabindex="-1"></a><span class="in">            \State compute next proposed time $\bar T_{\ell} \longleftarrow \bar T_{\ell-1} + S_\ell$  with $S_\ell \sim \mathcal{E}(\bar \Lambda)$ </span></span>
<span id="cb37-577"><a href="#cb37-577" aria-hidden="true" tabindex="-1"></a><span class="in">            \State draw $\bar J_\ell \sim \mathcal{U}\big\{ \bar \lambda_j / \bar \Lambda, j \in \mathcal{J} \big\}$ i.e. $\mathbb{P}(\bar J_\ell = j) = \bar \lambda_j / \bar \Lambda$</span></span>
<span id="cb37-578"><a href="#cb37-578" aria-hidden="true" tabindex="-1"></a><span class="in">            \State draw $\bar \Theta_\ell \sim \mathcal{U}([0,\bar \lambda_{\bar J_\ell}])$</span></span>
<span id="cb37-579"><a href="#cb37-579" aria-hidden="true" tabindex="-1"></a><span class="in">        \Until{accepted event $\bar \Theta_\ell \le \lambda_{\bar J_\ell}(\bar T_{\ell})$} </span></span>
<span id="cb37-580"><a href="#cb37-580" aria-hidden="true" tabindex="-1"></a><span class="in">        \State record $(T_k, J_k) \longleftarrow (\bar T_{\ell}, \bar J_\ell)$ as accepted point</span></span>
<span id="cb37-581"><a href="#cb37-581" aria-hidden="true" tabindex="-1"></a><span class="in">    \EndWhile</span></span>
<span id="cb37-582"><a href="#cb37-582" aria-hidden="true" tabindex="-1"></a><span class="in">\end{algorithmic}</span></span>
<span id="cb37-583"><a href="#cb37-583" aria-hidden="true" tabindex="-1"></a><span class="in">\end{algorithm}</span></span>
<span id="cb37-584"><a href="#cb37-584" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb37-585"><a href="#cb37-585" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-586"><a href="#cb37-586" aria-hidden="true" tabindex="-1"></a>::: {#rem-alternate-thinning}</span>
<span id="cb37-587"><a href="#cb37-587" aria-hidden="true" tabindex="-1"></a>The acceptance/rejection @alg-thinning2 can be efficient when the functions $\lambda_j$ are of different order, and thus bounded by different $\bar \lambda_j$. However, it is important to note that the simulation of the discrete random variables $(\bar J_\ell)$ can be costly (compared to a uniform law) when $\mathcal{J}$ is large, for instance when an individual is drawn from a large population. In this case, an alternative is to choose the same bound $\bar \lambda_j= \bar \lambda$ for all $j \in \mathcal{J}$. Then the marks $(\bar J_\ell, \bar \Theta_\ell)$ are *i.i.d.* uniform variables on $\mathcal{J}\times <span class="co">[</span><span class="ot">0,\bar \lambda</span><span class="co">]</span>$, faster to simulate.</span>
<span id="cb37-588"><a href="#cb37-588" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb37-589"><a href="#cb37-589" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-590"><a href="#cb37-590" aria-hidden="true" tabindex="-1"></a><span class="fu">## Simulation algorithm {#sec-simulation-algo}</span></span>
<span id="cb37-591"><a href="#cb37-591" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-592"><a href="#cb37-592" aria-hidden="true" tabindex="-1"></a>Let us now come back to the simulation of the IBM introduced in @sec-ibm. For ease of notations, we assume that there are no event with Poisson intensity ($\mathcal{P} =\emptyset$), so that all events that occur are of type $e \in \mathcal{E} \cup \mathcal{E}_W$, with individual intensity $\lambda_t^e(I,Z_t)$ depending on the population composition $Z_t$ ($e \in \mathcal{E}_W$) or not ($e \in \mathcal{E}$), as defined in @eq-individual-intensity and verifying either @cnj-intensity1 or @cnj-intensity2.</span>
<span id="cb37-593"><a href="#cb37-593" aria-hidden="true" tabindex="-1"></a>The global intensity @eq-global-ev-intensity at time $t \in <span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>$ is thus</span>
<span id="cb37-594"><a href="#cb37-594" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-595"><a href="#cb37-595" aria-hidden="true" tabindex="-1"></a>    \Lambda_t(Z_t) = \sum_{e \in \mathcal{E}} \Big( \sum_{k=1}^{N_t} \lambda^e(t, I_k) \Big)</span>
<span id="cb37-596"><a href="#cb37-596" aria-hidden="true" tabindex="-1"></a><span class="ss">    + </span>\sum_{e \in \mathcal{E}_W} \Big( \sum_{k=1}^{N_t} \sum_{j=1}^{N_t} W^e(t, I_k, I_j) \Big) \leq \bar \Lambda(N_t),</span>
<span id="cb37-597"><a href="#cb37-597" aria-hidden="true" tabindex="-1"></a>$$ {#eq-def-intensity}</span>
<span id="cb37-598"><a href="#cb37-598" aria-hidden="true" tabindex="-1"></a>with</span>
<span id="cb37-599"><a href="#cb37-599" aria-hidden="true" tabindex="-1"></a>$\bar \Lambda(n) = \big(\sum_{e \in \mathcal{E}} \bar \lambda^e \big) n + \big( \sum_{e \in \mathcal{E}_W} \bar W^e \big) n^2$.</span>
<span id="cb37-600"><a href="#cb37-600" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-601"><a href="#cb37-601" aria-hidden="true" tabindex="-1"></a>One of the main difficulty is that the intensity of events is not deterministic as in the case of inhomogeneous Poisson processes, but a function $\Lambda_t(Z_t)$ of the population state, bounded by a function which also depends on the population size. However, the @alg-thinning2 can be adapted to simulate the IBM. The construction is done by induction, by conditioning on the state of the population $Z_{T_k}$ at the $k$th event time $T_k$ ($T_0 = 0$).</span>
<span id="cb37-602"><a href="#cb37-602" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-603"><a href="#cb37-603" aria-hidden="true" tabindex="-1"></a>We first present the construction of the first event at time $T_1$.</span>
<span id="cb37-604"><a href="#cb37-604" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-605"><a href="#cb37-605" aria-hidden="true" tabindex="-1"></a><span class="fu">### First event simulation</span></span>
<span id="cb37-606"><a href="#cb37-606" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-607"><a href="#cb37-607" aria-hidden="true" tabindex="-1"></a>Before the first event time, on $<span class="sc">\{</span> t &lt; T_1 <span class="sc">\}</span>$, the population composition is constant : $Z_t = Z_0 = <span class="sc">\{</span> I_1, \dots, I_{N_0}<span class="sc">\}</span>$. For each type of event $e$ and individual $I_k$, $k \in <span class="sc">\{</span>1,\dots N_0<span class="sc">\}</span>$, we denote by $N^{k,e}$ the counting process of intensity $\lambda_t^e (I_k,Z_t)$, counting the occurrences of the events of type $e$ happening to the individual $I_k$. Then, the first event $T_1$ is the first jump time of the multivariate counting vector $(N^{(k,e)})_{ (k,e) \in \mathcal{J}_0}$, with $\mathcal{J}_0 = <span class="sc">\{</span>1,\dots , N_0<span class="sc">\}</span>\times \big(\mathcal{E} \cup \mathcal{E}_W \big)$.</span>
<span id="cb37-608"><a href="#cb37-608" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-609"><a href="#cb37-609" aria-hidden="true" tabindex="-1"></a>Since the population composition is constant before the first event time, each counting process $N^{j}$ coincides on $[0,T_1[$ with an inhomogeneous Poisson process, of intensity $\lambda_t^e (I_k,Z_0)$. Thus (conditionally to $Z_0$), $T_1$ is also the first jump time of an inhomogeneous multivariate Poisson process $N^0 = (N^{0,j})_{j \in \mathcal{J}_0}$ of intensity function $(\lambda_j)_{j\in \mathcal J_0}$, defined for all $j = (k,e) \in \mathcal{J}_0$ by:</span>
<span id="cb37-610"><a href="#cb37-610" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-611"><a href="#cb37-611" aria-hidden="true" tabindex="-1"></a>    \lambda_j(t) = \lambda^e_t(I_k,Z_0) \le \bar \lambda^e_0 \quad \text{with} \quad \bar \lambda^e_0 = \bar \lambda^e \mathbf{1}_{e \in \mathcal{E}} + \bar W^e N_0 \mathbf{1}_{e \in \mathcal{E}_W},</span>
<span id="cb37-612"><a href="#cb37-612" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-613"><a href="#cb37-613" aria-hidden="true" tabindex="-1"></a>by @cnj-intensity1 and @cnj-intensity2. In particular, the jump times of $N^0$ occur at the intensity</span>
<span id="cb37-614"><a href="#cb37-614" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-615"><a href="#cb37-615" aria-hidden="true" tabindex="-1"></a>    \Lambda(t) =\sum_{j \in \mathcal{J}_0} \lambda_j(t)  =\sum_{e \in \mathcal{E} \cup \mathcal{E}_W} \sum_{k=1}^{N_0}  \lambda^e_t(I_k,Z_0) \leq \bar \Lambda(N_0)=N_0 \sum_{e \in \mathcal{E} \cup \mathcal{E}_W} \bar \lambda^e_0.</span>
<span id="cb37-616"><a href="#cb37-616" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-617"><a href="#cb37-617" aria-hidden="true" tabindex="-1"></a>By @prp-thinning-vector, $N^0$ can be obtained by thinning of the marked Poisson measure $\bar Q^0 = \sum_{\ell \geq 1} \delta_{(\bar T_\ell , (\bar{K}_\ell, \bar E_\ell), \bar \Theta_\ell)}$ on ${\mathbb{R}}^+\times\mathcal{J}_0 \times {\mathbb{R}}^+$, with:</span>
<span id="cb37-618"><a href="#cb37-618" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-619"><a href="#cb37-619" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$(\bar T_\ell)_{\ell \in {\mathbb{N}}^*}$ the jump times of a Poisson process of rate $\bar \Lambda(N_0)$.</span>
<span id="cb37-620"><a href="#cb37-620" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$(\bar{K}_\ell, \bar E_\ell)_{\ell \in {\mathbb{N}}^*}$ discrete *i.i.d.* random variables on $\mathcal{J}_0 = \{1,\dots , N_0\}\times \big(\mathcal{E} \cup \mathcal{E}_W \big)$, with $K_\ell$ representing the index of the chosen individual and $E_\ell$ the event type for the proposed event, such that:</span>
<span id="cb37-621"><a href="#cb37-621" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-622"><a href="#cb37-622" aria-hidden="true" tabindex="-1"></a>    \mathbb{P}( \bar  K_1 = k, \bar E_1 = e) </span>
<span id="cb37-623"><a href="#cb37-623" aria-hidden="true" tabindex="-1"></a>    = \frac{\bar \lambda^e_0 }{\bar \Lambda(N_0)}</span>
<span id="cb37-624"><a href="#cb37-624" aria-hidden="true" tabindex="-1"></a>    = \frac{1}{N_0} \frac{\bar \lambda^e_0 N_0}{\bar \Lambda(N_0)},</span>
<span id="cb37-625"><a href="#cb37-625" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-626"><a href="#cb37-626" aria-hidden="true" tabindex="-1"></a>i.e. $(\bar K_1, \bar E_1)$ are distributed as independent random variables where $\bar K_1 \sim \mathcal U(<span class="sc">\{</span>1,\dots, N_0<span class="sc">\}</span>)$ and $\bar E_1$ such that </span>
<span id="cb37-627"><a href="#cb37-627" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-628"><a href="#cb37-628" aria-hidden="true" tabindex="-1"></a>    p_e := \mathbb{P}( \bar E_1 = e)</span>
<span id="cb37-629"><a href="#cb37-629" aria-hidden="true" tabindex="-1"></a>        = \frac{\bar \lambda^e_0 N_0}{\bar \Lambda(N_0)}.</span>
<span id="cb37-630"><a href="#cb37-630" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-631"><a href="#cb37-631" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$(\bar \Theta_\ell)_{\ell \in {\mathbb{N}}^*}$ are independent uniform random variables, with $\bar \Theta_\ell \sim \mathcal{U}([0,\bar \lambda^{\bar E_\ell}]).$</span>
<span id="cb37-632"><a href="#cb37-632" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-633"><a href="#cb37-633" aria-hidden="true" tabindex="-1"></a>Since the first event is the first jump of $N^0$, by @prp-thinning-vector and @alg-thinning2, the first event time $T_1$ is the first jump time $\bar T_\ell$ of $\bar Q^0$ such that $\bar \Theta_\ell \leq \lambda^{\bar E_\ell}_{\bar T_\ell}(I_{\bar K_\ell}, Z_0)$.</span>
<span id="cb37-634"><a href="#cb37-634" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-635"><a href="#cb37-635" aria-hidden="true" tabindex="-1"></a>At $T_1 =\bar T_{\ell}$, the event $\bar E_\ell$ occurs to the individual $I_{\bar K_\ell} = (\tau^b, \infty, x)$. For instance, if $\bar E_\ell =d$, a death/exit event occurs, so that $Z_{T_1} = Z_{0} + \delta_{(\tau^b, T_1, x)} - \delta_{I_{\bar K_\ell}}$ and $N_{T_1} = N_{0}$. If $\bar E_\ell =b$ or $en$, a birth or entry event occurs, so that $N_{T_1} = N_{0} + 1$, and a new individual $I_{N_0+1}$ is added to the population, chosen as described in @tbl-event-action. </span>
<span id="cb37-636"><a href="#cb37-636" aria-hidden="true" tabindex="-1"></a>Finally, if $\bar E_\ell=s$, a swap event occurs, the population size stays constant and $I_{\bar K_\ell}$ is replaced by an individual $I_{\bar K_\ell}'$, chosen as described in @tbl-event-action.</span>
<span id="cb37-637"><a href="#cb37-637" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-638"><a href="#cb37-638" aria-hidden="true" tabindex="-1"></a>The steps for simulating the first event in the population can be iterated in order to simulate the population. At the $k$th step, the same procedure is repeated to simulate the $k$th event, starting from a population $Z_{T_{k-1}}$ of size $N_{T_{k-1}}$.</span>
<span id="cb37-639"><a href="#cb37-639" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-640"><a href="#cb37-640" aria-hidden="true" tabindex="-1"></a><span class="in">```pseudocode</span></span>
<span id="cb37-641"><a href="#cb37-641" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: alg-interaction</span></span>
<span id="cb37-642"><a href="#cb37-642" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-indent-size: "1.2em"</span></span>
<span id="cb37-643"><a href="#cb37-643" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-comment-delimiter: "//"</span></span>
<span id="cb37-644"><a href="#cb37-644" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-line-number: true</span></span>
<span id="cb37-645"><a href="#cb37-645" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-line-number-punc: ":"</span></span>
<span id="cb37-646"><a href="#cb37-646" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-no-end: false</span></span>
<span id="cb37-647"><a href="#cb37-647" aria-hidden="true" tabindex="-1"></a><span class="in">#| pdf-placement: "htb!"</span></span>
<span id="cb37-648"><a href="#cb37-648" aria-hidden="true" tabindex="-1"></a><span class="in">#| pdf-line-number: true</span></span>
<span id="cb37-649"><a href="#cb37-649" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-650"><a href="#cb37-650" aria-hidden="true" tabindex="-1"></a><span class="in">\begin{algorithm}</span></span>
<span id="cb37-651"><a href="#cb37-651" aria-hidden="true" tabindex="-1"></a><span class="in">\caption{IBM simulation algorithm (without events of Poissonian intensity)}</span></span>
<span id="cb37-652"><a href="#cb37-652" aria-hidden="true" tabindex="-1"></a><span class="in">\begin{algorithmic}</span></span>
<span id="cb37-653"><a href="#cb37-653" aria-hidden="true" tabindex="-1"></a><span class="in">    \State \textbf{Input:} Initial population $Z_0$, horizon $T &gt; 0$, and events described by:</span></span>
<span id="cb37-654"><a href="#cb37-654" aria-hidden="true" tabindex="-1"></a><span class="in">        \State - Intensity functions and bounds $(\lambda^e, \bar \lambda^e)$ for $e \in \mathcal{E}$ and $(W^e, \bar W^e)$ for $e \in \mathcal{E}_W$ </span></span>
<span id="cb37-655"><a href="#cb37-655" aria-hidden="true" tabindex="-1"></a><span class="in">        \State - Event action functions $\phi^e(t, I)$ for $e \in \mathcal{E} \cup \mathcal{E}_W$ (see @tbl-event-action)</span></span>
<span id="cb37-656"><a href="#cb37-656" aria-hidden="true" tabindex="-1"></a><span class="in">    \State \textbf{Output:} Population $Z_T$</span></span>
<span id="cb37-657"><a href="#cb37-657" aria-hidden="true" tabindex="-1"></a><span class="in">    \State Initialization $T_0 \longleftarrow 0$, $\bar T_0 \longleftarrow 0$</span></span>
<span id="cb37-658"><a href="#cb37-658" aria-hidden="true" tabindex="-1"></a><span class="in">    \While{$T_k &lt; T$}</span></span>
<span id="cb37-659"><a href="#cb37-659" aria-hidden="true" tabindex="-1"></a><span class="in">        \Repeat</span></span>
<span id="cb37-660"><a href="#cb37-660" aria-hidden="true" tabindex="-1"></a><span class="in">            \State increment iterative variable $\ell \longleftarrow \ell+1$</span></span>
<span id="cb37-661"><a href="#cb37-661" aria-hidden="true" tabindex="-1"></a><span class="in">            \State compute next proposed time $\bar T_{\ell} \longleftarrow \bar T_{\ell-1} + \mathcal{E}\big(\bar \Lambda(N_{T_k}) \big)$</span></span>
<span id="cb37-662"><a href="#cb37-662" aria-hidden="true" tabindex="-1"></a><span class="in">            \State draw a proposed event $\bar E_\ell \sim \mathcal{U}\{p_e\}$ with $p_e = \frac{\bar \lambda^e \mathbf{1}_{e \in \mathcal{E}} + \bar W^e N_{T_k} \mathbf{1}_{e \in \mathcal{E}_W}}{\sum_{e \in \mathcal{E}} \bar \lambda^e + \sum_{e \in \mathcal{E}_W} \bar W^e N_{T_k}}$</span></span>
<span id="cb37-663"><a href="#cb37-663" aria-hidden="true" tabindex="-1"></a><span class="in">            \State draw an individual index $\bar K_\ell \sim \mathcal{U}(\{1,\dots,N_{T_k}\})$ </span></span>
<span id="cb37-664"><a href="#cb37-664" aria-hidden="true" tabindex="-1"></a><span class="in">            \State draw $\bar \Theta_\ell \sim \mathcal{U}([0, \bar \lambda^{\bar E_\ell}])$ if $\bar E_\ell \in \mathcal{E}$ or $\bar \Theta_\ell \sim \mathcal{U}([0, \bar W^{\bar E_\ell} N_{T_k}])$ if $\bar E_\ell \in \mathcal{E}_W$</span></span>
<span id="cb37-665"><a href="#cb37-665" aria-hidden="true" tabindex="-1"></a><span class="in">        \Until{accepted event $\bar \Theta_\ell \le \lambda^{\bar E_\ell}_{\bar T_\ell}(I_{\bar K_\ell},Z_{T_{k}})$}</span></span>
<span id="cb37-666"><a href="#cb37-666" aria-hidden="true" tabindex="-1"></a><span class="in">        \State increment iterative variable $k \longleftarrow k+1$ </span></span>
<span id="cb37-667"><a href="#cb37-667" aria-hidden="true" tabindex="-1"></a><span class="in">        \State record $(T_k, E_k, I_k) \longleftarrow (\bar T_{\ell}, \bar E_\ell,  I_{\bar K_\ell})$ as accepted time, event and individual</span></span>
<span id="cb37-668"><a href="#cb37-668" aria-hidden="true" tabindex="-1"></a><span class="in">        \State update the population $Z_{T_k} = Z_{T_{k-1}} + \phi^{E_k}(T_k, I_k)$</span></span>
<span id="cb37-669"><a href="#cb37-669" aria-hidden="true" tabindex="-1"></a><span class="in">    \EndWhile</span></span>
<span id="cb37-670"><a href="#cb37-670" aria-hidden="true" tabindex="-1"></a><span class="in">\end{algorithmic}</span></span>
<span id="cb37-671"><a href="#cb37-671" aria-hidden="true" tabindex="-1"></a><span class="in">\end{algorithm}</span></span>
<span id="cb37-672"><a href="#cb37-672" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb37-673"><a href="#cb37-673" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-674"><a href="#cb37-674" aria-hidden="true" tabindex="-1"></a>::: {#thm-interaction}</span>
<span id="cb37-675"><a href="#cb37-675" aria-hidden="true" tabindex="-1"></a>A population process $(Z_t)_{t \in <span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>}$ simulated by the @alg-interaction is an exact solution of the SDE @eq-sde-eq-Z.</span>
<span id="cb37-676"><a href="#cb37-676" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb37-677"><a href="#cb37-677" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-678"><a href="#cb37-678" aria-hidden="true" tabindex="-1"></a>The proof of @thm-interaction is detailed in the Appendix @sec-prf-thm-interaction.</span>
<span id="cb37-679"><a href="#cb37-679" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-680"><a href="#cb37-680" aria-hidden="true" tabindex="-1"></a>::: {#rem-remvoval-dead} </span>
<span id="cb37-681"><a href="#cb37-681" aria-hidden="true" tabindex="-1"></a>The population $Z_{T_k}$ includes dead/exited individuals before the event time $T_k$. Thus, $N_{T_k} &gt; N_{T_k}^a$ is greater than the number of alive individuals at time $T_k$. When a dead individual $I_{\bar K_l}$ is drawn from the population during the rejection/acceptance phase of the algorithm, the proposed event $(\bar T_{\ell}, \bar E_\ell,  I_{\bar K_\ell})$ is automatically rejected since the event intensity is $\lambda^{\bar E_\ell}_{T_\ell}(I_{\bar K_\ell}, Z_{T_k}) = 0$ (nothing can happen to a dead individual). </span>
<span id="cb37-682"><a href="#cb37-682" aria-hidden="true" tabindex="-1"></a>This can slow down the algorithm, especially when the proportion of dead/exited individuals in the population increases. However, the computational cost of keeping dead/exited individuals in the population is much lower than the cost of removing an individual from the population at each death/exit event, which is linear in the population size.</span>
<span id="cb37-683"><a href="#cb37-683" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-684"><a href="#cb37-684" aria-hidden="true" tabindex="-1"></a>Actually, dead/exited individuals are regularly removed from the population in the <span class="in">`IBMPopSim`</span> algorithm, in order to optimize the trade-off between having to many dead individuals and removing dead individuals from the population too often. The frequency at which dead individuals are "removed from the population" can be chosen by the user, as an optional argument of the main function <span class="in">`popsim`</span> (see details in @sec-simulation). </span>
<span id="cb37-685"><a href="#cb37-685" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb37-686"><a href="#cb37-686" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-687"><a href="#cb37-687" aria-hidden="true" tabindex="-1"></a>::: {#rem-sharp-bounds}</span>
<span id="cb37-688"><a href="#cb37-688" aria-hidden="true" tabindex="-1"></a>In practice, the bounds $\bar \lambda^e$ and $\bar W^e$ should be chosen as sharp as possible. It is easy to see that conditionally to $<span class="sc">\{</span>\bar E_\ell = e, \bar T_\ell = t, \bar K_\ell = l <span class="sc">\}</span>$ the probability of accepting the event is, depending if there are interactions,</span>
<span id="cb37-689"><a href="#cb37-689" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-690"><a href="#cb37-690" aria-hidden="true" tabindex="-1"></a>    \mathbb{P}\big(\bar \Theta_\ell \le \lambda^e_t(I_l,Z_{T_k})| \mathcal{F}_{T_k}\big)</span>
<span id="cb37-691"><a href="#cb37-691" aria-hidden="true" tabindex="-1"></a>    = \frac{\lambda^e(t, I_l)}{\bar \lambda^e} \mathbf{1}_{e \in \mathcal{E}} +  \frac{\sum_{j=1}^{N_{T_k}} W^e(t, I_l, I_j)}{\bar W^e N_{T_k}} \mathbf{1}_{e \in \mathcal{E}_W}.</span>
<span id="cb37-692"><a href="#cb37-692" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-693"><a href="#cb37-693" aria-hidden="true" tabindex="-1"></a>The sharper the bounds $\bar \lambda^e$ and $\bar W^e$ are, the higher is the acceptance rate. For even sharper bounds, an alternative is to define bounds $\bar \lambda^e(I_l)$ and $\bar W^e(I_l)$ depending on the individuals' characteristics. However, the algorithm is modified and the individual $I_l$ is not chosen uniformly in the population anymore. Due to the population size, this is way more costly than choosing uniform bounds, as explained in @rem-alternate-thinning.</span>
<span id="cb37-694"><a href="#cb37-694" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb37-695"><a href="#cb37-695" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-696"><a href="#cb37-696" aria-hidden="true" tabindex="-1"></a><span class="fu">## Simulation algorithm with randomization {#sec-simulation-randomized}</span></span>
<span id="cb37-697"><a href="#cb37-697" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-698"><a href="#cb37-698" aria-hidden="true" tabindex="-1"></a>Let $e \in \cal E_W$ be an event with interactions. In order to evaluate the individual intensity $\lambda^e_t (I,Z_t) = \sum_{j=1}^{N_t} W^e(t, I,I_j)$ one must compute $W^e(t, I_l, I_j)$ for all individuals in the population. This step can be computationally costly, especially for large populations. </span>
<span id="cb37-699"><a href="#cb37-699" aria-hidden="true" tabindex="-1"></a>One way to avoid this summation is to use randomization (see also&nbsp;@FouMel04 in a model without age). The randomization consists in replacing the summation by an evaluation of the interaction function $W^e$ using an individual $J$ drawn uniformly from the population.</span>
<span id="cb37-700"><a href="#cb37-700" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-701"><a href="#cb37-701" aria-hidden="true" tabindex="-1"></a>More precisely, if $J \sim \mathcal{U}(<span class="sc">\{</span>1, \dots, N_{T_k}<span class="sc">\}</span>)$ is independent of $\bar \Theta_\ell$, we have </span>
<span id="cb37-702"><a href="#cb37-702" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-703"><a href="#cb37-703" aria-hidden="true" tabindex="-1"></a>    \mathbb{P}\Big(\bar \Theta_\ell \le </span>
<span id="cb37-704"><a href="#cb37-704" aria-hidden="true" tabindex="-1"></a>    \sum_{j=1}^{N_{T_k}} W^e(t, I_l, I_j) | \mathcal{F}_{T_k} \Big)</span>
<span id="cb37-705"><a href="#cb37-705" aria-hidden="true" tabindex="-1"></a>    = \mathbb{P}\big(\bar \Theta_\ell </span>
<span id="cb37-706"><a href="#cb37-706" aria-hidden="true" tabindex="-1"></a>    \le N_{T_k} W^e(t, I_l, I_J) | \mathcal{F}_{T_k}\big).</span>
<span id="cb37-707"><a href="#cb37-707" aria-hidden="true" tabindex="-1"></a>$$ {#eq-randomized-event}</span>
<span id="cb37-708"><a href="#cb37-708" aria-hidden="true" tabindex="-1"></a>Equivalently, we can write this probability as $\mathbb{P}\big(\tilde \Theta_\ell \le W^e(t, I_l, I_J) \big)$ where $\tilde \Theta_\ell  = \frac{\bar \Theta_\ell}{N_{T_k}}\sim \mathcal{U}(<span class="co">[</span><span class="ot">0, \bar W^e</span><span class="co">]</span>)$ is independent of $J \sim \mathcal{U}(<span class="sc">\{</span>1, \dots, N_{T_k}<span class="sc">\}</span>)$.</span>
<span id="cb37-709"><a href="#cb37-709" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-710"><a href="#cb37-710" aria-hidden="true" tabindex="-1"></a>::: {#rem} </span>
<span id="cb37-711"><a href="#cb37-711" aria-hidden="true" tabindex="-1"></a>The efficiency of the randomization procedure increases with the population homogeneity. If the function $W^e$ varies little according to the individuals in the population, the randomization approach is very efficient in practice, especially when the population is large.</span>
<span id="cb37-712"><a href="#cb37-712" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb37-713"><a href="#cb37-713" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-714"><a href="#cb37-714" aria-hidden="true" tabindex="-1"></a>We now present the main algorithm implemented in the <span class="in">`popsim`</span> function of the <span class="in">`IBMPopSim`</span> package in the case where events arrive with individual intensities, but also with interactions (using randomization) and Poisson intensities. In this general case, $\bar \Lambda(n)$ is defined by @eq-def-bar-Lambda.</span>
<span id="cb37-715"><a href="#cb37-715" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-716"><a href="#cb37-716" aria-hidden="true" tabindex="-1"></a><span class="in">```pseudocode</span></span>
<span id="cb37-717"><a href="#cb37-717" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: alg-randomized</span></span>
<span id="cb37-718"><a href="#cb37-718" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-indent-size: "1.2em"</span></span>
<span id="cb37-719"><a href="#cb37-719" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-comment-delimiter: "//"</span></span>
<span id="cb37-720"><a href="#cb37-720" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-line-number: true</span></span>
<span id="cb37-721"><a href="#cb37-721" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-line-number-punc: ":"</span></span>
<span id="cb37-722"><a href="#cb37-722" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-no-end: false</span></span>
<span id="cb37-723"><a href="#cb37-723" aria-hidden="true" tabindex="-1"></a><span class="in">#| pdf-placement: "htb!"</span></span>
<span id="cb37-724"><a href="#cb37-724" aria-hidden="true" tabindex="-1"></a><span class="in">#| pdf-line-number: true</span></span>
<span id="cb37-725"><a href="#cb37-725" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-726"><a href="#cb37-726" aria-hidden="true" tabindex="-1"></a><span class="in">\begin{algorithm}</span></span>
<span id="cb37-727"><a href="#cb37-727" aria-hidden="true" tabindex="-1"></a><span class="in">\caption{Randomized IBM simulation algorithm.}</span></span>
<span id="cb37-728"><a href="#cb37-728" aria-hidden="true" tabindex="-1"></a><span class="in">\begin{algorithmic}</span></span>
<span id="cb37-729"><a href="#cb37-729" aria-hidden="true" tabindex="-1"></a><span class="in">    \State \textbf{Input:} Initial population $Z_0$, horizon $T &gt; 0$, and events described by</span></span>
<span id="cb37-730"><a href="#cb37-730" aria-hidden="true" tabindex="-1"></a><span class="in">    \State Intensity functions and bounds $(\lambda^e, \bar \lambda^e)$ for $e \in \mathcal{E}$, $(W^e, \bar W^e)$ for $e \in \mathcal{E}_W$ and $(\mu^e, \bar \mu^e)$ for $e \in \mathcal{P}$ </span></span>
<span id="cb37-731"><a href="#cb37-731" aria-hidden="true" tabindex="-1"></a><span class="in">    \State Event action functions $\phi^e(t, I)$ for $e \in \mathcal{E} \cup \mathcal{E}_W \cup \mathcal{P}$</span></span>
<span id="cb37-732"><a href="#cb37-732" aria-hidden="true" tabindex="-1"></a><span class="in">    \State \textbf{Output:} Population $Z_T$</span></span>
<span id="cb37-733"><a href="#cb37-733" aria-hidden="true" tabindex="-1"></a><span class="in">    \State Initialization $T_0 \longleftarrow 0$, $\bar T_0 \longleftarrow 0$ </span></span>
<span id="cb37-734"><a href="#cb37-734" aria-hidden="true" tabindex="-1"></a><span class="in">    \While{$T_k &lt; T$}</span></span>
<span id="cb37-735"><a href="#cb37-735" aria-hidden="true" tabindex="-1"></a><span class="in">        \Repeat</span></span>
<span id="cb37-736"><a href="#cb37-736" aria-hidden="true" tabindex="-1"></a><span class="in">            \State increment iterative variable $\ell \longleftarrow \ell+1$</span></span>
<span id="cb37-737"><a href="#cb37-737" aria-hidden="true" tabindex="-1"></a><span class="in">            \State compute next proposed time $\bar T_{\ell} \longleftarrow \bar T_{\ell-1} + \mathcal{E}\big(\bar \Lambda(N_{T_k}) \big)$</span></span>
<span id="cb37-738"><a href="#cb37-738" aria-hidden="true" tabindex="-1"></a><span class="in">            \State draw an individual index $\bar K_\ell \sim \mathcal{U}(\{1,\dots,N_{T_k}\})$</span></span>
<span id="cb37-739"><a href="#cb37-739" aria-hidden="true" tabindex="-1"></a><span class="in">            \State draw a proposed event $\bar E_\ell \sim \mathcal{U}\{p_e\}$ with $p_e = \frac{\bar \mu^e \mathbf{1}_{e \in \mathcal{P}} + \bar \lambda^e  N_{T_k}\mathbf{1}_{e \in \mathcal{E}} + \bar W^e (N_{T_k})^2 \mathbf{1}_{e \in \mathcal{E}_W}}{\bar \Lambda(N_{T_k})}$ </span></span>
<span id="cb37-740"><a href="#cb37-740" aria-hidden="true" tabindex="-1"></a><span class="in">            \If{$\bar E_\ell \in \mathcal{E}$ (without interaction)}</span></span>
<span id="cb37-741"><a href="#cb37-741" aria-hidden="true" tabindex="-1"></a><span class="in">                \State draw $\bar \Theta_\ell \sim \mathcal{U}\big([0, \bar \lambda^{\bar E_\ell}] \big)$ </span></span>
<span id="cb37-742"><a href="#cb37-742" aria-hidden="true" tabindex="-1"></a><span class="in">                \State \emph{accepted} $\longleftarrow \bar \Theta_\ell \le \lambda^{\bar E_\ell}(\bar T_\ell, I_{\bar K_\ell})$ </span></span>
<span id="cb37-743"><a href="#cb37-743" aria-hidden="true" tabindex="-1"></a><span class="in">            \EndIf</span></span>
<span id="cb37-744"><a href="#cb37-744" aria-hidden="true" tabindex="-1"></a><span class="in">            \If{$\bar E_\ell \in \mathcal{E}_W$ (with interaction)}</span></span>
<span id="cb37-745"><a href="#cb37-745" aria-hidden="true" tabindex="-1"></a><span class="in">                \State draw $(\bar \Theta_\ell, J_\ell) \sim  \mathcal{U}\big([0, \bar W^{\bar E_\ell}] \times \{1, \dots, N_{T_k}\} \big)$</span></span>
<span id="cb37-746"><a href="#cb37-746" aria-hidden="true" tabindex="-1"></a><span class="in">                \State \emph{accepted} $\longleftarrow \bar \Theta_\ell \le W^{\bar E_\ell}(\bar T_\ell, I_{\bar K_\ell}, I_{J_\ell})$</span></span>
<span id="cb37-747"><a href="#cb37-747" aria-hidden="true" tabindex="-1"></a><span class="in">            \EndIf</span></span>
<span id="cb37-748"><a href="#cb37-748" aria-hidden="true" tabindex="-1"></a><span class="in">            \If{$\bar E_\ell \in \mathcal{P}$ (Poissonian intensity)}</span></span>
<span id="cb37-749"><a href="#cb37-749" aria-hidden="true" tabindex="-1"></a><span class="in">                \State draw $\bar \Theta_\ell \sim \mathcal{U}\big([0, \bar \mu^{\bar E_\ell}] \big)$ </span></span>
<span id="cb37-750"><a href="#cb37-750" aria-hidden="true" tabindex="-1"></a><span class="in">                \State \emph{accepted} $\longleftarrow \bar \Theta_\ell \le \mu^{\bar E_\ell}(\bar T_\ell)$</span></span>
<span id="cb37-751"><a href="#cb37-751" aria-hidden="true" tabindex="-1"></a><span class="in">            \EndIf</span></span>
<span id="cb37-752"><a href="#cb37-752" aria-hidden="true" tabindex="-1"></a><span class="in">        \Until{accepted} </span></span>
<span id="cb37-753"><a href="#cb37-753" aria-hidden="true" tabindex="-1"></a><span class="in">        \State increment iterative variable $k \longleftarrow k+1$</span></span>
<span id="cb37-754"><a href="#cb37-754" aria-hidden="true" tabindex="-1"></a><span class="in">        \State record $(T_k, E_k, I_k) \longleftarrow (\bar T_{\ell}, \bar E_\ell, \bar I_{\bar K_\ell})$ as accepted time, event and individual</span></span>
<span id="cb37-755"><a href="#cb37-755" aria-hidden="true" tabindex="-1"></a><span class="in">        \State update the population $Z_{T_k} = Z_{T_{k-1}} + \phi^{E_k}(T_k, I_k)$</span></span>
<span id="cb37-756"><a href="#cb37-756" aria-hidden="true" tabindex="-1"></a><span class="in">    \EndWhile</span></span>
<span id="cb37-757"><a href="#cb37-757" aria-hidden="true" tabindex="-1"></a><span class="in">\end{algorithmic}</span></span>
<span id="cb37-758"><a href="#cb37-758" aria-hidden="true" tabindex="-1"></a><span class="in">\end{algorithm}</span></span>
<span id="cb37-759"><a href="#cb37-759" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb37-760"><a href="#cb37-760" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-761"><a href="#cb37-761" aria-hidden="true" tabindex="-1"></a>::: {#prp-randomized}</span>
<span id="cb37-762"><a href="#cb37-762" aria-hidden="true" tabindex="-1"></a>The population processes $(Z_t)_{t\in <span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>}$ simulated by the @alg-interaction and @alg-randomized have the same law.</span>
<span id="cb37-763"><a href="#cb37-763" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb37-764"><a href="#cb37-764" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-765"><a href="#cb37-765" aria-hidden="true" tabindex="-1"></a>::: {.proof}</span>
<span id="cb37-766"><a href="#cb37-766" aria-hidden="true" tabindex="-1"></a>The only difference between @alg-interaction and @alg-randomized is in the acceptance/rejection step of proposed events, in the presence of interactions.</span>
<span id="cb37-767"><a href="#cb37-767" aria-hidden="true" tabindex="-1"></a>In @alg-randomized , a proposed event $(\bar T_\ell, \bar E_\ell, \bar K_\ell)$, with $\bar E_l \in \mathcal{E}_W$ an event with interaction, is accepted as a true event in the population if</span>
<span id="cb37-768"><a href="#cb37-768" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-769"><a href="#cb37-769" aria-hidden="true" tabindex="-1"></a>    \bar \Theta_\ell \le W^{\bar E_\ell}(\bar T_\ell, I_{\bar K_\ell}, I_{\bar J_\ell}), \text{ with } (\bar \Theta_\ell, \bar J_\ell) \sim  \mathcal{U}\big(<span class="co">[</span><span class="ot">0, \bar W^{\bar E_\ell}</span><span class="co">]</span> \times <span class="sc">\{</span>1, \dots, N_{T_k}<span class="sc">\}</span> \big).</span>
<span id="cb37-770"><a href="#cb37-770" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-771"><a href="#cb37-771" aria-hidden="true" tabindex="-1"></a>By @eq-randomized-event, the probability of accepting this event is the same than in @alg-interaction, which achieves the proof.</span>
<span id="cb37-772"><a href="#cb37-772" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb37-773"><a href="#cb37-773" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-774"><a href="#cb37-774" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-775"><a href="#cb37-775" aria-hidden="true" tabindex="-1"></a><span class="fu"># Model creation and simulation with IBMPopSim {#sec-package}</span></span>
<span id="cb37-776"><a href="#cb37-776" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-777"><a href="#cb37-777" aria-hidden="true" tabindex="-1"></a>The use of the <span class="in">`IBMPopSim`</span> package is mainly done in two steps: a first model creation followed by the simulation of the population evolution. The creation of a model is itself based on two steps: the description of the population $Z_t$, as introduced in @sec-population, and the description of the events types, along with their associated intensities, as detailed in @sec-events and @sec-event-intensity.</span>
<span id="cb37-778"><a href="#cb37-778" aria-hidden="true" tabindex="-1"></a>A model is compiled by calling the <span class="in">`mk_model`</span> function, which internally uses a template mechanism to generate automatically the source code describing the model, which is subsequently compiled using the <span class="in">`Rcpp`</span> package to produce the object code.</span>
<span id="cb37-779"><a href="#cb37-779" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-780"><a href="#cb37-780" aria-hidden="true" tabindex="-1"></a>After the compilation of the model, the simulations are launched by calling the <span class="in">`popsim`</span> function. This function depends on the previously compiled model and simulates a random trajectory of the population evolution based on an initial population and on parameter values, which can change from a call to another.</span>
<span id="cb37-781"><a href="#cb37-781" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-782"><a href="#cb37-782" aria-hidden="true" tabindex="-1"></a>In this section, we take a closer look at each component of a model in <span class="in">`IBMPopSim`</span>. We also refer to the <span class="co">[</span><span class="ot">IBMPopSim website</span><span class="co">](https://daphnegiorgi.github.io/IBMPopSim/)</span> and to the <span class="in">`vignettes`</span> of the package for more details on the package and various examples of model creation.</span>
<span id="cb37-783"><a href="#cb37-783" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-784"><a href="#cb37-784" aria-hidden="true" tabindex="-1"></a><span class="fu">## Population {#sec-package-population}</span></span>
<span id="cb37-785"><a href="#cb37-785" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-786"><a href="#cb37-786" aria-hidden="true" tabindex="-1"></a>A population $Z$ is represented by an object of class <span class="in">`population`</span> containing a data frame where each row corresponds to an individual $I=(\tau^b, \tau^d, x)$, and which has at least two columns, <span class="in">`birth`</span> and <span class="in">`death`</span>, corresponding to the birth date $\tau^b$ and death/exit date $\tau^d$ ($\tau^d$ is set to <span class="in">`NA`</span> for alive individuals). The data frame can contain more than two columns if individuals are described by additional characteristics $x= (x_1,\dots x_n)$.</span>
<span id="cb37-787"><a href="#cb37-787" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-788"><a href="#cb37-788" aria-hidden="true" tabindex="-1"></a>If entry events can occur in the population, the population shall contain a characteristic named <span class="in">`entry`</span>. This can be done by setting the flag <span class="in">`entry=TRUE`</span> in the <span class="in">`population`</span> function, or by calling the <span class="in">`add_characteristic`</span> function on an existing population. During the simulation, the date at which an individual enters the population is automatically recorded in the variable <span class="in">`I.entry`</span>.</span>
<span id="cb37-789"><a href="#cb37-789" aria-hidden="true" tabindex="-1"></a>If exit events can occur, the population shall contain a characteristic named <span class="in">`out`</span>. This can be done by setting the flag <span class="in">`out=TRUE`</span> in the <span class="in">`population`</span> function, or by calling the <span class="in">`add_characteristic`</span> function. When an individual <span class="in">`I`</span> exits the population during the simulation, <span class="in">`I.out`</span> is set to <span class="in">`TRUE`</span> and its exit time is recorded as a "death" date.</span>
<span id="cb37-790"><a href="#cb37-790" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-791"><a href="#cb37-791" aria-hidden="true" tabindex="-1"></a>In the example below, individuals are described by their birth and death dates, as well a Boolean characteristics called male, and the <span class="in">`entry`</span> characteristic. For instance, the first individual is a female whose age at $t_0=0$ is $107$ and who was originally in the population.</span>
<span id="cb37-794"><a href="#cb37-794" aria-hidden="true" tabindex="-1"></a><span class="in">```{R}</span></span>
<span id="cb37-795"><a href="#cb37-795" aria-hidden="true" tabindex="-1"></a>pop_init <span class="ot">&lt;-</span> <span class="fu">population</span>(EW_pop_14<span class="sc">$</span>sample, <span class="at">entry=</span><span class="cn">TRUE</span>)</span>
<span id="cb37-796"><a href="#cb37-796" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(pop_init)</span>
<span id="cb37-797"><a href="#cb37-797" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb37-798"><a href="#cb37-798" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-799"><a href="#cb37-799" aria-hidden="true" tabindex="-1"></a><span class="fu">### Individual</span></span>
<span id="cb37-800"><a href="#cb37-800" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-801"><a href="#cb37-801" aria-hidden="true" tabindex="-1"></a>In the <span class="in">`C++`</span> model which is automatically generated and compiled, an individual <span class="in">`I`</span> is an object of an internal class containing some attributes (<span class="in">`birth_date`</span>, <span class="in">`death_date`</span> and the characteristics), and some methods including:</span>
<span id="cb37-802"><a href="#cb37-802" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-803"><a href="#cb37-803" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`I.age(t)`</span>: a <span class="in">`const`</span> method returning the age of an individual <span class="in">`I`</span> at time <span class="in">`t`</span>,</span>
<span id="cb37-804"><a href="#cb37-804" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`I.set_age(a, t)`</span>: a method to set the age <span class="in">`a`</span> at time <span class="in">`t`</span> of an individual <span class="in">`I`</span> (set <span class="in">`birth_date`</span> at <span class="in">`t-a`</span>),</span>
<span id="cb37-805"><a href="#cb37-805" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`I.is_dead(t)`</span>: a <span class="in">`const`</span> method returning <span class="in">`true`</span> if the individual <span class="in">`I`</span> is dead at time <span class="in">`t`</span>.</span>
<span id="cb37-806"><a href="#cb37-806" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-807"><a href="#cb37-807" aria-hidden="true" tabindex="-1"></a>::: {#rem-characteristics}</span>
<span id="cb37-808"><a href="#cb37-808" aria-hidden="true" tabindex="-1"></a>A characteristic $x_i$ must be of atomic type: <span class="in">`logical`</span>, <span class="in">`integer`</span>, <span class="in">`double`</span> or <span class="in">`character`</span>. The function <span class="in">`get_characteristic`</span> allows to easily get characteristics names and their types from a population data frame. We draw the attention to the fact that some names for characteristics are forbidden, or reserved to specific cases : this is the case for <span class="in">`birth`</span>, <span class="in">`death`</span>, <span class="in">`entry`</span>, <span class="in">`out`</span>, <span class="in">`id`</span>.</span>
<span id="cb37-809"><a href="#cb37-809" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb37-810"><a href="#cb37-810" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-811"><a href="#cb37-811" aria-hidden="true" tabindex="-1"></a><span class="fu">## Events {#sec-package-events}</span></span>
<span id="cb37-812"><a href="#cb37-812" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-813"><a href="#cb37-813" aria-hidden="true" tabindex="-1"></a>The most important step of the model creation is the events creation. The call to the function creating an event is of form</span>
<span id="cb37-816"><a href="#cb37-816" aria-hidden="true" tabindex="-1"></a><span class="in">```{R}</span></span>
<span id="cb37-817"><a href="#cb37-817" aria-hidden="true" tabindex="-1"></a><span class="co">#| eval: false </span></span>
<span id="cb37-818"><a href="#cb37-818" aria-hidden="true" tabindex="-1"></a><span class="fu">mk_event_CLASS</span>(<span class="at">type=</span><span class="st">"TYPE"</span>, <span class="at">name=</span><span class="st">"NAME"</span>, ...)</span>
<span id="cb37-819"><a href="#cb37-819" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb37-820"><a href="#cb37-820" aria-hidden="true" tabindex="-1"></a>where <span class="in">`CLASS`</span> is replaced by the class of the event intensity, described in @sec-event-intensity , and <span class="in">`type`</span> corresponds to the event type, described in Section&nbsp;@sec-events.</span>
<span id="cb37-821"><a href="#cb37-821" aria-hidden="true" tabindex="-1"></a>@tbl-intensity-classes and @tbl-event-types summarize the different possible choices for intensity classes and types of event. The optional argument <span class="in">`name`</span> gives a name to the event. If not specified, the name of the event is its type, for instance <span class="in">`death`</span>. However, a name must be specified if the model is composed of several events with the same type (for instance when there are multiple death events corresponding to different causes of death). The other arguments depend on the intensity class and on the event type.</span>
<span id="cb37-822"><a href="#cb37-822" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-823"><a href="#cb37-823" aria-hidden="true" tabindex="-1"></a>::: {#tbl-panel layout-ncol=2}</span>
<span id="cb37-824"><a href="#cb37-824" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-825"><a href="#cb37-825" aria-hidden="true" tabindex="-1"></a>Intensity class         Set               <span class="in">`CLASS`</span></span>
<span id="cb37-826"><a href="#cb37-826" aria-hidden="true" tabindex="-1"></a>----------------------- ----------------- -------------------------</span>
<span id="cb37-827"><a href="#cb37-827" aria-hidden="true" tabindex="-1"></a>Individual              $\mathcal{E}$     <span class="in">`individual`</span></span>
<span id="cb37-828"><a href="#cb37-828" aria-hidden="true" tabindex="-1"></a>Interaction             $\mathcal{E}_W$   <span class="in">`interaction`</span></span>
<span id="cb37-829"><a href="#cb37-829" aria-hidden="true" tabindex="-1"></a>Poisson                 $\mathcal{P}$     <span class="in">`poisson`</span></span>
<span id="cb37-830"><a href="#cb37-830" aria-hidden="true" tabindex="-1"></a>Inhomogeneous Poisson   $\mathcal{P}$     <span class="in">`inhomogeneous_poisson`</span></span>
<span id="cb37-831"><a href="#cb37-831" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-832"><a href="#cb37-832" aria-hidden="true" tabindex="-1"></a>: Intensity Classes {#tbl-intensity-classes}</span>
<span id="cb37-833"><a href="#cb37-833" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-834"><a href="#cb37-834" aria-hidden="true" tabindex="-1"></a>Event type   <span class="in">`TYPE`</span></span>
<span id="cb37-835"><a href="#cb37-835" aria-hidden="true" tabindex="-1"></a>------------ ---------</span>
<span id="cb37-836"><a href="#cb37-836" aria-hidden="true" tabindex="-1"></a>Birth        <span class="in">`birth`</span></span>
<span id="cb37-837"><a href="#cb37-837" aria-hidden="true" tabindex="-1"></a>Death        <span class="in">`death`</span></span>
<span id="cb37-838"><a href="#cb37-838" aria-hidden="true" tabindex="-1"></a>Entry        <span class="in">`entry`</span></span>
<span id="cb37-839"><a href="#cb37-839" aria-hidden="true" tabindex="-1"></a>Exit         <span class="in">`exit`</span></span>
<span id="cb37-840"><a href="#cb37-840" aria-hidden="true" tabindex="-1"></a>Swap         <span class="in">`swap`</span></span>
<span id="cb37-841"><a href="#cb37-841" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-842"><a href="#cb37-842" aria-hidden="true" tabindex="-1"></a>: Event Types {#tbl-event-types}</span>
<span id="cb37-843"><a href="#cb37-843" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-844"><a href="#cb37-844" aria-hidden="true" tabindex="-1"></a>Choices of <span class="in">`CLASS`</span> and <span class="in">`TYPE`</span> arguments for an event creation.</span>
<span id="cb37-845"><a href="#cb37-845" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb37-846"><a href="#cb37-846" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-847"><a href="#cb37-847" aria-hidden="true" tabindex="-1"></a>The intensity function and the kernel of an event are defined through arguments of the function <span class="in">`mk_event_CLASS`</span>. These arguments are strings composed of few lines of code. Since the model is compiled using <span class="in">`Rcpp`</span>, the code should be written in <span class="in">`C++`</span>. However, thanks to the functions/variables of the package, even the non-experienced <span class="in">`C++`</span> user can define a model quite easily. </span>
<span id="cb37-848"><a href="#cb37-848" aria-hidden="true" tabindex="-1"></a>To facilitate the implementation, the user can also define a list of **model parameters**, which can be used in the event and intensity definitions. These parameters are stored in a named list and can be of various types: atomic type, numeric vector or matrix, predefined function of one variable (<span class="in">`stepfun`</span>, <span class="in">`linfun`</span>, <span class="in">`gompertz`</span>, <span class="in">`weibull`</span>, <span class="in">`piecewise_x`</span>), piecewise functions of two variables (<span class="in">`piecewise_xy`</span>). </span>
<span id="cb37-849"><a href="#cb37-849" aria-hidden="true" tabindex="-1"></a>We refer to the <span class="in">`vignette(IBMPopSim_cpp)`</span> for more details on parameters types and basic <span class="in">`C++`</span> tools. Another advantage of the model parameters is that their value can be modified from a simulation to another without changing the model.</span>
<span id="cb37-850"><a href="#cb37-850" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-851"><a href="#cb37-851" aria-hidden="true" tabindex="-1"></a><span class="fu">### Intensities</span></span>
<span id="cb37-852"><a href="#cb37-852" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-853"><a href="#cb37-853" aria-hidden="true" tabindex="-1"></a>In <span class="in">`IBMPopSim`</span>, the intensity of an event can belong to three classes @sec-event-intensity: individual intensities without interaction between individuals, corresponding to events $e\in\mathcal{E}$, individual intensities with interaction, corresponding to events $e\in\mathcal{E}_W$, and Poisson intensities (homogeneous and inhomogeneous), corresponding to events $e\in\mathcal{P}$.</span>
<span id="cb37-854"><a href="#cb37-854" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-855"><a href="#cb37-855" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Event creation with individual intensity {.unnumbered}</span></span>
<span id="cb37-856"><a href="#cb37-856" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-857"><a href="#cb37-857" aria-hidden="true" tabindex="-1"></a>An event $e\in \mathcal{E}$ (see @eq-intensity-no-interaction) has an intensity of the form $\lambda^e(t, I)$ which depends only on the individual <span class="in">`I`</span> and time. Events with such intensity are created using the function</span>
<span id="cb37-860"><a href="#cb37-860" aria-hidden="true" tabindex="-1"></a><span class="in">```{R}</span></span>
<span id="cb37-861"><a href="#cb37-861" aria-hidden="true" tabindex="-1"></a><span class="co">#| eval: false</span></span>
<span id="cb37-862"><a href="#cb37-862" aria-hidden="true" tabindex="-1"></a><span class="fu">mk_event_individual</span>(<span class="at">type =</span> <span class="st">"TYPE"</span>, </span>
<span id="cb37-863"><a href="#cb37-863" aria-hidden="true" tabindex="-1"></a>                    <span class="at">name =</span> <span class="st">"NAME"</span>,</span>
<span id="cb37-864"><a href="#cb37-864" aria-hidden="true" tabindex="-1"></a>                    <span class="at">intensity_code =</span> <span class="st">"INTENSITY"</span>, ...)</span>
<span id="cb37-865"><a href="#cb37-865" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb37-866"><a href="#cb37-866" aria-hidden="true" tabindex="-1"></a>The <span class="in">`intensity_code`</span> argument is a character string containing few lines of <span class="in">`C++`</span> code describing the intensity function $\lambda^e(t, I)$. The intensity value has to be stored in a variable called <span class="in">`result`</span> and the available variables for the intensity code are given in @tbl-intensity-variables.</span>
<span id="cb37-867"><a href="#cb37-867" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-868"><a href="#cb37-868" aria-hidden="true" tabindex="-1"></a>::: {#tbl-intensity-variables}</span>
<span id="cb37-869"><a href="#cb37-869" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-870"><a href="#cb37-870" aria-hidden="true" tabindex="-1"></a>Variable           Description</span>
<span id="cb37-871"><a href="#cb37-871" aria-hidden="true" tabindex="-1"></a>------------------ -------------------------------------------------------------</span>
<span id="cb37-872"><a href="#cb37-872" aria-hidden="true" tabindex="-1"></a>Variable           Description</span>
<span id="cb37-873"><a href="#cb37-873" aria-hidden="true" tabindex="-1"></a><span class="in">`I`</span>                Current individual</span>
<span id="cb37-874"><a href="#cb37-874" aria-hidden="true" tabindex="-1"></a><span class="in">`J`</span>                Another individual in the population (only for interaction)</span>
<span id="cb37-875"><a href="#cb37-875" aria-hidden="true" tabindex="-1"></a><span class="in">`t`</span>                Current time</span>
<span id="cb37-876"><a href="#cb37-876" aria-hidden="true" tabindex="-1"></a>Model parameters   Depends on the model</span>
<span id="cb37-877"><a href="#cb37-877" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-878"><a href="#cb37-878" aria-hidden="true" tabindex="-1"></a><span class="in">`C++`</span> variables available for intensity code</span>
<span id="cb37-879"><a href="#cb37-879" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb37-880"><a href="#cb37-880" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-881"><a href="#cb37-881" aria-hidden="true" tabindex="-1"></a>For instance, the intensity code below corresponds to an individual death intensity $\lambda^d(t,I)$ equal to $d_1(a(I,t)) = \alpha_1 \exp(\beta_1 a(I,t))$ for males and $d_2(a(I,t)) = \alpha_2 \exp(\beta_2 a(I,t))$ for females, where $a(I,t)=t-\tau^b$ is the age of the individual $I=(\tau^b, \tau^d,x)$ at time $t$. </span>
<span id="cb37-882"><a href="#cb37-882" aria-hidden="true" tabindex="-1"></a>In this case, the intensity function depends on the individuals' age, gender, and on the model parameters $\alpha = (\alpha_1, \alpha_2)$ and $\beta = (\beta_1, \beta_2)$.</span>
<span id="cb37-885"><a href="#cb37-885" aria-hidden="true" tabindex="-1"></a><span class="in">```{R}</span></span>
<span id="cb37-886"><a href="#cb37-886" aria-hidden="true" tabindex="-1"></a><span class="co">#| eval: false</span></span>
<span id="cb37-887"><a href="#cb37-887" aria-hidden="true" tabindex="-1"></a>death_intensity <span class="ot">&lt;-</span> <span class="st">"</span></span>
<span id="cb37-888"><a href="#cb37-888" aria-hidden="true" tabindex="-1"></a><span class="st">    if (I.male) result = alpha_1 * exp(beta_1 * I.age(t));</span></span>
<span id="cb37-889"><a href="#cb37-889" aria-hidden="true" tabindex="-1"></a><span class="st">    else result = alpha_2 * exp(beta_2 * I.age(t));</span></span>
<span id="cb37-890"><a href="#cb37-890" aria-hidden="true" tabindex="-1"></a><span class="st">"</span></span>
<span id="cb37-891"><a href="#cb37-891" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb37-892"><a href="#cb37-892" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-893"><a href="#cb37-893" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Event creation with interaction intensity {.unnumbered}</span></span>
<span id="cb37-894"><a href="#cb37-894" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb37-895"><a href="#cb37-895" aria-hidden="true" tabindex="-1"></a>An event $e\in \mathcal{E}_W$ is an event which occurs to an individual at a frequency which is the result of interactions with other members of the population (see @eq-intensity-interaction), and which can be written as $\lambda^e_t(I, Z_t)=\sum_{J\in Z_t} W^e(t, I, J)$ where $W^e(t, I, J)$ is the intensity of the interaction between individual $I$ and individual $J$.</span>
<span id="cb37-896"><a href="#cb37-896" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-897"><a href="#cb37-897" aria-hidden="true" tabindex="-1"></a>An event $e\in \mathcal{E}_W$ with such intensity is created by calling the function</span>
<span id="cb37-900"><a href="#cb37-900" aria-hidden="true" tabindex="-1"></a><span class="in">```{R}</span></span>
<span id="cb37-901"><a href="#cb37-901" aria-hidden="true" tabindex="-1"></a><span class="co">#| eval: false</span></span>
<span id="cb37-902"><a href="#cb37-902" aria-hidden="true" tabindex="-1"></a><span class="fu">mk_event_interaction</span>(<span class="at">type =</span> <span class="st">"TYPE"</span>,</span>
<span id="cb37-903"><a href="#cb37-903" aria-hidden="true" tabindex="-1"></a>                     <span class="at">name =</span> <span class="st">"NAME"</span>,</span>
<span id="cb37-904"><a href="#cb37-904" aria-hidden="true" tabindex="-1"></a>                     <span class="at">interaction_code =</span> <span class="st">"INTERACTION_CODE"</span>,</span>
<span id="cb37-905"><a href="#cb37-905" aria-hidden="true" tabindex="-1"></a>                     <span class="at">interaction_type =</span> <span class="st">"random"</span>, ...)</span>
<span id="cb37-906"><a href="#cb37-906" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb37-907"><a href="#cb37-907" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-908"><a href="#cb37-908" aria-hidden="true" tabindex="-1"></a>The <span class="in">`interaction_code`</span> argument contains few lines of <span class="in">`C++`</span> code describing the interaction function $W^e(t, I, J)$. The interaction function value has to be stored in a variable called <span class="in">`result`</span> and the available variables for the intensity code are given in @tbl-intensity-variables. For example, if we set</span>
<span id="cb37-911"><a href="#cb37-911" aria-hidden="true" tabindex="-1"></a><span class="in">```{R}</span></span>
<span id="cb37-912"><a href="#cb37-912" aria-hidden="true" tabindex="-1"></a><span class="co">#| eval: false</span></span>
<span id="cb37-913"><a href="#cb37-913" aria-hidden="true" tabindex="-1"></a>death_interaction_code <span class="ot">&lt;-</span> <span class="st">"result = max(J.size - I.size, 0.);"</span></span>
<span id="cb37-914"><a href="#cb37-914" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb37-915"><a href="#cb37-915" aria-hidden="true" tabindex="-1"></a>the death intensity of an individual <span class="in">`I`</span> is the result of the competition between individuals, depending on a characteristic named <span class="in">`size`</span>, as defined in @eq-ex-interaction. </span>
<span id="cb37-916"><a href="#cb37-916" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-917"><a href="#cb37-917" aria-hidden="true" tabindex="-1"></a>The argument <span class="in">`interaction_type`</span>, set by default at <span class="in">`random`</span>, is the algorithm choice for simulating the model. When <span class="in">`interaction_type=full`</span>, the simulation follows @alg-interaction, <span class="in">`interaction_type=random`</span> it follows @alg-randomized.</span>
<span id="cb37-918"><a href="#cb37-918" aria-hidden="true" tabindex="-1"></a>In most cases, the <span class="in">`random`</span> algorithm is much faster than the <span class="in">`full`</span> algorithm, as we illustrate for instance in @sec-example-interaction , where we observe the gain of a factor of 40 between the two algorithms, on a set of standard parameters. This allows in particular to explore parameter sets that give larger population sizes, without reaching computation times that explode.</span>
<span id="cb37-919"><a href="#cb37-919" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-920"><a href="#cb37-920" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Events creation with Poisson and Inhomogeneous Poisson intensity {.unnumbered}</span></span>
<span id="cb37-921"><a href="#cb37-921" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-922"><a href="#cb37-922" aria-hidden="true" tabindex="-1"></a>For events $e\in\mathcal{P}$ with an intensity $\mu^e(t)$ which does not depend on the population, the event intensity is of class <span class="in">`inhomogeneous_poisson`</span> or <span class="in">`poisson`</span> depending on whether or not the intensity depends on time (in the second case the intensity is constant).</span>
<span id="cb37-923"><a href="#cb37-923" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-924"><a href="#cb37-924" aria-hidden="true" tabindex="-1"></a>For Poisson (constant) intensities the events are created with the function</span>
<span id="cb37-927"><a href="#cb37-927" aria-hidden="true" tabindex="-1"></a><span class="in">```{R}</span></span>
<span id="cb37-928"><a href="#cb37-928" aria-hidden="true" tabindex="-1"></a><span class="co">#| eval: false</span></span>
<span id="cb37-929"><a href="#cb37-929" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb37-930"><a href="#cb37-930" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-931"><a href="#cb37-931" aria-hidden="true" tabindex="-1"></a>The following example creates a death event, where individuals die at a constant intensity <span class="in">`lambda`</span> (which has to be in the list of model parameters):</span>
<span id="cb37-932"><a href="#cb37-932" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-933"><a href="#cb37-933" aria-hidden="true" tabindex="-1"></a>TODO</span>
<span id="cb37-934"><a href="#cb37-934" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-935"><a href="#cb37-935" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-936"><a href="#cb37-936" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-937"><a href="#cb37-937" aria-hidden="true" tabindex="-1"></a><span class="fu"># Insurance portfolio {#sec-insurance-portfolio}</span></span>
<span id="cb37-938"><a href="#cb37-938" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-939"><a href="#cb37-939" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-940"><a href="#cb37-940" aria-hidden="true" tabindex="-1"></a>This section provides an example of how to use the <span class="in">`IBMPopSim`</span> package</span>
<span id="cb37-941"><a href="#cb37-941" aria-hidden="true" tabindex="-1"></a>to simulate a heterogeneous life insurance portfolio (see</span>
<span id="cb37-942"><a href="#cb37-942" aria-hidden="true" tabindex="-1"></a>also&nbsp;<span class="in">`vignette(IBMPopSim_insurance_portfolio)`</span>).</span>
<span id="cb37-943"><a href="#cb37-943" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-944"><a href="#cb37-944" aria-hidden="true" tabindex="-1"></a>We consider an insurance portfolio consisting of male policyholders, of</span>
<span id="cb37-945"><a href="#cb37-945" aria-hidden="true" tabindex="-1"></a>age greater than 65. These policyholders are characterized by their age,</span>
<span id="cb37-946"><a href="#cb37-946" aria-hidden="true" tabindex="-1"></a>assumed to be less than $a_{max} = 110$, and risk class</span>
<span id="cb37-947"><a href="#cb37-947" aria-hidden="true" tabindex="-1"></a>$x\in \mathcal X =<span class="sc">\{</span>1,2<span class="sc">\}</span>$.</span>
<span id="cb37-948"><a href="#cb37-948" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-949"><a href="#cb37-949" aria-hidden="true" tabindex="-1"></a>**Entries in the portfolio** New policyholders enter the population at a</span>
<span id="cb37-950"><a href="#cb37-950" aria-hidden="true" tabindex="-1"></a>constant Poisson rate $\mu^{en}=\lambda$, which means that on average,</span>
<span id="cb37-951"><a href="#cb37-951" aria-hidden="true" tabindex="-1"></a>$\lambda$ individuals enter the portfolio each year. A new individual</span>
<span id="cb37-952"><a href="#cb37-952" aria-hidden="true" tabindex="-1"></a>enters the population at an age a that is uniformly distributed between</span>
<span id="cb37-953"><a href="#cb37-953" aria-hidden="true" tabindex="-1"></a>65 and 70, and is in risk class 1 with probability $p$.</span>
<span id="cb37-954"><a href="#cb37-954" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-955"><a href="#cb37-955" aria-hidden="true" tabindex="-1"></a>**Death events** A baseline age and time specific death rate is first</span>
<span id="cb37-956"><a href="#cb37-956" aria-hidden="true" tabindex="-1"></a>calibrated on "England and Wales (EW)" males mortality historic</span>
<span id="cb37-957"><a href="#cb37-957" aria-hidden="true" tabindex="-1"></a>data<span class="ot">[^1]</span>, and projected for 30 years using the Lee-Carter model with the</span>
<span id="cb37-958"><a href="#cb37-958" aria-hidden="true" tabindex="-1"></a>package <span class="in">`StMoMo`</span> (see&nbsp;<span class="co">[</span><span class="ot">@stmomo</span><span class="co">]</span>). The forecasted baseline death</span>
<span id="cb37-959"><a href="#cb37-959" aria-hidden="true" tabindex="-1"></a>intensity is denoted by $d(t,a)$, defined by:</span>
<span id="cb37-960"><a href="#cb37-960" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-961"><a href="#cb37-961" aria-hidden="true" tabindex="-1"></a>d(t,a) = \sum_{k=0}^{29}\mathbf{1}_{\{k\leq t &lt; k+1\}} d_k(a), \quad \forall \; t\in [0,30] \text{ and } a \in [65, a_{max}],</span>
<span id="cb37-962"><a href="#cb37-962" aria-hidden="true" tabindex="-1"></a>$$ {#eq-insurance-baseline}</span>
<span id="cb37-963"><a href="#cb37-963" aria-hidden="true" tabindex="-1"></a>with $d_k(a)$ the point estimate of the forecasted mortality rate for</span>
<span id="cb37-964"><a href="#cb37-964" aria-hidden="true" tabindex="-1"></a>age $a$ and year $k$.\</span>
<span id="cb37-965"><a href="#cb37-965" aria-hidden="true" tabindex="-1"></a>Individuals in risk class 1 are assumed to have mortality rates that are</span>
<span id="cb37-966"><a href="#cb37-966" aria-hidden="true" tabindex="-1"></a>20% higher than the baseline mortality (for instance, the risk class</span>
<span id="cb37-967"><a href="#cb37-967" aria-hidden="true" tabindex="-1"></a>could refer to smokers), while individuals in risk class 2 are assumed</span>
<span id="cb37-968"><a href="#cb37-968" aria-hidden="true" tabindex="-1"></a>to have mortality rates that are 20% lower than the baseline (non</span>
<span id="cb37-969"><a href="#cb37-969" aria-hidden="true" tabindex="-1"></a>smokers). The death intensity of an individual $I= (\tau_b, \infty, x)$,</span>
<span id="cb37-970"><a href="#cb37-970" aria-hidden="true" tabindex="-1"></a>of age $a(I,t) = t - \tau_b$ at time $t$ and in risk class</span>
<span id="cb37-971"><a href="#cb37-971" aria-hidden="true" tabindex="-1"></a>$x \in <span class="sc">\{</span>1, 2<span class="sc">\}</span>$ is thus the function $$\label{eq-insurance-deathrates}</span>
<span id="cb37-972"><a href="#cb37-972" aria-hidden="true" tabindex="-1"></a>\lambda^d(t,I) = \alpha_x d(t,a(I,t)), \quad \alpha_1 = 1.2, \quad \alpha_2 = 0.8.$$</span>
<span id="cb37-973"><a href="#cb37-973" aria-hidden="true" tabindex="-1"></a>In particular, the death intensity verifies Assumption TODO</span>
<span id="cb37-974"><a href="#cb37-974" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">2</span><span class="co">](#AssumptionIntensity1)</span>{reference-type="ref"</span>
<span id="cb37-975"><a href="#cb37-975" aria-hidden="true" tabindex="-1"></a>reference="AssumptionIntensity1"} since:</span>
<span id="cb37-976"><a href="#cb37-976" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-977"><a href="#cb37-977" aria-hidden="true" tabindex="-1"></a>\lambda^d(t,I) \leq \bar d : = \alpha_1 \sup_{t \in <span class="co">[</span><span class="ot">0,30</span><span class="co">]</span>} d(t,a_{max}).</span>
<span id="cb37-978"><a href="#cb37-978" aria-hidden="true" tabindex="-1"></a>$$ {#eq-insurance-bound-deathrates}</span>
<span id="cb37-979"><a href="#cb37-979" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-980"><a href="#cb37-980" aria-hidden="true" tabindex="-1"></a>**Exits from the portfolio** Individuals exit the portfolio at a</span>
<span id="cb37-981"><a href="#cb37-981" aria-hidden="true" tabindex="-1"></a>constant (individual) rate $\lambda^{ex}(t,I) = \mu^{i}$ only depending</span>
<span id="cb37-982"><a href="#cb37-982" aria-hidden="true" tabindex="-1"></a>on their risk class $i\in <span class="sc">\{</span>1,2<span class="sc">\}</span>$.</span>
<span id="cb37-983"><a href="#cb37-983" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-984"><a href="#cb37-984" aria-hidden="true" tabindex="-1"></a><span class="fu">## Population {#insurance-population}</span></span>
<span id="cb37-985"><a href="#cb37-985" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-986"><a href="#cb37-986" aria-hidden="true" tabindex="-1"></a>We start with an initial population of $30\,000$ males of age 65,</span>
<span id="cb37-987"><a href="#cb37-987" aria-hidden="true" tabindex="-1"></a>distributed uniformly in each risk class. The population data frame has</span>
<span id="cb37-988"><a href="#cb37-988" aria-hidden="true" tabindex="-1"></a>thus the two (mandatory) columns <span class="in">`birth`</span> (here the initial time is</span>
<span id="cb37-989"><a href="#cb37-989" aria-hidden="true" tabindex="-1"></a>$t_0=0$) and <span class="in">`death`</span> (<span class="in">`NA`</span> if alive), and an additional column</span>
<span id="cb37-990"><a href="#cb37-990" aria-hidden="true" tabindex="-1"></a><span class="in">`risk_cls`</span> corresponding to the policyholders risk class. Since there</span>
<span id="cb37-991"><a href="#cb37-991" aria-hidden="true" tabindex="-1"></a>are entry and exit events, the <span class="in">`entry`</span> and <span class="in">`out`</span> flags of the population</span>
<span id="cb37-992"><a href="#cb37-992" aria-hidden="true" tabindex="-1"></a>constructor are set to <span class="in">`TRUE`</span>.</span>
<span id="cb37-993"><a href="#cb37-993" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-996"><a href="#cb37-996" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb37-997"><a href="#cb37-997" aria-hidden="true" tabindex="-1"></a>N <span class="ot">&lt;-</span> <span class="dv">30000</span></span>
<span id="cb37-998"><a href="#cb37-998" aria-hidden="true" tabindex="-1"></a>pop_df <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="st">"birth"</span> <span class="ot">=</span> <span class="fu">rep</span>(<span class="sc">-</span><span class="dv">65</span>,N), <span class="st">"death"</span> <span class="ot">=</span> <span class="fu">rep</span>(<span class="cn">NA</span>,N),</span>
<span id="cb37-999"><a href="#cb37-999" aria-hidden="true" tabindex="-1"></a>                     <span class="st">"risk_cls"</span> <span class="ot">=</span> <span class="fu">rep</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>,<span class="at">each=</span>N<span class="sc">/</span><span class="dv">2</span>))</span>
<span id="cb37-1000"><a href="#cb37-1000" aria-hidden="true" tabindex="-1"></a>pop_init <span class="ot">&lt;-</span> <span class="fu">population</span>(pop_df, <span class="at">entry=</span><span class="cn">TRUE</span>, <span class="at">out=</span><span class="cn">TRUE</span>)</span>
<span id="cb37-1001"><a href="#cb37-1001" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb37-1002"><a href="#cb37-1002" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1003"><a href="#cb37-1003" aria-hidden="true" tabindex="-1"></a><span class="fu">## Events {#insurance-events}</span></span>
<span id="cb37-1004"><a href="#cb37-1004" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1005"><a href="#cb37-1005" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Entry events</span></span>
<span id="cb37-1006"><a href="#cb37-1006" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1007"><a href="#cb37-1007" aria-hidden="true" tabindex="-1"></a>The age of the new individual is determined by the <span class="in">`kernel_code`</span></span>
<span id="cb37-1008"><a href="#cb37-1008" aria-hidden="true" tabindex="-1"></a>argument in the <span class="in">`mk_event_poisson`</span> function.</span>
<span id="cb37-1009"><a href="#cb37-1009" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1012"><a href="#cb37-1012" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb37-1013"><a href="#cb37-1013" aria-hidden="true" tabindex="-1"></a>entry_params <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="st">"lambda"</span> <span class="ot">=</span> <span class="dv">30000</span>, <span class="st">"p"</span> <span class="ot">=</span> <span class="fl">0.5</span>)</span>
<span id="cb37-1014"><a href="#cb37-1014" aria-hidden="true" tabindex="-1"></a>entry_event <span class="ot">&lt;-</span> <span class="fu">mk_event_poisson</span>(</span>
<span id="cb37-1015"><a href="#cb37-1015" aria-hidden="true" tabindex="-1"></a>    <span class="at">type =</span> <span class="st">"entry"</span>,</span>
<span id="cb37-1016"><a href="#cb37-1016" aria-hidden="true" tabindex="-1"></a>    <span class="at">intensity =</span> <span class="st">"lambda"</span>,</span>
<span id="cb37-1017"><a href="#cb37-1017" aria-hidden="true" tabindex="-1"></a>    <span class="at">kernel_code =</span> <span class="st">"if (CUnif() &lt; p) newI.risk_cls =1;</span></span>
<span id="cb37-1018"><a href="#cb37-1018" aria-hidden="true" tabindex="-1"></a><span class="st">                   else newI.risk_cls= 2;</span></span>
<span id="cb37-1019"><a href="#cb37-1019" aria-hidden="true" tabindex="-1"></a><span class="st">                   double a = CUnif(65, 70);</span></span>
<span id="cb37-1020"><a href="#cb37-1020" aria-hidden="true" tabindex="-1"></a><span class="st">                   newI.set_age(a, t);"</span>)</span>
<span id="cb37-1021"><a href="#cb37-1021" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb37-1022"><a href="#cb37-1022" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1023"><a href="#cb37-1023" aria-hidden="true" tabindex="-1"></a>Note that the variables <span class="in">`newI`</span> and <span class="in">`t`</span>, as well as the function</span>
<span id="cb37-1024"><a href="#cb37-1024" aria-hidden="true" tabindex="-1"></a><span class="in">`CUnif()`</span>, are implicitly defined and usable in the <span class="in">`kernel_code`</span>. The</span>
<span id="cb37-1025"><a href="#cb37-1025" aria-hidden="true" tabindex="-1"></a>field <span class="in">`risk_cls`</span> comes from the names of characteristics of individuals</span>
<span id="cb37-1026"><a href="#cb37-1026" aria-hidden="true" tabindex="-1"></a>in the population. The names <span class="in">`lambda`</span> and <span class="in">`p`</span> are parameter names that</span>
<span id="cb37-1027"><a href="#cb37-1027" aria-hidden="true" tabindex="-1"></a>will be specified in the <span class="in">`R`</span> named list <span class="in">`params`</span>.</span>
<span id="cb37-1028"><a href="#cb37-1028" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1029"><a href="#cb37-1029" aria-hidden="true" tabindex="-1"></a>Here we use a constant $\lambda$ as the event intensity, but we could</span>
<span id="cb37-1030"><a href="#cb37-1030" aria-hidden="true" tabindex="-1"></a>also use a rate $\lambda(t)$ that depends on time, using the function</span>
<span id="cb37-1031"><a href="#cb37-1031" aria-hidden="true" tabindex="-1"></a><span class="in">`mk_event_poisson_inhomogeneous`</span>.</span>
<span id="cb37-1032"><a href="#cb37-1032" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1033"><a href="#cb37-1033" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Death and exit events</span></span>
<span id="cb37-1034"><a href="#cb37-1034" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1035"><a href="#cb37-1035" aria-hidden="true" tabindex="-1"></a>The baseline death intensity defined</span>
<span id="cb37-1036"><a href="#cb37-1036" aria-hidden="true" tabindex="-1"></a>in @eq-insurance-baseline and obtained with the package</span>
<span id="cb37-1037"><a href="#cb37-1037" aria-hidden="true" tabindex="-1"></a><span class="in">`StMoMo`</span> is stored in the variable <span class="in">`death_male`</span>.</span>
<span id="cb37-1038"><a href="#cb37-1038" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1041"><a href="#cb37-1041" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb37-1042"><a href="#cb37-1042" aria-hidden="true" tabindex="-1"></a><span class="co"># StMoMo death rates</span></span>
<span id="cb37-1043"><a href="#cb37-1043" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">'StMoMo'</span>)</span>
<span id="cb37-1044"><a href="#cb37-1044" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">'reshape2'</span>)</span>
<span id="cb37-1045"><a href="#cb37-1045" aria-hidden="true" tabindex="-1"></a>EWStMoMoMale <span class="ot">&lt;-</span> <span class="fu">StMoMoData</span>(EWdata_hmd, <span class="at">series =</span> <span class="st">"male"</span>)</span>
<span id="cb37-1046"><a href="#cb37-1046" aria-hidden="true" tabindex="-1"></a>LC <span class="ot">&lt;-</span> <span class="fu">lc</span>()</span>
<span id="cb37-1047"><a href="#cb37-1047" aria-hidden="true" tabindex="-1"></a>ages.fit <span class="ot">&lt;-</span> <span class="dv">65</span><span class="sc">:</span><span class="dv">100</span></span>
<span id="cb37-1048"><a href="#cb37-1048" aria-hidden="true" tabindex="-1"></a>years.fit <span class="ot">&lt;-</span> <span class="dv">1950</span><span class="sc">:</span><span class="dv">2016</span></span>
<span id="cb37-1049"><a href="#cb37-1049" aria-hidden="true" tabindex="-1"></a>LCfitMale <span class="ot">&lt;-</span> <span class="fu">fit</span>(LC, <span class="at">data =</span> EWStMoMoMale, <span class="at">ages.fit =</span> ages.fit, <span class="at">years.fit =</span> years.fit)</span>
<span id="cb37-1050"><a href="#cb37-1050" aria-hidden="true" tabindex="-1"></a>t <span class="ot">&lt;-</span> <span class="dv">30</span></span>
<span id="cb37-1051"><a href="#cb37-1051" aria-hidden="true" tabindex="-1"></a>LCforecastMale <span class="ot">&lt;-</span> <span class="fu">forecast</span>(LCfitMale, <span class="at">h =</span> t)</span>
<span id="cb37-1052"><a href="#cb37-1052" aria-hidden="true" tabindex="-1"></a>d_k <span class="ot">&lt;-</span> <span class="fu">apply</span>(LCforecastMale<span class="sc">$</span>rates, <span class="dv">2</span>, <span class="cf">function</span>(x) <span class="fu">stepfun</span>(<span class="dv">66</span><span class="sc">:</span><span class="dv">100</span>, x))</span>
<span id="cb37-1053"><a href="#cb37-1053" aria-hidden="true" tabindex="-1"></a>breaks <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">29</span></span>
<span id="cb37-1054"><a href="#cb37-1054" aria-hidden="true" tabindex="-1"></a>death_male <span class="ot">&lt;-</span> <span class="fu">piecewise_xy</span>(breaks,d_k)</span>
<span id="cb37-1055"><a href="#cb37-1055" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1056"><a href="#cb37-1056" aria-hidden="true" tabindex="-1"></a>death_max <span class="ot">&lt;-</span> <span class="fu">max</span>(<span class="fu">sapply</span>(d_k, <span class="cf">function</span>(x) { <span class="fu">max</span>(x) }))</span>
<span id="cb37-1057"><a href="#cb37-1057" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1058"><a href="#cb37-1058" aria-hidden="true" tabindex="-1"></a>death_params <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="st">"death_male"</span> <span class="ot">=</span> death_male, <span class="st">"alpha"</span> <span class="ot">=</span> <span class="fu">c</span>(<span class="fl">1.2</span>, <span class="fl">0.8</span>))</span>
<span id="cb37-1059"><a href="#cb37-1059" aria-hidden="true" tabindex="-1"></a>death_event <span class="ot">&lt;-</span> <span class="fu">mk_event_individual</span>(</span>
<span id="cb37-1060"><a href="#cb37-1060" aria-hidden="true" tabindex="-1"></a>    <span class="at">type =</span> <span class="st">"death"</span>,</span>
<span id="cb37-1061"><a href="#cb37-1061" aria-hidden="true" tabindex="-1"></a>    <span class="at">intensity_code =</span> <span class="st">"result = alpha[I.risk_cls-1] * death_male(t, I.age(t));"</span>)</span>
<span id="cb37-1062"><a href="#cb37-1062" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb37-1063"><a href="#cb37-1063" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1064"><a href="#cb37-1064" aria-hidden="true" tabindex="-1"></a>The death and exit intensities are of class <span class="in">`individual`</span> TODO(see Table</span>
<span id="cb37-1065"><a href="#cb37-1065" aria-hidden="true" tabindex="-1"></a>@tab::intensity_classes ). Hence, the death and exit events</span>
<span id="cb37-1066"><a href="#cb37-1066" aria-hidden="true" tabindex="-1"></a>are created with the <span class="in">`mk_event_individual`</span> function.</span>
<span id="cb37-1067"><a href="#cb37-1067" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1070"><a href="#cb37-1070" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb37-1071"><a href="#cb37-1071" aria-hidden="true" tabindex="-1"></a>death_params <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="st">"death_male"</span> <span class="ot">=</span> death_male, <span class="st">"alpha"</span> <span class="ot">=</span> <span class="fu">c</span>(<span class="fl">1.2</span>, <span class="fl">0.8</span>))</span>
<span id="cb37-1072"><a href="#cb37-1072" aria-hidden="true" tabindex="-1"></a>death_event <span class="ot">&lt;-</span> <span class="fu">mk_event_individual</span>(</span>
<span id="cb37-1073"><a href="#cb37-1073" aria-hidden="true" tabindex="-1"></a>    <span class="at">type =</span> <span class="st">"death"</span>,</span>
<span id="cb37-1074"><a href="#cb37-1074" aria-hidden="true" tabindex="-1"></a>    <span class="at">intensity_code =</span> <span class="st">"result = alpha[I.risk_cls-1] * death_male(t, I.age(t));"</span>)</span>
<span id="cb37-1075"><a href="#cb37-1075" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb37-1076"><a href="#cb37-1076" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb37-1079"><a href="#cb37-1079" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb37-1080"><a href="#cb37-1080" aria-hidden="true" tabindex="-1"></a>exit_params <span class="ot">=</span> <span class="fu">list</span>(<span class="st">"mu"</span> <span class="ot">=</span> <span class="fu">c</span>(<span class="fl">0.001</span>, <span class="fl">0.06</span>))</span>
<span id="cb37-1081"><a href="#cb37-1081" aria-hidden="true" tabindex="-1"></a>exit_event <span class="ot">&lt;-</span> <span class="fu">mk_event_individual</span>(</span>
<span id="cb37-1082"><a href="#cb37-1082" aria-hidden="true" tabindex="-1"></a>    <span class="at">type =</span> <span class="st">"exit"</span>,</span>
<span id="cb37-1083"><a href="#cb37-1083" aria-hidden="true" tabindex="-1"></a>    <span class="at">intensity_code =</span> <span class="st">"result = mu[I.risk_cls-1]; "</span>)</span>
<span id="cb37-1084"><a href="#cb37-1084" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb37-1085"><a href="#cb37-1085" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1086"><a href="#cb37-1086" aria-hidden="true" tabindex="-1"></a><span class="fu">## Model creation and simulation {#insurance-simulation}</span></span>
<span id="cb37-1087"><a href="#cb37-1087" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1088"><a href="#cb37-1088" aria-hidden="true" tabindex="-1"></a>The model is created from all the previously defined building blocks, by</span>
<span id="cb37-1089"><a href="#cb37-1089" aria-hidden="true" tabindex="-1"></a>calling the <span class="in">`mk_model`</span>.</span>
<span id="cb37-1090"><a href="#cb37-1090" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1093"><a href="#cb37-1093" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb37-1094"><a href="#cb37-1094" aria-hidden="true" tabindex="-1"></a>model <span class="ot">&lt;-</span> <span class="fu">mk_model</span>(</span>
<span id="cb37-1095"><a href="#cb37-1095" aria-hidden="true" tabindex="-1"></a>    <span class="at">characteristics =</span> <span class="fu">get_characteristics</span>(pop_init),</span>
<span id="cb37-1096"><a href="#cb37-1096" aria-hidden="true" tabindex="-1"></a>    <span class="at">events =</span> <span class="fu">list</span>(entry_event, death_event, exit_event),</span>
<span id="cb37-1097"><a href="#cb37-1097" aria-hidden="true" tabindex="-1"></a>    <span class="at">parameters =</span> <span class="fu">c</span>(entry_params, death_params, exit_params))</span>
<span id="cb37-1098"><a href="#cb37-1098" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb37-1099"><a href="#cb37-1099" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1100"><a href="#cb37-1100" aria-hidden="true" tabindex="-1"></a>Once the model is compiled, it can be used with different parameters and</span>
<span id="cb37-1101"><a href="#cb37-1101" aria-hidden="true" tabindex="-1"></a>run simulations for various scenarios. Similarly, the initial population</span>
<span id="cb37-1102"><a href="#cb37-1102" aria-hidden="true" tabindex="-1"></a>(here <span class="in">`pop_df`</span>) can be modified without rerunning the <span class="in">`mk_model`</span></span>
<span id="cb37-1103"><a href="#cb37-1103" aria-hidden="true" tabindex="-1"></a>function. The bounds for entry events is simply the intensity $\lambda$.</span>
<span id="cb37-1104"><a href="#cb37-1104" aria-hidden="true" tabindex="-1"></a>For death events, the bound is given by $\bar{d}$ defined in</span>
<span id="cb37-1105"><a href="#cb37-1105" aria-hidden="true" tabindex="-1"></a>@eq-insurance-bound-deathrates, which is stored in the</span>
<span id="cb37-1106"><a href="#cb37-1106" aria-hidden="true" tabindex="-1"></a><span class="in">`death_max`</span> variable.</span>
<span id="cb37-1107"><a href="#cb37-1107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1110"><a href="#cb37-1110" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb37-1111"><a href="#cb37-1111" aria-hidden="true" tabindex="-1"></a>bounds <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"entry"</span> <span class="ot">=</span> entry_params<span class="sc">$</span>lambda,</span>
<span id="cb37-1112"><a href="#cb37-1112" aria-hidden="true" tabindex="-1"></a>            <span class="st">"death"</span> <span class="ot">=</span> death_max,</span>
<span id="cb37-1113"><a href="#cb37-1113" aria-hidden="true" tabindex="-1"></a>            <span class="st">"exit"</span> <span class="ot">=</span> <span class="fu">max</span>(exit_params<span class="sc">$</span>mu))</span>
<span id="cb37-1114"><a href="#cb37-1114" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1115"><a href="#cb37-1115" aria-hidden="true" tabindex="-1"></a>sim_out <span class="ot">&lt;-</span> <span class="fu">popsim</span>(</span>
<span id="cb37-1116"><a href="#cb37-1116" aria-hidden="true" tabindex="-1"></a>    <span class="at">model =</span> model,</span>
<span id="cb37-1117"><a href="#cb37-1117" aria-hidden="true" tabindex="-1"></a>    <span class="at">initial_population =</span> pop_init,</span>
<span id="cb37-1118"><a href="#cb37-1118" aria-hidden="true" tabindex="-1"></a>    <span class="at">events_bounds =</span> bounds,</span>
<span id="cb37-1119"><a href="#cb37-1119" aria-hidden="true" tabindex="-1"></a>    <span class="at">parameters =</span> <span class="fu">c</span>(entry_params, death_params, exit_params),</span>
<span id="cb37-1120"><a href="#cb37-1120" aria-hidden="true" tabindex="-1"></a>    <span class="at">time =</span> <span class="dv">30</span>,</span>
<span id="cb37-1121"><a href="#cb37-1121" aria-hidden="true" tabindex="-1"></a>    <span class="at">age_max =</span> <span class="dv">110</span>,</span>
<span id="cb37-1122"><a href="#cb37-1122" aria-hidden="true" tabindex="-1"></a>    <span class="at">multithreading =</span> <span class="cn">TRUE</span>)</span>
<span id="cb37-1123"><a href="#cb37-1123" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb37-1124"><a href="#cb37-1124" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1125"><a href="#cb37-1125" aria-hidden="true" tabindex="-1"></a><span class="fu">## Outputs</span></span>
<span id="cb37-1126"><a href="#cb37-1126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1127"><a href="#cb37-1127" aria-hidden="true" tabindex="-1"></a>The data frame <span class="in">`sim_out$population`</span> consists of all individuals present</span>
<span id="cb37-1128"><a href="#cb37-1128" aria-hidden="true" tabindex="-1"></a>in the portfolio during the period of $<span class="co">[</span><span class="ot">0, 30</span><span class="co">]</span>$, including the</span>
<span id="cb37-1129"><a href="#cb37-1129" aria-hidden="true" tabindex="-1"></a>individuals in the initial population and those who entered the</span>
<span id="cb37-1130"><a href="#cb37-1130" aria-hidden="true" tabindex="-1"></a>portfolio. Each row represents an individual, with their date of birth,</span>
<span id="cb37-1131"><a href="#cb37-1131" aria-hidden="true" tabindex="-1"></a>date of death (<span class="in">`NA`</span> if still alive at the end of the simulation), risk</span>
<span id="cb37-1132"><a href="#cb37-1132" aria-hidden="true" tabindex="-1"></a>class, and characteristics <span class="in">`entry`</span> and <span class="in">`out`</span>. Recall that if an</span>
<span id="cb37-1133"><a href="#cb37-1133" aria-hidden="true" tabindex="-1"></a>individual enters the population at time $t$, his <span class="in">`entry`</span> characteristic</span>
<span id="cb37-1134"><a href="#cb37-1134" aria-hidden="true" tabindex="-1"></a>is automatically set up to be equal to $t$. The characteristics <span class="in">`out`</span> is</span>
<span id="cb37-1135"><a href="#cb37-1135" aria-hidden="true" tabindex="-1"></a>set to <span class="in">`TRUE`</span> for individuals who left the portfolio due to an exit</span>
<span id="cb37-1136"><a href="#cb37-1136" aria-hidden="true" tabindex="-1"></a>event.</span>
<span id="cb37-1137"><a href="#cb37-1137" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1138"><a href="#cb37-1138" aria-hidden="true" tabindex="-1"></a>In this example, the simulation time over 30 years, starting from an</span>
<span id="cb37-1139"><a href="#cb37-1139" aria-hidden="true" tabindex="-1"></a>initial population of 30 000 individuals is of $2\times 10^{-4}$</span>
<span id="cb37-1140"><a href="#cb37-1140" aria-hidden="true" tabindex="-1"></a>seconds, for an acceptance rate of proposed event of approximately 25%.</span>
<span id="cb37-1141"><a href="#cb37-1141" aria-hidden="true" tabindex="-1"></a>At the end of the simulation, the number of alive individuals is</span>
<span id="cb37-1142"><a href="#cb37-1142" aria-hidden="true" tabindex="-1"></a>approximately 430 000.</span>
<span id="cb37-1143"><a href="#cb37-1143" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1144"><a href="#cb37-1144" aria-hidden="true" tabindex="-1"></a>Initially in the portfolio (at $t=0$), there is the same number of 65</span>
<span id="cb37-1145"><a href="#cb37-1145" aria-hidden="true" tabindex="-1"></a>years old policyholders in each risk class. However, policyholders in</span>
<span id="cb37-1146"><a href="#cb37-1146" aria-hidden="true" tabindex="-1"></a>the risk class 2 with lower mortality rates leave the portfolio at</span>
<span id="cb37-1147"><a href="#cb37-1147" aria-hidden="true" tabindex="-1"></a>higher rate than policyholders in the risk class 1 : $\mu^2 &gt; \mu^1$.</span>
<span id="cb37-1148"><a href="#cb37-1148" aria-hidden="true" tabindex="-1"></a>Therefore, the heterogeneous portfolio composition changes with time,</span>
<span id="cb37-1149"><a href="#cb37-1149" aria-hidden="true" tabindex="-1"></a>including more and more individuals in risk class 1 with higher</span>
<span id="cb37-1150"><a href="#cb37-1150" aria-hidden="true" tabindex="-1"></a>mortality rates, but with variations across age classes. To illustrate</span>
<span id="cb37-1151"><a href="#cb37-1151" aria-hidden="true" tabindex="-1"></a>the composition of the total population at the end of the simulation</span>
<span id="cb37-1152"><a href="#cb37-1152" aria-hidden="true" tabindex="-1"></a>($t=30$), we present in Figure @fig-insur-a the age pyramid of the final composition of</span>
<span id="cb37-1153"><a href="#cb37-1153" aria-hidden="true" tabindex="-1"></a>the portfolio obtained with the <span class="in">`age_pyramid`</span> and <span class="in">`plot`</span> function of the</span>
<span id="cb37-1154"><a href="#cb37-1154" aria-hidden="true" tabindex="-1"></a><span class="in">`pyramid`</span> class.</span>
<span id="cb37-1155"><a href="#cb37-1155" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1156"><a href="#cb37-1156" aria-hidden="true" tabindex="-1"></a><span class="in">`IBMPopSim`</span> also allows the fast computation of exact life tables from</span>
<span id="cb37-1157"><a href="#cb37-1157" aria-hidden="true" tabindex="-1"></a>truncated and censored individual data (due to entry and exit events),</span>
<span id="cb37-1158"><a href="#cb37-1158" aria-hidden="true" tabindex="-1"></a>using the functions <span class="in">`death_table`</span> and <span class="in">`exposure_table`</span>. These function</span>
<span id="cb37-1159"><a href="#cb37-1159" aria-hidden="true" tabindex="-1"></a>are particularly efficient, since the computations are made using the</span>
<span id="cb37-1160"><a href="#cb37-1160" aria-hidden="true" tabindex="-1"></a><span class="in">`Rccp`</span> library.</span>
<span id="cb37-1161"><a href="#cb37-1161" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1162"><a href="#cb37-1162" aria-hidden="true" tabindex="-1"></a>In Figure @fig-insur-b, we illustrate the central death rates in the</span>
<span id="cb37-1163"><a href="#cb37-1163" aria-hidden="true" tabindex="-1"></a>simulated portfolio at final time. Due to the mortality differential</span>
<span id="cb37-1164"><a href="#cb37-1164" aria-hidden="true" tabindex="-1"></a>between risk class 1 and 2, one would expect to observe more individuals</span>
<span id="cb37-1165"><a href="#cb37-1165" aria-hidden="true" tabindex="-1"></a>in risk class 2 at higher ages. However, due to exit events, a higher</span>
<span id="cb37-1166"><a href="#cb37-1166" aria-hidden="true" tabindex="-1"></a>proportion of individuals in risk class 1 exit the portfolio over time,</span>
<span id="cb37-1167"><a href="#cb37-1167" aria-hidden="true" tabindex="-1"></a>resulting in a greater proportion of individuals in risk class 1 at</span>
<span id="cb37-1168"><a href="#cb37-1168" aria-hidden="true" tabindex="-1"></a>higher ages than what would be expected in the absence of exit events.</span>
<span id="cb37-1169"><a href="#cb37-1169" aria-hidden="true" tabindex="-1"></a>Consequently, the mortality rates in the portfolio are more aligned with</span>
<span id="cb37-1170"><a href="#cb37-1170" aria-hidden="true" tabindex="-1"></a>those of risk class 1 at higher ages. This is a simple example of how</span>
<span id="cb37-1171"><a href="#cb37-1171" aria-hidden="true" tabindex="-1"></a>composition changes in the portfolio can impact aggregated mortality</span>
<span id="cb37-1172"><a href="#cb37-1172" aria-hidden="true" tabindex="-1"></a>rates and potentially compensate or reduce an overall mortality</span>
<span id="cb37-1173"><a href="#cb37-1173" aria-hidden="true" tabindex="-1"></a>reduction (see also <span class="co">[</span><span class="ot">@KAAKAI201916</span><span class="co">]</span>).</span>
<span id="cb37-1174"><a href="#cb37-1174" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1175"><a href="#cb37-1175" aria-hidden="true" tabindex="-1"></a><span class="in">```{r, echo=FALSE, fig.width=10}</span></span>
<span id="cb37-1176"><a href="#cb37-1176" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: fig-insur-a</span></span>
<span id="cb37-1177"><a href="#cb37-1177" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-cap: "Portfolio age pyramid at t = 30 for individuals in risk class 1 (blue) and 2 (red)."</span></span>
<span id="cb37-1178"><a href="#cb37-1178" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-pos: 'h'</span></span>
<span id="cb37-1179"><a href="#cb37-1179" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1180"><a href="#cb37-1180" aria-hidden="true" tabindex="-1"></a><span class="in">dim(population_alive(sim_out$population,t = 30))</span></span>
<span id="cb37-1181"><a href="#cb37-1181" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1182"><a href="#cb37-1182" aria-hidden="true" tabindex="-1"></a><span class="in">sim_out$logs[["duration_ns"]]/1e9</span></span>
<span id="cb37-1183"><a href="#cb37-1183" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1184"><a href="#cb37-1184" aria-hidden="true" tabindex="-1"></a><span class="in">sim_out$logs[["effective_events"]] / sim_out$logs[["proposed_events"]]</span></span>
<span id="cb37-1185"><a href="#cb37-1185" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1186"><a href="#cb37-1186" aria-hidden="true" tabindex="-1"></a><span class="in"># Age pyramid (Figure 2(a))</span></span>
<span id="cb37-1187"><a href="#cb37-1187" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1188"><a href="#cb37-1188" aria-hidden="true" tabindex="-1"></a><span class="in">age_grp &lt;- 65:98</span></span>
<span id="cb37-1189"><a href="#cb37-1189" aria-hidden="true" tabindex="-1"></a><span class="in">pyr = age_pyramid(sim_out$population, time = 30, ages=age_grp)</span></span>
<span id="cb37-1190"><a href="#cb37-1190" aria-hidden="true" tabindex="-1"></a><span class="in">colnames(pyr)[2]&lt;- "group_name"</span></span>
<span id="cb37-1191"><a href="#cb37-1191" aria-hidden="true" tabindex="-1"></a><span class="in">pyr$group_name &lt;- as.character(pyr$group_name)</span></span>
<span id="cb37-1192"><a href="#cb37-1192" aria-hidden="true" tabindex="-1"></a><span class="in">colors &lt;- c("1"="#00AFBB","2"="#FC4E07")</span></span>
<span id="cb37-1193"><a href="#cb37-1193" aria-hidden="true" tabindex="-1"></a><span class="in">plot(pyr,colors,age_breaks = as.integer(seq(1,length(age_grp)-1,by=2)))</span></span>
<span id="cb37-1194"><a href="#cb37-1194" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb37-1195"><a href="#cb37-1195" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1196"><a href="#cb37-1196" aria-hidden="true" tabindex="-1"></a><span class="in">```{r, echo=FALSE, fig.width=10}</span></span>
<span id="cb37-1197"><a href="#cb37-1197" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: fig-insur-b</span></span>
<span id="cb37-1198"><a href="#cb37-1198" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-cap: "Portfolio central death rates at t = 30 (black)."</span></span>
<span id="cb37-1199"><a href="#cb37-1199" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-pos: 'h'</span></span>
<span id="cb37-1200"><a href="#cb37-1200" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1201"><a href="#cb37-1201" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1202"><a href="#cb37-1202" aria-hidden="true" tabindex="-1"></a><span class="in"># Portofolio death rates</span></span>
<span id="cb37-1203"><a href="#cb37-1203" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1204"><a href="#cb37-1204" aria-hidden="true" tabindex="-1"></a><span class="in">age_grp &lt;- 65:95</span></span>
<span id="cb37-1205"><a href="#cb37-1205" aria-hidden="true" tabindex="-1"></a><span class="in">Dx_pop &lt;- death_table(sim_out$population, ages = age_grp, period = 0:30)</span></span>
<span id="cb37-1206"><a href="#cb37-1206" aria-hidden="true" tabindex="-1"></a><span class="in">Ex_pop &lt;- exposure_table(sim_out$population, ages = age_grp, period = 0:30)</span></span>
<span id="cb37-1207"><a href="#cb37-1207" aria-hidden="true" tabindex="-1"></a><span class="in">mx_pop &lt;- Dx_pop/Ex_pop</span></span>
<span id="cb37-1208"><a href="#cb37-1208" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1209"><a href="#cb37-1209" aria-hidden="true" tabindex="-1"></a><span class="in"># Figure 2(b)</span></span>
<span id="cb37-1210"><a href="#cb37-1210" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1211"><a href="#cb37-1211" aria-hidden="true" tabindex="-1"></a><span class="in">Dx &lt;- death_table(sim_out$population[sim_out$population$risk_cls==1,],</span></span>
<span id="cb37-1212"><a href="#cb37-1212" aria-hidden="true" tabindex="-1"></a><span class="in">                  ages = age_grp, period = 0:30)</span></span>
<span id="cb37-1213"><a href="#cb37-1213" aria-hidden="true" tabindex="-1"></a><span class="in">Ex &lt;- exposure_table(sim_out$population[sim_out$population$risk_cls==1,],</span></span>
<span id="cb37-1214"><a href="#cb37-1214" aria-hidden="true" tabindex="-1"></a><span class="in">                     ages = age_grp, period = 0:30)</span></span>
<span id="cb37-1215"><a href="#cb37-1215" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1216"><a href="#cb37-1216" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1217"><a href="#cb37-1217" aria-hidden="true" tabindex="-1"></a><span class="in">LC &lt;- lc()</span></span>
<span id="cb37-1218"><a href="#cb37-1218" aria-hidden="true" tabindex="-1"></a><span class="in">LCfitSim1 &lt;- fit(LC, Dxt = Dx , Ext = Ex,ages=age_grp[-length(age_grp)])</span></span>
<span id="cb37-1219"><a href="#cb37-1219" aria-hidden="true" tabindex="-1"></a><span class="in">time &lt;- 30</span></span>
<span id="cb37-1220"><a href="#cb37-1220" aria-hidden="true" tabindex="-1"></a><span class="in">age &lt;- age_grp[-length(age_grp)]</span></span>
<span id="cb37-1221"><a href="#cb37-1221" aria-hidden="true" tabindex="-1"></a><span class="in">estimated &lt;- LCfitSim1$ax + LCfitSim1$bx*LCfitSim1$kt[time]</span></span>
<span id="cb37-1222"><a href="#cb37-1222" aria-hidden="true" tabindex="-1"></a><span class="in">forecast_1 &lt;- log(1.3*LCforecastMale$rates[1:(length(age_grp)-1),time])</span></span>
<span id="cb37-1223"><a href="#cb37-1223" aria-hidden="true" tabindex="-1"></a><span class="in">forecast_2 &lt;- log(0.8*LCforecastMale$rates[1:(length(age_grp)-1),time])</span></span>
<span id="cb37-1224"><a href="#cb37-1224" aria-hidden="true" tabindex="-1"></a><span class="in">portfolio &lt;- log((mx_pop)[,time])</span></span>
<span id="cb37-1225"><a href="#cb37-1225" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1226"><a href="#cb37-1226" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1227"><a href="#cb37-1227" aria-hidden="true" tabindex="-1"></a><span class="in">df &lt;- data.frame(age=age, portfolio=portfolio, forecast_1=forecast_1, forecast_1=forecast_2)</span></span>
<span id="cb37-1228"><a href="#cb37-1228" aria-hidden="true" tabindex="-1"></a><span class="in">colnames(df) &lt;- c("Age", "Portfolio", "Risk class 1", "Risk class 2")</span></span>
<span id="cb37-1229"><a href="#cb37-1229" aria-hidden="true" tabindex="-1"></a><span class="in">df_melt &lt;- melt(df, id="Age")</span></span>
<span id="cb37-1230"><a href="#cb37-1230" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1231"><a href="#cb37-1231" aria-hidden="true" tabindex="-1"></a><span class="in">ggplot(data=df_melt, aes(x=Age, y=value)) +</span></span>
<span id="cb37-1232"><a href="#cb37-1232" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_point(aes(color=variable, shape=variable)) +</span></span>
<span id="cb37-1233"><a href="#cb37-1233" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_line(aes(color=variable, linetype=variable)) +</span></span>
<span id="cb37-1234"><a href="#cb37-1234" aria-hidden="true" tabindex="-1"></a><span class="in">  xlab("Age") +</span></span>
<span id="cb37-1235"><a href="#cb37-1235" aria-hidden="true" tabindex="-1"></a><span class="in">  ylab("Log mortality rates") +</span></span>
<span id="cb37-1236"><a href="#cb37-1236" aria-hidden="true" tabindex="-1"></a><span class="in">  scale_color_manual(values = c("Portfolio" = "black", "Risk class 1" = "blue", "Risk class 2" = "red")) +</span></span>
<span id="cb37-1237"><a href="#cb37-1237" aria-hidden="true" tabindex="-1"></a><span class="in">  scale_shape_manual(values = c("Portfolio" = 1, "Risk class 1" = NA, "Risk class 2" = NA)) +</span></span>
<span id="cb37-1238"><a href="#cb37-1238" aria-hidden="true" tabindex="-1"></a><span class="in">  scale_linetype_manual(values = c("Portfolio" = 0, "Risk class 1" = 2, "Risk class 2" = 1)) +</span></span>
<span id="cb37-1239"><a href="#cb37-1239" aria-hidden="true" tabindex="-1"></a><span class="in">  theme(legend.title = element_blank(), legend.position = c(0.9,0.2), plot.title = element_text(hjust = 0.5))</span></span>
<span id="cb37-1240"><a href="#cb37-1240" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1241"><a href="#cb37-1241" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1242"><a href="#cb37-1242" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb37-1243"><a href="#cb37-1243" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1244"><a href="#cb37-1244" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1245"><a href="#cb37-1245" aria-hidden="true" tabindex="-1"></a><span class="fu"># Population with genetically variable traits {#sec-example-interaction}</span></span>
<span id="cb37-1246"><a href="#cb37-1246" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1247"><a href="#cb37-1247" aria-hidden="true" tabindex="-1"></a>This section provides an example of how to use the <span class="in">`IBMPopSim`</span> package to simulate an age-structured population with interactions, based on the model proposed in Example 1 of @FerTra09 (see also @meleard2009trait).</span>
<span id="cb37-1248"><a href="#cb37-1248" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1249"><a href="#cb37-1249" aria-hidden="true" tabindex="-1"></a>In this model, individuals are characterized by their body size at birth</span>
<span id="cb37-1250"><a href="#cb37-1250" aria-hidden="true" tabindex="-1"></a>$x_0 \in <span class="co">[</span><span class="ot">0,4</span><span class="co">]</span>$ and by their physical age $a \in <span class="co">[</span><span class="ot">0,2</span><span class="co">]</span>$. The body size</span>
<span id="cb37-1251"><a href="#cb37-1251" aria-hidden="true" tabindex="-1"></a>of an individual $I=(\tau^b,\infty, x_0)$ at time $t$ is a linear</span>
<span id="cb37-1252"><a href="#cb37-1252" aria-hidden="true" tabindex="-1"></a>function of its age $a(I,t) = t-\tau^b$: $$x(t)= x_0 + ga(I,t),$$ where</span>
<span id="cb37-1253"><a href="#cb37-1253" aria-hidden="true" tabindex="-1"></a>$g$ is a constant growth rate assumed to be identical for all</span>
<span id="cb37-1254"><a href="#cb37-1254" aria-hidden="true" tabindex="-1"></a>individuals.</span>
<span id="cb37-1255"><a href="#cb37-1255" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1256"><a href="#cb37-1256" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1257"><a href="#cb37-1257" aria-hidden="true" tabindex="-1"></a>**Birth events** The birth intensity of each individual</span>
<span id="cb37-1258"><a href="#cb37-1258" aria-hidden="true" tabindex="-1"></a>$I=(\tau^b, \infty, x_0)$ depends on a parameter $\alpha &gt; 0$ and on its</span>
<span id="cb37-1259"><a href="#cb37-1259" aria-hidden="true" tabindex="-1"></a>initial size, as given by the equation</span>
<span id="cb37-1260"><a href="#cb37-1260" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-1261"><a href="#cb37-1261" aria-hidden="true" tabindex="-1"></a>\lambda^b(t,I) = \alpha (4 - x_0) \leq \bar \lambda^b = 4\alpha.</span>
<span id="cb37-1262"><a href="#cb37-1262" aria-hidden="true" tabindex="-1"></a>$${#eq-interaction-birth-intensity}</span>
<span id="cb37-1263"><a href="#cb37-1263" aria-hidden="true" tabindex="-1"></a>Thus,</span>
<span id="cb37-1264"><a href="#cb37-1264" aria-hidden="true" tabindex="-1"></a>smaller individuals have a higher birth intensity. When a birth occurs,</span>
<span id="cb37-1265"><a href="#cb37-1265" aria-hidden="true" tabindex="-1"></a>the new individual inherit the same birth size $x_0$ as its parent with</span>
<span id="cb37-1266"><a href="#cb37-1266" aria-hidden="true" tabindex="-1"></a>high probability $1-p$, or a mutation can occur with probability $p$,</span>
<span id="cb37-1267"><a href="#cb37-1267" aria-hidden="true" tabindex="-1"></a>resulting in a birth size given by</span>
<span id="cb37-1268"><a href="#cb37-1268" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-1269"><a href="#cb37-1269" aria-hidden="true" tabindex="-1"></a>    x_0' = \min(\max(0, x_0 + G), 4),</span>
<span id="cb37-1270"><a href="#cb37-1270" aria-hidden="true" tabindex="-1"></a>$${#eq-interaction-birth-kernel}</span>
<span id="cb37-1271"><a href="#cb37-1271" aria-hidden="true" tabindex="-1"></a>where $G$ is a Gaussian random</span>
<span id="cb37-1272"><a href="#cb37-1272" aria-hidden="true" tabindex="-1"></a>variable with mean 0 and variance $\sigma^2$.</span>
<span id="cb37-1273"><a href="#cb37-1273" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1274"><a href="#cb37-1274" aria-hidden="true" tabindex="-1"></a>**Death events** Due to competition between individuals, the death</span>
<span id="cb37-1275"><a href="#cb37-1275" aria-hidden="true" tabindex="-1"></a>intensity of an individual depends on the size of other individuals in</span>
<span id="cb37-1276"><a href="#cb37-1276" aria-hidden="true" tabindex="-1"></a>the population. Bigger individuals have a better chance of survival. If</span>
<span id="cb37-1277"><a href="#cb37-1277" aria-hidden="true" tabindex="-1"></a>an individual $I= (\tau^b, \infty, x_0)$ of size $x(t)= x_0 +ga(I,t)$</span>
<span id="cb37-1278"><a href="#cb37-1278" aria-hidden="true" tabindex="-1"></a>encounters an individual $J= (\tau^{b}_J, \infty, x_0')$ of size</span>
<span id="cb37-1279"><a href="#cb37-1279" aria-hidden="true" tabindex="-1"></a>$x'(t) = x_0'+ ga(J,t)$, then it can die with the intensity</span>
<span id="cb37-1280"><a href="#cb37-1280" aria-hidden="true" tabindex="-1"></a>$$W(t, I,J) = U(x(t),x'(t)),$$ where the interaction function $U$ is</span>
<span id="cb37-1281"><a href="#cb37-1281" aria-hidden="true" tabindex="-1"></a>defined by </span>
<span id="cb37-1282"><a href="#cb37-1282" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-1283"><a href="#cb37-1283" aria-hidden="true" tabindex="-1"></a>    U(x,y) = \beta \left(1- \frac{1}{1+ c\exp(-4(x-y))}\right) \leq \bar W = \beta.</span>
<span id="cb37-1284"><a href="#cb37-1284" aria-hidden="true" tabindex="-1"></a>$${#eq-interaction-death-intensity}</span>
<span id="cb37-1285"><a href="#cb37-1285" aria-hidden="true" tabindex="-1"></a>The death intensity of an individual $I$ at time $t$ and in a population</span>
<span id="cb37-1286"><a href="#cb37-1286" aria-hidden="true" tabindex="-1"></a>$Z$ is the result of interactions with all individuals in the</span>
<span id="cb37-1287"><a href="#cb37-1287" aria-hidden="true" tabindex="-1"></a>population, including itself, and is given by</span>
<span id="cb37-1288"><a href="#cb37-1288" aria-hidden="true" tabindex="-1"></a>$$\lambda^d_t(I,Z) = \sum_{J = (\tau^b,\infty, x_0') \in Z}  W (x_0 + g a(I,t), x_0' + g a(J,t)),$$</span>
<span id="cb37-1289"><a href="#cb37-1289" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1290"><a href="#cb37-1290" aria-hidden="true" tabindex="-1"></a><span class="fu">## Population</span></span>
<span id="cb37-1291"><a href="#cb37-1291" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1292"><a href="#cb37-1292" aria-hidden="true" tabindex="-1"></a>We use an initial population of 900 living individuals, all of whom have</span>
<span id="cb37-1293"><a href="#cb37-1293" aria-hidden="true" tabindex="-1"></a>the same size and ages uniformly distributed between 0 and 2 years.</span>
<span id="cb37-1294"><a href="#cb37-1294" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1297"><a href="#cb37-1297" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb37-1298"><a href="#cb37-1298" aria-hidden="true" tabindex="-1"></a>N <span class="ot">&lt;-</span> <span class="dv">900</span> </span>
<span id="cb37-1299"><a href="#cb37-1299" aria-hidden="true" tabindex="-1"></a>x0 <span class="ot">&lt;-</span> <span class="fl">1.06</span></span>
<span id="cb37-1300"><a href="#cb37-1300" aria-hidden="true" tabindex="-1"></a>agemin <span class="ot">&lt;-</span> <span class="fl">0.</span></span>
<span id="cb37-1301"><a href="#cb37-1301" aria-hidden="true" tabindex="-1"></a>agemax <span class="ot">&lt;-</span> <span class="fl">2.</span></span>
<span id="cb37-1302"><a href="#cb37-1302" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb37-1303"><a href="#cb37-1303" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1306"><a href="#cb37-1306" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb37-1307"><a href="#cb37-1307" aria-hidden="true" tabindex="-1"></a>pop_df <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb37-1308"><a href="#cb37-1308" aria-hidden="true" tabindex="-1"></a>  <span class="st">"birth"</span> <span class="ot">=</span> <span class="sc">-</span><span class="fu">runif</span>(N, agemin, agemax), <span class="co"># Uniform age in [0,2]</span></span>
<span id="cb37-1309"><a href="#cb37-1309" aria-hidden="true" tabindex="-1"></a>  <span class="st">"death"</span> <span class="ot">=</span> <span class="fu">as.double</span>(<span class="cn">NA</span>), <span class="co"># All individuals are alive</span></span>
<span id="cb37-1310"><a href="#cb37-1310" aria-hidden="true" tabindex="-1"></a>  <span class="st">"birth_size"</span> <span class="ot">=</span> x0) <span class="co"># All individuals have the same initial birth size x0</span></span>
<span id="cb37-1311"><a href="#cb37-1311" aria-hidden="true" tabindex="-1"></a>pop_init <span class="ot">&lt;-</span> <span class="fu">population</span>(pop_df)</span>
<span id="cb37-1312"><a href="#cb37-1312" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb37-1313"><a href="#cb37-1313" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1314"><a href="#cb37-1314" aria-hidden="true" tabindex="-1"></a><span class="fu">## Events </span></span>
<span id="cb37-1315"><a href="#cb37-1315" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1316"><a href="#cb37-1316" aria-hidden="true" tabindex="-1"></a><span class="fu">### Birth events</span></span>
<span id="cb37-1317"><a href="#cb37-1317" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1318"><a href="#cb37-1318" aria-hidden="true" tabindex="-1"></a>The parameters involved in a birth event are the probability of mutation</span>
<span id="cb37-1319"><a href="#cb37-1319" aria-hidden="true" tabindex="-1"></a>$p$, the variance of the Gaussian random variable and the coefficient</span>
<span id="cb37-1320"><a href="#cb37-1320" aria-hidden="true" tabindex="-1"></a>$\alpha$ of the intensity.</span>
<span id="cb37-1323"><a href="#cb37-1323" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb37-1324"><a href="#cb37-1324" aria-hidden="true" tabindex="-1"></a>params_birth <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="st">"p"</span> <span class="ot">=</span> <span class="fl">0.03</span>, <span class="st">"sigma"</span> <span class="ot">=</span> <span class="fu">sqrt</span>(<span class="fl">0.01</span>), <span class="st">"alpha"</span> <span class="ot">=</span> <span class="dv">1</span>)</span>
<span id="cb37-1325"><a href="#cb37-1325" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb37-1326"><a href="#cb37-1326" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1327"><a href="#cb37-1327" aria-hidden="true" tabindex="-1"></a>The birth</span>
<span id="cb37-1328"><a href="#cb37-1328" aria-hidden="true" tabindex="-1"></a>intensity @eq-interaction-birth-intensity is of class <span class="in">`individual`</span>.</span>
<span id="cb37-1329"><a href="#cb37-1329" aria-hidden="true" tabindex="-1"></a>Hence, the event is created by calling the <span class="in">`mk_event_individual`</span></span>
<span id="cb37-1330"><a href="#cb37-1330" aria-hidden="true" tabindex="-1"></a>function. The size of the new individual is given in the kernel</span>
<span id="cb37-1331"><a href="#cb37-1331" aria-hidden="true" tabindex="-1"></a>following @eq-interaction-birth-kernel.</span>
<span id="cb37-1332"><a href="#cb37-1332" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1335"><a href="#cb37-1335" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb37-1336"><a href="#cb37-1336" aria-hidden="true" tabindex="-1"></a>birth_event <span class="ot">&lt;-</span> <span class="fu">mk_event_individual</span>( </span>
<span id="cb37-1337"><a href="#cb37-1337" aria-hidden="true" tabindex="-1"></a>  <span class="at">type =</span> <span class="st">"birth"</span>,</span>
<span id="cb37-1338"><a href="#cb37-1338" aria-hidden="true" tabindex="-1"></a>  <span class="at">intensity_code =</span> <span class="st">"result = alpha*(4 - I.birth_size);"</span>,</span>
<span id="cb37-1339"><a href="#cb37-1339" aria-hidden="true" tabindex="-1"></a>  <span class="at">kernel_code =</span> <span class="st">"if (CUnif() &lt; p)</span></span>
<span id="cb37-1340"><a href="#cb37-1340" aria-hidden="true" tabindex="-1"></a><span class="st">                   newI.birth_size = min(max(0.,CNorm(I.birth_size,sigma)),4.);</span></span>
<span id="cb37-1341"><a href="#cb37-1341" aria-hidden="true" tabindex="-1"></a><span class="st">                 else</span></span>
<span id="cb37-1342"><a href="#cb37-1342" aria-hidden="true" tabindex="-1"></a><span class="st">                   newI.birth_size = I.birth_size;"</span>)</span>
<span id="cb37-1343"><a href="#cb37-1343" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb37-1344"><a href="#cb37-1344" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1345"><a href="#cb37-1345" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1346"><a href="#cb37-1346" aria-hidden="true" tabindex="-1"></a><span class="fu">### Death events</span></span>
<span id="cb37-1347"><a href="#cb37-1347" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1348"><a href="#cb37-1348" aria-hidden="true" tabindex="-1"></a>The death</span>
<span id="cb37-1349"><a href="#cb37-1349" aria-hidden="true" tabindex="-1"></a>intensity @eq-interaction-death-intensity is of class <span class="in">`interaction`</span>.</span>
<span id="cb37-1350"><a href="#cb37-1350" aria-hidden="true" tabindex="-1"></a>Hence, the event is created by calling the <span class="in">`mk_event_interaction`</span></span>
<span id="cb37-1351"><a href="#cb37-1351" aria-hidden="true" tabindex="-1"></a>function. The parameters used for this event are the growth rate $g$,</span>
<span id="cb37-1352"><a href="#cb37-1352" aria-hidden="true" tabindex="-1"></a>the amplitude of the interaction function $\beta$, and the strength of</span>
<span id="cb37-1353"><a href="#cb37-1353" aria-hidden="true" tabindex="-1"></a>competition $c$.</span>
<span id="cb37-1354"><a href="#cb37-1354" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1357"><a href="#cb37-1357" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb37-1358"><a href="#cb37-1358" aria-hidden="true" tabindex="-1"></a>params_death <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="st">"g"</span> <span class="ot">=</span> <span class="dv">1</span>, <span class="st">"beta"</span> <span class="ot">=</span> <span class="fl">2.</span><span class="sc">/</span><span class="fl">300.</span>, <span class="st">"c"</span> <span class="ot">=</span> <span class="fl">1.2</span>)</span>
<span id="cb37-1359"><a href="#cb37-1359" aria-hidden="true" tabindex="-1"></a>death_event <span class="ot">&lt;-</span> <span class="fu">mk_event_interaction</span>(</span>
<span id="cb37-1360"><a href="#cb37-1360" aria-hidden="true" tabindex="-1"></a>  <span class="at">type =</span> <span class="st">"death"</span>,</span>
<span id="cb37-1361"><a href="#cb37-1361" aria-hidden="true" tabindex="-1"></a>  <span class="at">interaction_code =</span> <span class="st">"double x_I = I.birth_size + g * age(I,t);</span></span>
<span id="cb37-1362"><a href="#cb37-1362" aria-hidden="true" tabindex="-1"></a><span class="st">                      double x_J = J.birth_size + g * age(J,t);</span></span>
<span id="cb37-1363"><a href="#cb37-1363" aria-hidden="true" tabindex="-1"></a><span class="st">                      result = beta*(1.-1./(1.+c*exp(-4.*(x_I-x_J))));"</span>)</span>
<span id="cb37-1364"><a href="#cb37-1364" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb37-1365"><a href="#cb37-1365" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1366"><a href="#cb37-1366" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1367"><a href="#cb37-1367" aria-hidden="true" tabindex="-1"></a><span class="fu">## Model creation and simulation</span></span>
<span id="cb37-1368"><a href="#cb37-1368" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1369"><a href="#cb37-1369" aria-hidden="true" tabindex="-1"></a>The model is created using the <span class="in">`mk_model`</span> function.</span>
<span id="cb37-1370"><a href="#cb37-1370" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1371"><a href="#cb37-1371" aria-hidden="true" tabindex="-1"></a>The simulation of one scenario can then be launched with the call of the</span>
<span id="cb37-1372"><a href="#cb37-1372" aria-hidden="true" tabindex="-1"></a><span class="in">`popsim`</span> function, after computing the events bounds</span>
<span id="cb37-1373"><a href="#cb37-1373" aria-hidden="true" tabindex="-1"></a>$\bar \lambda^b=4 \alpha$ and $\bar W= \beta$.</span>
<span id="cb37-1374"><a href="#cb37-1374" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1377"><a href="#cb37-1377" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb37-1378"><a href="#cb37-1378" aria-hidden="true" tabindex="-1"></a>model <span class="ot">&lt;-</span> <span class="fu">mk_model</span>(</span>
<span id="cb37-1379"><a href="#cb37-1379" aria-hidden="true" tabindex="-1"></a>    <span class="at">characteristics =</span> <span class="fu">get_characteristics</span>(pop_init),</span>
<span id="cb37-1380"><a href="#cb37-1380" aria-hidden="true" tabindex="-1"></a>    <span class="at">events =</span> <span class="fu">list</span>(birth_event, death_event),</span>
<span id="cb37-1381"><a href="#cb37-1381" aria-hidden="true" tabindex="-1"></a>    <span class="at">parameters =</span> <span class="fu">c</span>(params_birth, params_death))</span>
<span id="cb37-1382"><a href="#cb37-1382" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb37-1383"><a href="#cb37-1383" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1384"><a href="#cb37-1384" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1385"><a href="#cb37-1385" aria-hidden="true" tabindex="-1"></a>The simulation of one scenario can then be launched with the call of the</span>
<span id="cb37-1386"><a href="#cb37-1386" aria-hidden="true" tabindex="-1"></a><span class="in">`popsim`</span> function, after computing the events bounds</span>
<span id="cb37-1387"><a href="#cb37-1387" aria-hidden="true" tabindex="-1"></a>$\bar \lambda^b=4 \alpha$ and $\bar W= \beta$.</span>
<span id="cb37-1388"><a href="#cb37-1388" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1391"><a href="#cb37-1391" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb37-1392"><a href="#cb37-1392" aria-hidden="true" tabindex="-1"></a>sim_out <span class="ot">&lt;-</span> <span class="fu">popsim</span>(<span class="at">model =</span> model,</span>
<span id="cb37-1393"><a href="#cb37-1393" aria-hidden="true" tabindex="-1"></a>    <span class="at">initial_population =</span> pop_init,</span>
<span id="cb37-1394"><a href="#cb37-1394" aria-hidden="true" tabindex="-1"></a>    <span class="at">events_bounds =</span> <span class="fu">c</span>(<span class="st">"birth"</span> <span class="ot">=</span> <span class="dv">4</span> <span class="sc">*</span> params_birth<span class="sc">$</span>alpha, </span>
<span id="cb37-1395"><a href="#cb37-1395" aria-hidden="true" tabindex="-1"></a>                      <span class="st">"death"</span> <span class="ot">=</span> params_death<span class="sc">$</span>beta),</span>
<span id="cb37-1396"><a href="#cb37-1396" aria-hidden="true" tabindex="-1"></a>    <span class="at">parameters =</span> <span class="fu">c</span>(params_birth, params_death),</span>
<span id="cb37-1397"><a href="#cb37-1397" aria-hidden="true" tabindex="-1"></a>    <span class="at">age_max =</span> <span class="dv">2</span>,</span>
<span id="cb37-1398"><a href="#cb37-1398" aria-hidden="true" tabindex="-1"></a>    <span class="at">time =</span> <span class="dv">500</span>)</span>
<span id="cb37-1399"><a href="#cb37-1399" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb37-1400"><a href="#cb37-1400" aria-hidden="true" tabindex="-1"></a>Based on the results of a simulation, we can reproduce the numerical</span>
<span id="cb37-1401"><a href="#cb37-1401" aria-hidden="true" tabindex="-1"></a>results of @FerTra09. In @fig-birth-size, we draw a line for each individual in the population to represent their birth size during their lifetime. </span>
<span id="cb37-1402"><a href="#cb37-1402" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1403"><a href="#cb37-1403" aria-hidden="true" tabindex="-1"></a><span class="in">```{r, echo=FALSE, fig.width=10}</span></span>
<span id="cb37-1404"><a href="#cb37-1404" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: fig-birth-size</span></span>
<span id="cb37-1405"><a href="#cb37-1405" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-cap: "Evolution of birth size"</span></span>
<span id="cb37-1406"><a href="#cb37-1406" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-pos: 'h'</span></span>
<span id="cb37-1407"><a href="#cb37-1407" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1408"><a href="#cb37-1408" aria-hidden="true" tabindex="-1"></a><span class="in">pop_out &lt;- sim_out$population</span></span>
<span id="cb37-1409"><a href="#cb37-1409" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1410"><a href="#cb37-1410" aria-hidden="true" tabindex="-1"></a><span class="in">ggplot(pop_out) + geom_segment(</span></span>
<span id="cb37-1411"><a href="#cb37-1411" aria-hidden="true" tabindex="-1"></a><span class="in">  aes(x=birth, xend=death, y=birth_size, yend=birth_size),</span></span>
<span id="cb37-1412"><a href="#cb37-1412" aria-hidden="true" tabindex="-1"></a><span class="in">  na.rm=TRUE, colour="blue", alpha=0.2) +</span></span>
<span id="cb37-1413"><a href="#cb37-1413" aria-hidden="true" tabindex="-1"></a><span class="in">  xlab("Time") +</span></span>
<span id="cb37-1414"><a href="#cb37-1414" aria-hidden="true" tabindex="-1"></a><span class="in">  ylab("Birth size")</span></span>
<span id="cb37-1415"><a href="#cb37-1415" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb37-1416"><a href="#cb37-1416" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1417"><a href="#cb37-1417" aria-hidden="true" tabindex="-1"></a>In this example, the randomized</span>
<span id="cb37-1418"><a href="#cb37-1418" aria-hidden="true" tabindex="-1"></a>@alg-randomized allows for much faster computation</span>
<span id="cb37-1419"><a href="#cb37-1419" aria-hidden="true" tabindex="-1"></a>times than the model implemented below with</span>
<span id="cb37-1420"><a href="#cb37-1420" aria-hidden="true" tabindex="-1"></a>@alg-interaction ("full" algorithm):</span>
<span id="cb37-1421"><a href="#cb37-1421" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1424"><a href="#cb37-1424" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb37-1425"><a href="#cb37-1425" aria-hidden="true" tabindex="-1"></a>death_event_full <span class="ot">&lt;-</span> <span class="fu">mk_event_interaction</span>(<span class="at">type =</span> <span class="st">"death"</span>,</span>
<span id="cb37-1426"><a href="#cb37-1426" aria-hidden="true" tabindex="-1"></a>                             <span class="at">interaction_type=</span> <span class="st">"full"</span>,</span>
<span id="cb37-1427"><a href="#cb37-1427" aria-hidden="true" tabindex="-1"></a>                             <span class="at">interaction_code =</span> <span class="st">"double x_I = I.birth_size + g * age(I,t);</span></span>
<span id="cb37-1428"><a href="#cb37-1428" aria-hidden="true" tabindex="-1"></a><span class="st">                                                 double x_J = J.birth_size + g * age(J,t);</span></span>
<span id="cb37-1429"><a href="#cb37-1429" aria-hidden="true" tabindex="-1"></a><span class="st">                                result = beta * ( 1.- 1./(1. + c * exp(-4. * (x_I-x_J))));"</span></span>
<span id="cb37-1430"><a href="#cb37-1430" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb37-1431"><a href="#cb37-1431" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1432"><a href="#cb37-1432" aria-hidden="true" tabindex="-1"></a>model_full <span class="ot">&lt;-</span> <span class="fu">mk_model</span>(<span class="at">characteristics =</span> <span class="fu">get_characteristics</span>(pop_init),</span>
<span id="cb37-1433"><a href="#cb37-1433" aria-hidden="true" tabindex="-1"></a>                       <span class="at">events =</span> <span class="fu">list</span>(birth_event, death_event_full),</span>
<span id="cb37-1434"><a href="#cb37-1434" aria-hidden="true" tabindex="-1"></a>                       <span class="at">parameters =</span> <span class="fu">c</span>(params_birth, params_death))</span>
<span id="cb37-1435"><a href="#cb37-1435" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1436"><a href="#cb37-1436" aria-hidden="true" tabindex="-1"></a>sim_out_full <span class="ot">&lt;-</span> <span class="fu">popsim</span>(<span class="at">model =</span> model_full,</span>
<span id="cb37-1437"><a href="#cb37-1437" aria-hidden="true" tabindex="-1"></a>                       <span class="at">initial_population =</span> pop_init,</span>
<span id="cb37-1438"><a href="#cb37-1438" aria-hidden="true" tabindex="-1"></a>                       <span class="at">events_bounds =</span><span class="fu">c</span>(<span class="st">"birth"</span> <span class="ot">=</span> <span class="dv">4</span> <span class="sc">*</span> params_birth<span class="sc">$</span>alpha,</span>
<span id="cb37-1439"><a href="#cb37-1439" aria-hidden="true" tabindex="-1"></a>                                        <span class="st">"death"</span> <span class="ot">=</span> params_death<span class="sc">$</span>beta),</span>
<span id="cb37-1440"><a href="#cb37-1440" aria-hidden="true" tabindex="-1"></a>                       <span class="at">parameters =</span> <span class="fu">c</span>(params_birth, params_death),</span>
<span id="cb37-1441"><a href="#cb37-1441" aria-hidden="true" tabindex="-1"></a>                       <span class="at">age_max =</span> <span class="dv">2</span>,</span>
<span id="cb37-1442"><a href="#cb37-1442" aria-hidden="true" tabindex="-1"></a>                       <span class="at">time =</span> <span class="dv">500</span>)</span>
<span id="cb37-1443"><a href="#cb37-1443" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1444"><a href="#cb37-1444" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb37-1445"><a href="#cb37-1445" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1446"><a href="#cb37-1446" aria-hidden="true" tabindex="-1"></a><span class="in">```{r echo=FALSE}</span></span>
<span id="cb37-1447"><a href="#cb37-1447" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1448"><a href="#cb37-1448" aria-hidden="true" tabindex="-1"></a><span class="in">print(paste("The full algorithm is " ,sim_out_full$logs["duration_ns"]/sim_out$logs["duration_ns"], " times slower than the randomized version", sep=""))</span></span>
<span id="cb37-1449"><a href="#cb37-1449" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb37-1450"><a href="#cb37-1450" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1451"><a href="#cb37-1451" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1452"><a href="#cb37-1452" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1453"><a href="#cb37-1453" aria-hidden="true" tabindex="-1"></a>In @fig-fullvsrandom, the two algorithms are compared for different population sizes.  </span>
<span id="cb37-1454"><a href="#cb37-1454" aria-hidden="true" tabindex="-1"></a>We progressively decrease the value of the mortality rate parameter $\beta$ and increase the birth</span>
<span id="cb37-1455"><a href="#cb37-1455" aria-hidden="true" tabindex="-1"></a>rate parameter $\alpha$. Starting with the values provided</span>
<span id="cb37-1456"><a href="#cb37-1456" aria-hidden="true" tabindex="-1"></a>in&nbsp;@FerTra09, $\alpha=1$ and $\beta=2/300$, resulting in a stationary</span>
<span id="cb37-1457"><a href="#cb37-1457" aria-hidden="true" tabindex="-1"></a>population size of approximately $N=360$ individuals for a sample of 50</span>
<span id="cb37-1458"><a href="#cb37-1458" aria-hidden="true" tabindex="-1"></a>simulations, we can easily increase the stationary population size to</span>
<span id="cb37-1459"><a href="#cb37-1459" aria-hidden="true" tabindex="-1"></a>approximately $N=2600$ individuals with $\alpha=2$ and $\beta=1/300$</span>
<span id="cb37-1460"><a href="#cb37-1460" aria-hidden="true" tabindex="-1"></a>.^[The choices</span>
<span id="cb37-1461"><a href="#cb37-1461" aria-hidden="true" tabindex="-1"></a>    $(\alpha, \beta) \in <span class="sc">\{</span>(1,2/300),(1, 1/300), (1.5, 1/300), (2, 1/300)<span class="sc">\}</span>$</span>
<span id="cb37-1462"><a href="#cb37-1462" aria-hidden="true" tabindex="-1"></a>    lead to the stationary population sizes</span>
<span id="cb37-1463"><a href="#cb37-1463" aria-hidden="true" tabindex="-1"></a>    $N \in <span class="sc">\{</span>360, 900, 1800, 2600<span class="sc">\}</span>$. For each set of parameters, we</span>
<span id="cb37-1464"><a href="#cb37-1464" aria-hidden="true" tabindex="-1"></a>    generated a new initial population, which was used for a benchmark</span>
<span id="cb37-1465"><a href="#cb37-1465" aria-hidden="true" tabindex="-1"></a>    of 50 simulations with both randomized and full algorithm. The</span>
<span id="cb37-1466"><a href="#cb37-1466" aria-hidden="true" tabindex="-1"></a>    simulations run on a Intel Core i7-8550U CPU 1.80GHz × 8 processor,</span>
<span id="cb37-1467"><a href="#cb37-1467" aria-hidden="true" tabindex="-1"></a>    with 15.3 GiB of RAM, under Debian GNU/Linux 11.] In the log-scaled figure, we can observe the trend of computation</span>
<span id="cb37-1468"><a href="#cb37-1468" aria-hidden="true" tabindex="-1"></a>time as a function of the population size $N$, which is linear for the</span>
<span id="cb37-1469"><a href="#cb37-1469" aria-hidden="true" tabindex="-1"></a>randomized algorithm and quadratic for the full one (</span>
<span id="cb37-1470"><a href="#cb37-1470" aria-hidden="true" tabindex="-1"></a> @alg-interaction). We can also see that the</span>
<span id="cb37-1471"><a href="#cb37-1471" aria-hidden="true" tabindex="-1"></a>randomized version of the algorithm is between 17 to 100 times faster</span>
<span id="cb37-1472"><a href="#cb37-1472" aria-hidden="true" tabindex="-1"></a>than the full one in this example, taking only 2 seconds in average for</span>
<span id="cb37-1473"><a href="#cb37-1473" aria-hidden="true" tabindex="-1"></a>the randomized version versus 211 seconds for </span>
<span id="cb37-1474"><a href="#cb37-1474" aria-hidden="true" tabindex="-1"></a>@alg-interaction for the biggest population size</span>
<span id="cb37-1475"><a href="#cb37-1475" aria-hidden="true" tabindex="-1"></a>($N=2600$) and $T=500$.</span>
<span id="cb37-1476"><a href="#cb37-1476" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1477"><a href="#cb37-1477" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1478"><a href="#cb37-1478" aria-hidden="true" tabindex="-1"></a><span class="al">![Full vs random algorithm computztion time](img/time_pop_size.png)</span>{#fig-fullvsrandom width=80%}</span>
<span id="cb37-1479"><a href="#cb37-1479" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1480"><a href="#cb37-1480" aria-hidden="true" tabindex="-1"></a><span class="fu"># Appendix {.appendix} </span></span>
<span id="cb37-1481"><a href="#cb37-1481" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1482"><a href="#cb37-1482" aria-hidden="true" tabindex="-1"></a><span class="fu">## Recall on Poisson random measures {#sec-recall-poisson} </span></span>
<span id="cb37-1483"><a href="#cb37-1483" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1484"><a href="#cb37-1484" aria-hidden="true" tabindex="-1"></a>We recall below some useful properties of Poisson random measures,</span>
<span id="cb37-1485"><a href="#cb37-1485" aria-hidden="true" tabindex="-1"></a>mainly following Chapter&nbsp;6 of&nbsp;<span class="co">[</span><span class="ot">@Cin11</span><span class="co">]</span>. We also refer to&nbsp;<span class="co">[</span><span class="ot">@Kal17</span><span class="co">]</span> for a</span>
<span id="cb37-1486"><a href="#cb37-1486" aria-hidden="true" tabindex="-1"></a>more comprehensive presentation of random counting measures.</span>
<span id="cb37-1487"><a href="#cb37-1487" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1488"><a href="#cb37-1488" aria-hidden="true" tabindex="-1"></a>::: {#def-poisson-random-measure} </span>
<span id="cb37-1489"><a href="#cb37-1489" aria-hidden="true" tabindex="-1"></a><span class="fu">## Poisson Random Measures</span></span>
<span id="cb37-1490"><a href="#cb37-1490" aria-hidden="true" tabindex="-1"></a>Let $\mu$ be a $\sigma$-finite diffuse measure on a Borel subspace $(E,\mathcal{E})$ of $({\mathbb{R}}^d, \mathcal{B}({\mathbb{R}}^d))$. A random counting measure $Q= \sum_{k\geq 1} \delta_{X_k}$ is a Poisson (counting) random measure of *mean measure* $\mu$ if</span>
<span id="cb37-1491"><a href="#cb37-1491" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1492"><a href="#cb37-1492" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>$\forall A \in \mathcal{E}$, $Q(A)$ is a Poisson random variable with ${\mathbb{E}}<span class="co">[</span><span class="ot">Q(A)</span><span class="co">]</span>= \mu(A)$. </span>
<span id="cb37-1493"><a href="#cb37-1493" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>For all disjoints subsets $A_1, \dots, A_n \in \mathcal{E}$, $Q(A_1), \dots, Q(A_n)$ are independent Poisson random variables.</span>
<span id="cb37-1494"><a href="#cb37-1494" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb37-1495"><a href="#cb37-1495" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1496"><a href="#cb37-1496" aria-hidden="true" tabindex="-1"></a>Let us briefly recall here some simple but useful operations on Poisson measures. In the following, $Q$ is a Poisson measure of mean measure $\mu$, unless stated otherwise.</span>
<span id="cb37-1497"><a href="#cb37-1497" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1498"><a href="#cb37-1498" aria-hidden="true" tabindex="-1"></a>::: {#prp-restriction-poisson-measure}</span>
<span id="cb37-1499"><a href="#cb37-1499" aria-hidden="true" tabindex="-1"></a><span class="fu">## Restricted Poisson measure</span></span>
<span id="cb37-1500"><a href="#cb37-1500" aria-hidden="true" tabindex="-1"></a>If $B \in \mathcal{E}$, then, the restriction of $Q$ to $B$ defined by </span>
<span id="cb37-1501"><a href="#cb37-1501" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-1502"><a href="#cb37-1502" aria-hidden="true" tabindex="-1"></a>    Q^B = \boldsymbol{1}_B Q = \sum_{k \ge 1} \mathbf{1}_{B}(X_k) \delta_{X_k}</span>
<span id="cb37-1503"><a href="#cb37-1503" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-1504"><a href="#cb37-1504" aria-hidden="true" tabindex="-1"></a>is also a Poisson random measure, of mean measure $\mu^B = \mu(\cdot \cap B)$.</span>
<span id="cb37-1505"><a href="#cb37-1505" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb37-1506"><a href="#cb37-1506" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1507"><a href="#cb37-1507" aria-hidden="true" tabindex="-1"></a>::: {#prp-proj-poisson-measure}</span>
<span id="cb37-1508"><a href="#cb37-1508" aria-hidden="true" tabindex="-1"></a><span class="fu">## Projection of Poisson measure</span></span>
<span id="cb37-1509"><a href="#cb37-1509" aria-hidden="true" tabindex="-1"></a>If $E = F_1 \times F_2$ is a product space, then the projection</span>
<span id="cb37-1510"><a href="#cb37-1510" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-1511"><a href="#cb37-1511" aria-hidden="true" tabindex="-1"></a>    Q_1(\mathrm{d}x) = \int_{F_2} Q(\mathrm{d}x , \mathrm{d}y)</span>
<span id="cb37-1512"><a href="#cb37-1512" aria-hidden="true" tabindex="-1"></a>$$ </span>
<span id="cb37-1513"><a href="#cb37-1513" aria-hidden="true" tabindex="-1"></a>is a Poisson random measure of mean measure $\mu_1 (\mathrm{d}x ) = \int_{F_2} \mu(\mathrm{d}x, \mathrm{d}y)$.</span>
<span id="cb37-1514"><a href="#cb37-1514" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb37-1515"><a href="#cb37-1515" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1516"><a href="#cb37-1516" aria-hidden="true" tabindex="-1"></a><span class="fu">### Link with Poisson processes</span></span>
<span id="cb37-1517"><a href="#cb37-1517" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1518"><a href="#cb37-1518" aria-hidden="true" tabindex="-1"></a>Let $Q= \sum_{k\geq 1} \delta_{T_k}$ a Poisson random measure on $E={\mathbb{R}}^+$ with mean measure $\mu(\mathrm{d}t) = \Lambda (t) \mathrm{d}t$ absolutely continuous with respect to the Lebesgue measure, $\mu(A) = \int_A \Lambda(t) \mathrm{d}t$. </span>
<span id="cb37-1519"><a href="#cb37-1519" aria-hidden="true" tabindex="-1"></a>The counting process</span>
<span id="cb37-1520"><a href="#cb37-1520" aria-hidden="true" tabindex="-1"></a>$(N_t)_{t \ge 0}$ defined by </span>
<span id="cb37-1521"><a href="#cb37-1521" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-1522"><a href="#cb37-1522" aria-hidden="true" tabindex="-1"></a>    N_t = Q(<span class="co">[</span><span class="ot">0,t</span><span class="co">]</span>) = \sum_{k \geq 1} \boldsymbol{1}_{<span class="sc">\{</span>T_k \leq t<span class="sc">\}</span>}, \quad \forall \; t\geq 0,</span>
<span id="cb37-1523"><a href="#cb37-1523" aria-hidden="true" tabindex="-1"></a>$$ {#eq-inhomogeneous-pp}</span>
<span id="cb37-1524"><a href="#cb37-1524" aria-hidden="true" tabindex="-1"></a>is an inhomogeneous Poisson process with intensity function (or rate) $t \mapsto \Lambda(t)$. In particular, when $\Lambda(t) \equiv c$ is a constant, $N$ is a homogeneous Poisson process with rate $c$. Assuming that the atoms are ordered $T_1&lt; T_2&lt; \dots$, we recall that the sequence $(T_{k+1}-T_k)_{k\geq 1}$ is a sequence of *i.i.d.* exponential variables of parameter $c$.</span>
<span id="cb37-1525"><a href="#cb37-1525" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1526"><a href="#cb37-1526" aria-hidden="true" tabindex="-1"></a><span class="fu">### Marked Poisson measures on $E = {\mathbb{R}}^+ \times F$</span></span>
<span id="cb37-1527"><a href="#cb37-1527" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1528"><a href="#cb37-1528" aria-hidden="true" tabindex="-1"></a>We are interested in the particular case when $E$ is the product space ${\mathbb{R}}^+ \times F$, with $(F,\mathcal{F})$ a Borel subspace of ${\mathbb{R}}^d$. Then, a random counting measure is defined by a random set $S =<span class="sc">\{</span> (T_k, \Theta_k ), k \geq 1<span class="sc">\}</span>$. The random variables $T_k\geq 0$ can be considered as time variables, and constitute the jump times of the random measure, while the variables $\Theta_k \in F$ represent space variables.</span>
<span id="cb37-1529"><a href="#cb37-1529" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1530"><a href="#cb37-1530" aria-hidden="true" tabindex="-1"></a>We recall in this special case the Theorem&nbsp;VI.3.2 in&nbsp;<span class="co">[</span><span class="ot">@Cin11</span><span class="co">]</span>.</span>
<span id="cb37-1531"><a href="#cb37-1531" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1532"><a href="#cb37-1532" aria-hidden="true" tabindex="-1"></a>::: {#prp-marked-poisson}</span>
<span id="cb37-1533"><a href="#cb37-1533" aria-hidden="true" tabindex="-1"></a><span class="fu">## Marked Poisson measure </span></span>
<span id="cb37-1534"><a href="#cb37-1534" aria-hidden="true" tabindex="-1"></a>Let $m$ be a $\sigma$--finite diffuse measure on ${\mathbb{R}}^+$, and $K$ a transition probability kernel from $({\mathbb{R}}^+,\mathcal{B}({\mathbb{R}}^+))$ into $(F, \mathcal{F})$. </span>
<span id="cb37-1535"><a href="#cb37-1535" aria-hidden="true" tabindex="-1"></a>Assume that the collection $(T_k)_{k \ge 1}$ forms a Poisson process $(N_t) =(\sum_{k\geq 1} \mathsf{1}_{\{T_k \leq t\}})$ with mean $m(\mathrm{d}t) =\Lambda(t) \mathrm{d}t$, and that given $(T_k)_{k \ge 1}$, the variables $\Theta_k$ are conditionally independent and have the respective distributions $K(T_k, \cdot)$.</span>
<span id="cb37-1536"><a href="#cb37-1536" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1537"><a href="#cb37-1537" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Then, $<span class="sc">\{</span> (T_k, \Theta_k) ;\; k \ge 1\}$ forms a Poisson random measure $Q = \sum_{k\ge 1} \delta_{(T_k, \Theta_k)}$ on $({\mathbb{R}}^+ \times F, \mathcal{B}({\mathbb{R}}^+) \otimes \mathcal{F})$, called a *Marked point process* , with mean $\mu$ defined by </span>
<span id="cb37-1538"><a href="#cb37-1538" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-1539"><a href="#cb37-1539" aria-hidden="true" tabindex="-1"></a>    \mu(\mathrm{d}t, \mathrm{d}y) = \Lambda(t) \mathrm{d}t K(t, \mathrm{d}y).</span>
<span id="cb37-1540"><a href="#cb37-1540" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-1541"><a href="#cb37-1541" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1542"><a href="#cb37-1542" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Reciprocally let $Q$ be a Poisson random measure of mean measure $\mu(\mathrm{d}t, \mathrm{d}y)$, admitting the following disintegration with respect to the first coordinate: $\mu(\mathrm{d}t , \mathrm{d}y) =\tilde  \Lambda(t) \mathrm{d}t \nu(t, \mathrm{d}y)$, with $\nu(t, F)&lt;\infty$. </span>
<span id="cb37-1543"><a href="#cb37-1543" aria-hidden="true" tabindex="-1"></a>Let $K(t, \mathrm{d}y) = \dfrac{\nu(t,\mathrm{d}y) }{\nu(t, F) }$ and $\Lambda(t) = \nu(t, F)\tilde  \Lambda(t)$. Then, $Q = \sum_{k\ge 1} \delta_{(T_k, \Theta_k)}$ is a marked Poisson measure with $(T_k,\Theta_k)_{k\in {\mathbb{N}}^*}$ defined as above. </span>
<span id="cb37-1544"><a href="#cb37-1544" aria-hidden="true" tabindex="-1"></a>In particular, the projection $N= (N_t)_{t\geq0}$ of the Poisson measure on the first coordinate,</span>
<span id="cb37-1545"><a href="#cb37-1545" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-1546"><a href="#cb37-1546" aria-hidden="true" tabindex="-1"></a>    N_t = Q([0,t] \times F) = \sum_{k\geq 1} \boldsymbol{1}_{[0,t] \times F} (T_k, \Theta_k)  = \sum_{k\geq 1} \boldsymbol{1}_{<span class="sc">\{</span>T_k \leq t<span class="sc">\}</span>}, \quad \forall \; t \geq 0,</span>
<span id="cb37-1547"><a href="#cb37-1547" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-1548"><a href="#cb37-1548" aria-hidden="true" tabindex="-1"></a>is an inhomogeneous Poisson process of rate $\Lambda(t)= \nu(t, F)\tilde  \Lambda(t)$.</span>
<span id="cb37-1549"><a href="#cb37-1549" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb37-1550"><a href="#cb37-1550" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1551"><a href="#cb37-1551" aria-hidden="true" tabindex="-1"></a>::: {#rem}</span>
<span id="cb37-1552"><a href="#cb37-1552" aria-hidden="true" tabindex="-1"></a>When the transition probability kernel $K$ does not depend on the time: $K(t, A) = \nu(A)$ for some probability measure $\nu$, then the marks $(\Theta_k)_{k \ge 1}$ form an *i.i.d.* sequence with distribution $\nu$, independent of $(T_k)_{k \ge 1}$.</span>
<span id="cb37-1553"><a href="#cb37-1553" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb37-1554"><a href="#cb37-1554" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1555"><a href="#cb37-1555" aria-hidden="true" tabindex="-1"></a>The preceding proposition thus yields a straight forward iterative simulation procedure for a Marked Poisson process on $<span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>\times F$ with mean measure $\mu(\mathrm{d}t, \mathrm{d}y) = c \mathrm{d}t K(t, \mathrm{d}y)$ and $c&gt;0$. The procedure is described in @alg-marked-poisson.</span>
<span id="cb37-1556"><a href="#cb37-1556" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1557"><a href="#cb37-1557" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1558"><a href="#cb37-1558" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1559"><a href="#cb37-1559" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1560"><a href="#cb37-1560" aria-hidden="true" tabindex="-1"></a>!<span class="co">[</span><span class="ot">Example of Marked Poisson measure on $[0,T</span><span class="co">]</span>$ with $m(\mathrm{d} t) = L \mathrm{d} t$ (jump times occur at Poisson arrival times of rate $L$) and with $\nu(\mathrm{d} y) = \frac{1}{L} \mathbf{1}_{<span class="co">[</span><span class="ot">0, L</span><span class="co">]</span>}(y) \mathrm{d} y$ (marks are drawn uniformly on $<span class="co">[</span><span class="ot">0,L</span><span class="co">]</span>$).</span>
<span id="cb37-1561"><a href="#cb37-1561" aria-hidden="true" tabindex="-1"></a>The mean measure is then $\mu(\mathrm{d} t, \mathrm{d} y) = \mathrm{d} t {1}_{<span class="co">[</span><span class="ot">0,L</span><span class="co">]</span>}(y) \mathrm{d} y$.](img/plot_poisson.tex){#fig-poisson}</span>
<span id="cb37-1562"><a href="#cb37-1562" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1563"><a href="#cb37-1563" aria-hidden="true" tabindex="-1"></a><span class="fu">## Pathwise representation of IBMs {#sec-pathwise-representation}</span></span>
<span id="cb37-1564"><a href="#cb37-1564" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1565"><a href="#cb37-1565" aria-hidden="true" tabindex="-1"></a><span class="fu">### Notation reminder</span></span>
<span id="cb37-1566"><a href="#cb37-1566" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1567"><a href="#cb37-1567" aria-hidden="true" tabindex="-1"></a>The population's evolution is described by the measure valued process $(Z_t)_{t\geq 0}$. Several types of events $e$ can occur to individuals denoted by $I$. In an event of type $e$ occur to the individual $I$ at time $t$, then the population state $Z_{t^-}$ is modified by $\phi^e(t,I)$. </span>
<span id="cb37-1568"><a href="#cb37-1568" aria-hidden="true" tabindex="-1"></a>If $e\in \mathcal{E} \cup \mathcal{E}_W$, then events of type $e$ occur with an intensity $\sum_{k=1}^{N_t} \lambda_t^e(I,Z_t)$, with $\lambda_t^e(I,Z_t)$ defined by @eq-individual-intensity. </span>
<span id="cb37-1569"><a href="#cb37-1569" aria-hidden="true" tabindex="-1"></a>If $e \in \mathcal{P}$, then events of type $e$ occur in the population at a Poisson intensity of $(\mu^e_t)$.</span>
<span id="cb37-1570"><a href="#cb37-1570" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1571"><a href="#cb37-1571" aria-hidden="true" tabindex="-1"></a><span class="fu">### Proof of @thm-eq-Z {#sec-prf-thm-eq-Z} </span></span>
<span id="cb37-1572"><a href="#cb37-1572" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1573"><a href="#cb37-1573" aria-hidden="true" tabindex="-1"></a>::: {.proof}</span>
<span id="cb37-1574"><a href="#cb37-1574" aria-hidden="true" tabindex="-1"></a>For ease of notation, we prove the case when $\mathcal{P} =\emptyset$ (there are no events with Poisson intensity).</span>
<span id="cb37-1575"><a href="#cb37-1575" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1576"><a href="#cb37-1576" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Step 1. The existence of a solution to @eq-sde-eq-Z is obtained by induction. Let $Z^1$ be the unique solution the thinning equation:</span>
<span id="cb37-1577"><a href="#cb37-1577" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-1578"><a href="#cb37-1578" aria-hidden="true" tabindex="-1"></a>    Z_t^1 = Z_0 + \int_0^t \int_{ \mathcal{J}\times \mathbb R^+ }\phi^e (s , I_k)  \mathbf{1}_{\{k \leq N_{0}\} }\mathbf{1}_{\{\theta \leq \lambda_s^e(I_k, Z_{0})<span class="sc">\}</span>} Q (\mathrm{d}s,\mathrm{d}k , \mathrm{d}e, \mathrm{d}\theta ), \quad \forall  0 \leq t \leq T.</span>
<span id="cb37-1579"><a href="#cb37-1579" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-1580"><a href="#cb37-1580" aria-hidden="true" tabindex="-1"></a>Let $T_1$ be the first jump time of $Z^1$. Since $Z_{s^-}^1 = Z_{0}$ and $N_{s^-}=N_{0}$ on $<span class="co">[</span><span class="ot">0, T_1</span><span class="co">]</span>$, $Z^1$ is solution of @eq-sde-eq-Z on $<span class="co">[</span><span class="ot">0,T_1</span><span class="co">]</span>$.</span>
<span id="cb37-1581"><a href="#cb37-1581" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1582"><a href="#cb37-1582" aria-hidden="true" tabindex="-1"></a>Let us now assume that @eq-sde-eq-Z admits a solution $Z^n$ on $<span class="co">[</span><span class="ot">0,T_n</span><span class="co">]</span>$, with $T_n$ the $n$--th event time in the population. Let $Z^{n+1}$ be the unique solution of the thinning equation:</span>
<span id="cb37-1583"><a href="#cb37-1583" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-1584"><a href="#cb37-1584" aria-hidden="true" tabindex="-1"></a>    Z^{n+1}_t  =  Z_{t\wedge T_n}^n + \int_{t\wedge T_n}^{t} \int_{ \mathcal{J}\times \mathbb R^+ }\phi^e (s , I_k)  \mathbf{1}_{\{\theta \leq \lambda_s^e(I_k, Z_{T_n}^n)\}} \mathbf{1}_{\{k \leq N_{T_n}^n <span class="sc">\}</span> }Q (\mathrm{d}s ,\mathrm{d}k , \mathrm{d}e, \mathrm{d}\theta ).</span>
<span id="cb37-1585"><a href="#cb37-1585" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-1586"><a href="#cb37-1586" aria-hidden="true" tabindex="-1"></a>First, observe that $Z^{n+1}$ coincides with $Z^n$ on $<span class="co">[</span><span class="ot">0,T_n</span><span class="co">]</span>$. Let $T_{n+1}$ be the $(n+1)$--th jump of $Z^{n+1}$. Furthermore, $Z_{s^-}^{n+1} = Z_{T_n}^n$ and $N_{s^-}^{n+1}=N_{T_n}^{n}$ on $<span class="co">[</span><span class="ot">T_n, T_{n+1}</span><span class="co">]</span>$ (nothing happens between two successive event times), $Z^{n+1}$ verifies for all $t\leq T_{n+1}$: </span>
<span id="cb37-1587"><a href="#cb37-1587" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb37-1588"><a href="#cb37-1588" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb37-1589"><a href="#cb37-1589" aria-hidden="true" tabindex="-1"></a>    Z^{n+1}_t  =  Z_{t\wedge T_n}^n +\int_{t\wedge T_n}^{t} \int_{ \mathcal{J}\times \mathbb R^+ }\phi^e (s , I_k)  \mathbf{1}_{\{\theta \leq \lambda_s^e(I_k, Z_{s^-}^{n+1} )\}} \mathbf{1}_{\{k \leq N_{s^-}^{n+1} <span class="sc">\}</span> }Q (\mathrm{d}s ,\mathrm{d}k , \mathrm{d}e, \mathrm{d}\theta ).</span>
<span id="cb37-1590"><a href="#cb37-1590" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb37-1591"><a href="#cb37-1591" aria-hidden="true" tabindex="-1"></a>$$ </span>
<span id="cb37-1592"><a href="#cb37-1592" aria-hidden="true" tabindex="-1"></a>Since, $Z^n$ is a solution of @eq-sde-eq-Z on $<span class="co">[</span><span class="ot">0,T_n</span><span class="co">]</span>$ coinciding with $Z^{n+1}$, this achieves to prove that $Z^{n+1}$ is solution of @eq-sde-eq-Z on $<span class="co">[</span><span class="ot">0,T_{n+1}</span><span class="co">]</span>$.</span>
<span id="cb37-1593"><a href="#cb37-1593" aria-hidden="true" tabindex="-1"></a>Finally, let $Z =\lim_{n\to \infty } Z^n$. For all $n\geq 1$, $T_n$ is the $n$--th event time of $Z$, and $Z$ is solution of @eq-sde-eq-Z on all time intervals $<span class="co">[</span><span class="ot">0,T_n\wedge T</span><span class="co">]</span>$ by construction.</span>
<span id="cb37-1594"><a href="#cb37-1594" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1595"><a href="#cb37-1595" aria-hidden="true" tabindex="-1"></a>By @lem-non-explosion $T_n \underset{n\to \infty}{\longrightarrow} \infty$. Thus, by letting $n\to \infty$ we can conclude that $Z$ is a solution of @eq-sde-eq-Z on $<span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>$.</span>
<span id="cb37-1596"><a href="#cb37-1596" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1597"><a href="#cb37-1597" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Step 2. Let $\tilde Z$ be a solution of @eq-sde-eq-Z. Using the same arguments than in Step 1, it is straight forward to show that $\tilde Z$ coincides with $Z^n$ on $<span class="co">[</span><span class="ot">0,T_n</span><span class="co">]</span>$, for all $n \geq 1$. Thus, $\tilde{Z} = Z$, with achieves to prove uniqueness.</span>
<span id="cb37-1598"><a href="#cb37-1598" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb37-1599"><a href="#cb37-1599" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1600"><a href="#cb37-1600" aria-hidden="true" tabindex="-1"></a><span class="fu">### Proof of @lem-non-explosion {#sec-prf-lem-non-explosion} </span></span>
<span id="cb37-1601"><a href="#cb37-1601" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1602"><a href="#cb37-1602" aria-hidden="true" tabindex="-1"></a>The proof is obtained using pathwise comparison result, generalizing those obtained in <span class="co">[</span><span class="ot">@KaaElK20</span><span class="co">]</span>.</span>
<span id="cb37-1603"><a href="#cb37-1603" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1604"><a href="#cb37-1604" aria-hidden="true" tabindex="-1"></a>::: {.proof}</span>
<span id="cb37-1605"><a href="#cb37-1605" aria-hidden="true" tabindex="-1"></a>TODO</span>
<span id="cb37-1606"><a href="#cb37-1606" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb37-1607"><a href="#cb37-1607" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1608"><a href="#cb37-1608" aria-hidden="true" tabindex="-1"></a><span class="fu">### Alternative pathwise representation </span></span>
<span id="cb37-1609"><a href="#cb37-1609" aria-hidden="true" tabindex="-1"></a>TODO</span>
<span id="cb37-1610"><a href="#cb37-1610" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1611"><a href="#cb37-1611" aria-hidden="true" tabindex="-1"></a><span class="fu">## Proof of @thm-interaction {#sec-prf-thm-interaction}</span></span>
<span id="cb37-1612"><a href="#cb37-1612" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1613"><a href="#cb37-1613" aria-hidden="true" tabindex="-1"></a>TODO</span>
<span id="cb37-1614"><a href="#cb37-1614" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1615"><a href="#cb37-1615" aria-hidden="true" tabindex="-1"></a><span class="fu"># References {.unnumbered}</span></span>
<span id="cb37-1616"><a href="#cb37-1616" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1617"><a href="#cb37-1617" aria-hidden="true" tabindex="-1"></a>::: {#refs}</span>
<span id="cb37-1618"><a href="#cb37-1618" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb37-1619"><a href="#cb37-1619" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1620"><a href="#cb37-1620" aria-hidden="true" tabindex="-1"></a><span class="fu"># Session information {.appendix .unnumbered}</span></span>
<span id="cb37-1621"><a href="#cb37-1621" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-1622"><a href="#cb37-1622" aria-hidden="true" tabindex="-1"></a><span class="in">```{r session-info}</span></span>
<span id="cb37-1623"><a href="#cb37-1623" aria-hidden="true" tabindex="-1"></a><span class="in">sessionInfo()</span></span>
<span id="cb37-1624"><a href="#cb37-1624" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->
<script>
(function(d) {
  d.querySelectorAll(".pseudocode-container").forEach(function(el) {
    let pseudocodeOptions = {
      indentSize: el.dataset.indentSize || "1.2em",
      commentDelimiter: el.dataset.commentDelimiter || "//",
      lineNumber: el.dataset.lineNumber === "true" ? true : false,
      lineNumberPunc: el.dataset.lineNumberPunc || ":",
      noEnd: el.dataset.noEnd === "true" ? true : false,
      titlePrefix: el.dataset.algTitle || "Algorithm"
    };
    pseudocode.renderElement(el.querySelector(".pseudocode"), pseudocodeOptions);
  });
})(document);
(function(d) {
  d.querySelectorAll(".pseudocode-container").forEach(function(el) {
    titleSpan = el.querySelector(".ps-root > .ps-algorithm > .ps-line > .ps-keyword")
    titlePrefix = el.dataset.algTitle;
    titleIndex = el.dataset.chapterLevel ? el.dataset.chapterLevel + "." + el.dataset.pseudocodeIndex : el.dataset.pseudocodeIndex;
    titleSpan.innerHTML = titlePrefix + " " + titleIndex + " ";
  });
})(document);
</script>
<script>
(function(d) {
  d.querySelectorAll(".pseudocode-container").forEach(function(el) {
    let pseudocodeOptions = {
      indentSize: el.dataset.indentSize || "1.2em",
      commentDelimiter: el.dataset.commentDelimiter || "//",
      lineNumber: el.dataset.lineNumber === "true" ? true : false,
      lineNumberPunc: el.dataset.lineNumberPunc || ":",
      noEnd: el.dataset.noEnd === "true" ? true : false,
      titlePrefix: el.dataset.algTitle || "Algorithm"
    };
    pseudocode.renderElement(el.querySelector(".pseudocode"), pseudocodeOptions);
  });
})(document);
(function(d) {
  d.querySelectorAll(".pseudocode-container").forEach(function(el) {
    titleSpan = el.querySelector(".ps-root > .ps-algorithm > .ps-line > .ps-keyword")
    titlePrefix = el.dataset.algTitle;
    titleIndex = el.dataset.chapterLevel ? el.dataset.chapterLevel + "." + el.dataset.pseudocodeIndex : el.dataset.pseudocodeIndex;
    titleSpan.innerHTML = titlePrefix + " " + titleIndex + " ";
  });
})(document);
</script>
<script>
(function(d) {
  d.querySelectorAll(".pseudocode-container").forEach(function(el) {
    let pseudocodeOptions = {
      indentSize: el.dataset.indentSize || "1.2em",
      commentDelimiter: el.dataset.commentDelimiter || "//",
      lineNumber: el.dataset.lineNumber === "true" ? true : false,
      lineNumberPunc: el.dataset.lineNumberPunc || ":",
      noEnd: el.dataset.noEnd === "true" ? true : false,
      titlePrefix: el.dataset.algTitle || "Algorithm"
    };
    pseudocode.renderElement(el.querySelector(".pseudocode"), pseudocodeOptions);
  });
})(document);
(function(d) {
  d.querySelectorAll(".pseudocode-container").forEach(function(el) {
    titleSpan = el.querySelector(".ps-root > .ps-algorithm > .ps-line > .ps-keyword")
    titlePrefix = el.dataset.algTitle;
    titleIndex = el.dataset.chapterLevel ? el.dataset.chapterLevel + "." + el.dataset.pseudocodeIndex : el.dataset.pseudocodeIndex;
    titleSpan.innerHTML = titlePrefix + " " + titleIndex + " ";
  });
})(document);
</script>




</body></html>