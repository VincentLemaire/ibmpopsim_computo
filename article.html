<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.551">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Daphné Giorgi">
<meta name="author" content="Vincent Lemaire">
<meta name="author" content="Sarah Kaakai">
<meta name="dcterms.date" content="2024-03-18">
<meta name="keywords" content="Individual-based models, stochastic simulation, population dynamics, Poisson measures, thinning method, actuarial science, insurance portfolio simulation">
<meta name="description" content="TODO">

<title>Efficient simulation of individual-based population models</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="article_files/libs/clipboard/clipboard.min.js"></script>
<script src="article_files/libs/quarto-html/quarto.js"></script>
<script src="article_files/libs/quarto-html/popper.min.js"></script>
<script src="article_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="article_files/libs/quarto-html/anchor.min.js"></script>
<link href="article_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="article_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="article_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="article_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="article_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script src="article_files/libs/quarto-contrib/pseudocode-2.4/pseudocode.min.js"></script>
<link href="article_files/libs/quarto-contrib/pseudocode-2.4/pseudocode.min.css" rel="stylesheet">
<style>

      .quarto-title-block .quarto-title-banner h1,
      .quarto-title-block .quarto-title-banner h2,
      .quarto-title-block .quarto-title-banner h3,
      .quarto-title-block .quarto-title-banner h4,
      .quarto-title-block .quarto-title-banner h5,
      .quarto-title-block .quarto-title-banner h6
      {
        color: #FFFFFF;
      }

      .quarto-title-block .quarto-title-banner {
        color: #FFFFFF;
background: #034E79;
      }
</style>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body>

<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <div class="quarto-title-block"><div><h1 class="title"><a href="https://computo.sfds.asso.fr">
        <img src="https://computo.sfds.asso.fr/assets/img/logo_notext_white.png" height="60px">
      </a> &nbsp; Efficient simulation of individual-based population models</h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> source</button></div></div>
            <p class="subtitle lead">The <code>R</code> package <code>IBMPopSim</code></p>
            <p><a href="http://creativecommons.org/licenses/by/4.0/"><img src="https://i.creativecommons.org/l/by/4.0/80x15.png" alt="Creative Commons BY License"></a>
ISSN 2824-7795</p>
            <div>
        <div class="description">
          <p>TODO</p>
        </div>
      </div>
                </div>
  </div>
    
    <div class="quarto-title-meta-author">
      <div class="quarto-title-meta-heading">Authors</div>
      <div class="quarto-title-meta-heading">Affiliations</div>
          
          <div class="quarto-title-meta-contents">
        <a href="https://perso.lpsm.paris/~giorgi/">Daphné Giorgi</a> 
      </div>
          
          <div class="quarto-title-meta-contents">
              <p class="affiliation">
                  <a href="https://www.lpsm.paris/">
                  Sorbonne Université, CNRS
                  </a>
                </p>
            </div>
            <div class="quarto-title-meta-contents">
        <a href="https://perso.lpsm.paris/~vlemaire/">Vincent Lemaire</a> <a href="https://orcid.org/0000-0002-0433-7722" class="quarto-title-author-orcid"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg=="></a>
      </div>
          
          <div class="quarto-title-meta-contents">
              <p class="affiliation">
                  <a href="https://www.lpsm.paris/">
                  Sorbonne Université, CNRS
                  </a>
                </p>
            </div>
            <div class="quarto-title-meta-contents">
        <a href="https://perso.univ-lemans.fr/~skaakai/">Sarah Kaakai</a> 
      </div>
          
          <div class="quarto-title-meta-contents">
              <p class="affiliation">
                  <a href="https://lmm.univ-lemans.fr/fr/">
                  Le Mans Université, CNRS, Institut du Risque et de l’Assurance
                  </a>
                </p>
            </div>
        </div>
                    
  <div class="quarto-title-meta">
                                
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">March 18, 2024</p>
      </div>
    </div>
                                    
      <div>
      <div class="quarto-title-meta-heading">Modified</div>
      <div class="quarto-title-meta-contents">
        <p class="date-modified">March 18, 2024</p>
      </div>
    </div>
      
                  
      <div>
      <div class="quarto-title-meta-heading">Keywords</div>
      <div class="quarto-title-meta-contents">
        <p class="date">Individual-based models, stochastic simulation, population dynamics, Poisson measures, thinning method, actuarial science, insurance portfolio simulation</p>
      </div>
    </div>
    
    <div>
      <div class="quarto-title-meta-heading">Status</div>
      <div class="quarto-title-meta-contents">
              <p class="date">draft</p>
                  </div>
    </div>

  </div>
                                                
  <div>
    <div class="abstract">
    <div class="abstract-title">Abstract</div>
      <p>The <code>R</code> Package <code>IBMPopSim</code> aims to simulate the random evolution of heterogeneous populations using stochastic Individual-Based Models (IBMs). The package enables users to simulate population evolution, in which individuals are characterized by their age and some characteristics, and the population is modified by different types of events, including births/arrivals, death/exit events, or changes of characteristics. The frequency at which an event can occur to an individual can depend on their age and characteristics, but also on the characteristics of other individuals (interactions). Such models have a wide range of applications in fields including actuarial science, biology, ecology or epidemiology. <code>IBMPopSim</code> overcomes the limitations of time-consuming IBMs simulations by implementing new efficient algorithms based on thinning methods, which are compiled using the <code>Rcpp</code> package while providing a user-friendly interface.</p>
    </div>
  </div>

  </header><div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Contents</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction"><span class="header-section-number">1</span> Introduction</a></li>
  <li><a href="#sec-ibm" id="toc-sec-ibm" class="nav-link" data-scroll-target="#sec-ibm"><span class="header-section-number">2</span> Stochastic Individual-Based Models (IBMs) in IBMPopSim</a>
  <ul class="collapse">
  <li><a href="#brief-package-overview" id="toc-brief-package-overview" class="nav-link" data-scroll-target="#brief-package-overview"><span class="header-section-number">2.1</span> Brief package overview</a>
  <ul class="collapse">
  <li><a href="#model-creation" id="toc-model-creation" class="nav-link" data-scroll-target="#model-creation"><span class="header-section-number">2.1.1</span> Model creation</a></li>
  <li><a href="#simulation" id="toc-simulation" class="nav-link" data-scroll-target="#simulation"><span class="header-section-number">2.1.2</span> Simulation</a></li>
  </ul></li>
  <li><a href="#sec-population" id="toc-sec-population" class="nav-link" data-scroll-target="#sec-population"><span class="header-section-number">2.2</span> Population</a>
  <ul class="collapse">
  <li><a href="#notations" id="toc-notations" class="nav-link" data-scroll-target="#notations"><span class="header-section-number">2.2.1</span> Notations</a></li>
  <li><a href="#individuals" id="toc-individuals" class="nav-link" data-scroll-target="#individuals"><span class="header-section-number">2.2.2</span> Individuals</a></li>
  <li><a href="#population-process" id="toc-population-process" class="nav-link" data-scroll-target="#population-process"><span class="header-section-number">2.2.3</span> Population process</a></li>
  </ul></li>
  <li><a href="#sec-events" id="toc-sec-events" class="nav-link" data-scroll-target="#sec-events"><span class="header-section-number">2.3</span> Events</a></li>
  <li><a href="#sec-event-intensity" id="toc-sec-event-intensity" class="nav-link" data-scroll-target="#sec-event-intensity"><span class="header-section-number">2.4</span> Events intensity</a>
  <ul class="collapse">
  <li><a href="#events-intensity-bounds" id="toc-events-intensity-bounds" class="nav-link" data-scroll-target="#events-intensity-bounds"><span class="header-section-number">2.4.1</span> Events intensity bounds</a></li>
  </ul></li>
  <li><a href="#pathwise-representation" id="toc-pathwise-representation" class="nav-link" data-scroll-target="#pathwise-representation"><span class="header-section-number">2.5</span> Pathwise representation</a>
  <ul class="collapse">
  <li><a href="#non-explosion-criterion" id="toc-non-explosion-criterion" class="nav-link" data-scroll-target="#non-explosion-criterion"><span class="header-section-number">2.5.1</span> Non explosion criterion</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#sec-simulation" id="toc-sec-simulation" class="nav-link" data-scroll-target="#sec-simulation"><span class="header-section-number">3</span> Population simulation</a>
  <ul class="collapse">
  <li><a href="#sec-thinning" id="toc-sec-thinning" class="nav-link" data-scroll-target="#sec-thinning"><span class="header-section-number">3.1</span> Thinning of Poisson measure</a>
  <ul class="collapse">
  <li><a href="#sec-vector" id="toc-sec-vector" class="nav-link" data-scroll-target="#sec-vector"><span class="header-section-number">3.1.1</span> Multivariate Poisson process</a></li>
  </ul></li>
  <li><a href="#sec-simulation-algo" id="toc-sec-simulation-algo" class="nav-link" data-scroll-target="#sec-simulation-algo"><span class="header-section-number">3.2</span> Simulation algorithm</a>
  <ul class="collapse">
  <li><a href="#first-event-simulation" id="toc-first-event-simulation" class="nav-link" data-scroll-target="#first-event-simulation"><span class="header-section-number">3.2.1</span> First event simulation</a></li>
  </ul></li>
  <li><a href="#sec-simulation-randomized" id="toc-sec-simulation-randomized" class="nav-link" data-scroll-target="#sec-simulation-randomized"><span class="header-section-number">3.3</span> Simulation algorithm with randomization</a></li>
  </ul></li>
  <li><a href="#sec-package" id="toc-sec-package" class="nav-link" data-scroll-target="#sec-package"><span class="header-section-number">4</span> Model creation and simulation with IBMPopSim</a>
  <ul class="collapse">
  <li><a href="#sec-population" id="toc-sec-population" class="nav-link" data-scroll-target="#sec-population"><span class="header-section-number">4.1</span> Population</a>
  <ul class="collapse">
  <li><a href="#individual" id="toc-individual" class="nav-link" data-scroll-target="#individual"><span class="header-section-number">4.1.1</span> Individual</a></li>
  </ul></li>
  <li><a href="#sec-package-events" id="toc-sec-package-events" class="nav-link" data-scroll-target="#sec-package-events"><span class="header-section-number">4.2</span> Events</a></li>
  </ul></li>
  <li><a href="#sec-insurance-portfolio" id="toc-sec-insurance-portfolio" class="nav-link" data-scroll-target="#sec-insurance-portfolio"><span class="header-section-number">5</span> Insurance portfolio</a></li>
  <li><a href="#sec-example-interaction" id="toc-sec-example-interaction" class="nav-link" data-scroll-target="#sec-example-interaction"><span class="header-section-number">6</span> Population with genetically variable traits</a></li>
  
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="article.pdf"><i class="bi bi-file-pdf"></i>PDF (computo)</a></li></ul></div></nav>
</div>
<main class="content quarto-banner-title-block" id="quarto-document-content">




<section id="introduction" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Introduction</h1>
<p>In various fields, advances in probability have contributed to the development of a new mathematical framework for so-called individual-based stochastic population dynamics, also called stochastic Individual-Based Models (IBMs).</p>
<p>Stochastic IBMs allow the modeling in continuous time of populations dynamics structured by age and/or characteristics. In the field of mathematical biology and ecology, a large community has used this formalism for the study of the evolution of structured populations (see e.g. <span class="citation" data-cites="FerTra09 collet2013rigorous BanMel15 costa2016stochastic billiard2016effect lavallee2019stochastic meleard2019birth calvez2020horizontal">(<a href="#ref-FerTra09" role="doc-biblioref">Ferrière and Tran 2009</a>; <a href="#ref-collet2013rigorous" role="doc-biblioref">Collet, Méléard, and Metz 2013</a>; <a href="#ref-BanMel15" role="doc-biblioref">Bansaye and Méléard 2015</a>; <a href="#ref-costa2016stochastic" role="doc-biblioref">Costa et al. 2016</a>; <a href="#ref-billiard2016effect" role="doc-biblioref">Billiard et al. 2016</a>; <a href="#ref-lavallee2019stochastic" role="doc-biblioref">Lavallée et al. 2019</a>; <a href="#ref-meleard2019birth" role="doc-biblioref">Méléard, Rera, and Roget 2019</a>; <a href="#ref-calvez2020horizontal" role="doc-biblioref">Calvez et al. 2020</a>)</span>), after the pioneer works&nbsp;<span class="citation" data-cites="FouMel04 champagnat2006unifying tran_2008">(<a href="#ref-FouMel04" role="doc-biblioref">Fournier and Méléard 2004</a>; <a href="#ref-champagnat2006unifying" role="doc-biblioref">Champagnat, Ferrière, and Méléard 2006</a>; <a href="#ref-tran_2008" role="doc-biblioref">Tran 2008</a>)</span>.</p>
<p>IBMs are also useful in demography and actuarial sciences, for the modeling of human populations dynamics (see e.g. <span class="citation" data-cites="Ben10 Bou16 karoui2021simulating">(<a href="#ref-Ben10" role="doc-biblioref">Bensusan 2010</a>; <a href="#ref-Bou16" role="doc-biblioref">Boumezoued 2016</a>; <a href="#ref-karoui2021simulating" role="doc-biblioref">El Karoui, Hadji, and Kaakai 2021</a>)</span>). They allow the modeling of heterogeneous and complex population dynamics, which can be used to compute demographic indicators or simulate the evolution of insurance portfolios in order to study the basis risk, compute cash flows for annuity products or pension schemes, or for a fine assessment of mortality models <span class="citation" data-cites="barrieu2012understanding">(<a href="#ref-barrieu2012understanding" role="doc-biblioref">Barrieu et al. 2012</a>)</span>. There are other domains in which stochastic IBMs can be used, for example in epidemiology with stochastic compartmental models, neurosciences, cyber risk, or Agent-Based Models (ABMs) in economy and social sciences, which can be seen as IBMs. Many mathematical results have been obtained in the literature cited above, for quantifying the limit behaviors of IBMs in long time or in large population. In particular, pathwise representations of IBMs have been introduced in <span class="citation" data-cites="FouMel04">(<a href="#ref-FouMel04" role="doc-biblioref">Fournier and Méléard 2004</a>)</span> (and extended to age-structured populations in <span class="citation" data-cites="tran_2008">(<a href="#ref-tran_2008" role="doc-biblioref">Tran 2008</a>)</span>), as measure-valued pure jumps Markov processes, solutions of SDEs driven by Poisson measures. These pathwise representations are based on the <em>thinning</em> and projection of Poisson random measures defined on extended spaces. However, the simulation of large and interacting populations is often referred as computationally expensive.</p>
<p>The aim of the <code>R</code> package <code>IBMPopSim</code> is to meet the needs of the various communities for efficient tools in order to simulate the evolution of stochastic IBMs. <code>IBMPopSim</code> provides a general framework for the simulation of a wide class of IBMs, where individuals are characterized by their age and/or a set of characteristics. Different types of events can be included in the modeling by users, depending on their needs: births, deaths, entry or exit in/to the population and changes of characteristics (swap events). Furthermore, the various events that can happen to individuals in the population can occur at a non-stationary frequency, depending on the individuals’ characteristics and time, and also including potential interactions between individuals.</p>
<p>We introduce a unified mathematical and simulation framework for this class of IBMs, generalizing the pathwise representation of IBMs by thinning of Poisson measures, as well as the associated population simulation algorithm, based on an acceptance/rejection procedure. In particular, we provide general sufficient conditions on the event intensities under which the simulation of a particular model is possible.</p>
<p>We opted to implement the algorithms of the <code>IBMPopSim</code> package using the <code>Rcpp</code> package, a tool facilitating the seamless integration of high-performance <code>C++</code> code into easily callable <code>R</code> functions <span class="citation" data-cites="JSSv040i08">(<a href="#ref-JSSv040i08" role="doc-biblioref">Eddelbuettel and Francois 2011</a>)</span>. With just a few lines of <code>C++</code> code, <code>IBMPopSim</code> offers user-friendly R functions for defining IBMs. Once events and their associated intensities are specified, an automated procedure creates the model. This involves integrating the user’s source code into the primary <code>C++</code> code using a template mechanism. Subsequently, <code>Rcpp</code> is invoked to compile the model and integrate it into the <code>R</code> session. Following this process, the model becomes callable with varying parameters, enabling the generation of diverse population evolution scenarios. Combined with the design of the simulation algorithms, the package structure yields very competitive simulation runtimes for IBMs, while staying user-friendly for <code>R</code> users. Several outputs function are also implemented in <code>IBMPopSim</code>. For instance the package allows the construction and visualization of age pyramids, as well as the construction of death and exposures table from the censored individual data, compatible with <code>R</code> packages concerned with mortality modelling, such as <span class="citation" data-cites="Rdemography">(<a href="#ref-Rdemography" role="doc-biblioref">Hyndman et al. 2023</a>)</span> or <span class="citation" data-cites="Rstmomo">(<a href="#ref-Rstmomo" role="doc-biblioref">Villegas, Millossovich, and Kaishev Hyndman 2018</a>)</span>. Several examples are provided in the form of <code>R</code> vignettes on the <a href="https://daphnegiorgi.github.io/IBMPopSim/">website</a>, and in recent works of <span class="citation" data-cites="karoui2021simulating">(<a href="#ref-karoui2021simulating" role="doc-biblioref">El Karoui, Hadji, and Kaakai 2021</a>)</span> and <span class="citation" data-cites="roget2022positive">(<a href="#ref-roget2022positive" role="doc-biblioref">Roget et al. 2022</a>)</span>.</p>
<p>Designed for applications in social sciences, the <code>R</code> package <code>MicSim</code>&nbsp;<span class="citation" data-cites="Zin14">(<a href="#ref-Zin14" role="doc-biblioref">Zinn 2014</a>)</span> can be used for continuous time microsimulation. In continuous-time microsimulation, individual life-courses are usually specified by sequences of state transitions (events) and the time spans between these transitions. The state space is usually discrete and finite, which is no necessarily the case in <code>IBMPopSim</code>, where individuals can have continuous characteristics. But most importantly, microsimulation does not allow for interactions between individuals. Indeed, microsimulation produces separately the life courses of all individuals in the populations, based on the computation of the distribution functions of the waiting times in the distinct states of the state space, for each individual <span class="citation" data-cites="Zin14">(<a href="#ref-Zin14" role="doc-biblioref">Zinn 2014</a>)</span>. This can be slow in comparison to the simulation by thinning of event times occurring in the population, which is based on selecting event times among some competing proposed event times. Finally, <code>MicSim</code> simplifies the Mic-Core microsimulation tool implemented in Java <span class="citation" data-cites="zinn2009mic">(<a href="#ref-zinn2009mic" role="doc-biblioref">Zinn et al. 2009</a>)</span>. However, the implementation in <code>R</code> of simulation algorithms yields longer simulation run times than when using <code>Rcpp</code>. To the best of our knowledge, there are no other <code>R</code> packages currently available addressing the issue of IBMs efficient simulation.</p>
<p>In <a href="#sec-ibm" class="quarto-xref">Section&nbsp;2</a>, we introduce the mathematical framework that characterizes the class of Stochastic Individual-Based Models (IBMs) that can be implemented in the <code>IBMPopSim</code> package. In particular, a general pathwise representation of IBMs is presented. The population dynamics is obtained as the solution of an SDE driven by Poisson measures, for which we obtain existence and uniqueness results in <a href="#thm-eq-Z" class="quarto-xref">Theorem&nbsp;1</a>. Additionally, a succinct overview of the package is provided. In <a href="#sec-simulation" class="quarto-xref">Section&nbsp;3</a> the two main algorithms for simulating the population evolution of an IBM across the interval <span class="math inline">[0, T]</span> are detailed. In <a href="#sec-package" class="quarto-xref">Section&nbsp;4</a> we present the main functions of the <code>IBMPopSim</code> package, which allow for the definition of events and their intensities, the creation of a model, and the simulation of scenarios. Two examples are detailed in <a href="#sec-insurance-portfolio" class="quarto-xref">Section&nbsp;5</a> and sec-example-interaction, featuring applications involving an heterogeneous insurance portfolio characterized by entry and exit events, and an age and size-structured population with intricate interactions.</p>
</section>
<section id="sec-ibm" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Stochastic Individual-Based Models (IBMs) in IBMPopSim</h1>
<p>Stochastic Individual-Based Models (IBMs) represent a broad class of random population dynamics models, allowing the description of populations evolution on a microscopic scale. Informally, an IBM can be summarized by the description of the individuals constituting the population, the various types of events that can occur to these individuals, along with their respective frequencies. In <code>IBMPopSim</code>, individuals can be characterized by their age and/or a collection of discrete or continuous characteristics. Moreover, the package enables users to simulate efficiently populations in which one or more of the following event types may occur:</p>
<ul>
<li><strong>Birth event</strong>: addition of an individual of age 0 to the population.</li>
<li><strong>Death event</strong>: removal of an individual from the population.</li>
<li><strong>Entry event</strong>: arrival of an individual in the population.</li>
<li><strong>Exit (emigration) event</strong>: exit from the population (other than death).</li>
<li><strong>Swap event</strong>: an individual changes characteristics.</li>
</ul>
<p>Each event type is linked to an associated event kernel, describing how the population is modified following the occurrence of the event. For some event types, the event kernel requires explicit specification. This is the case for entry events when a new individual joins the population. Then,the model should specify how the age and characteristics of this new individual are chosen. For instance, the characteristics of a new individual in the population can be chosen uniformly in the space of all characteristics, or can depend on the distribution of his parents or those of the other individuals composing the population.</p>
<p>The last component of an IBM are the event intensities. Informally, an event intensity is a function <span class="math inline">\lambda^e_t(I, Z)</span> describing the frequency at which an event <span class="math inline">e</span> can occur to an individual <span class="math inline">I</span> in a population <span class="math inline">Z</span> at a time <span class="math inline">t</span>. Given a history of the population <span class="math inline">(\mathcal{F}_t)</span>, the probability of event <span class="math inline">e</span> occurring to individual <span class="math inline">I</span> during a small interval of time <span class="math inline">(t,t+dt]</span> is proportional to <span class="math inline">\lambda^e(I,t)</span>: <span class="math display">
    \mathbb{P}(\text{event } e \text{ occurring to $I$ during } (t,t+dt] | \mathcal{F}_t) \simeq \lambda^e_t(I, Z)dt.
</span> The intensity function <span class="math inline">\lambda^e</span> can include dependency on the individual’s <span class="math inline">I</span> age and characteristics, the time <span class="math inline">t</span>, or the population composition <span class="math inline">Z</span> in the presence of interactions.</p>
<section id="brief-package-overview" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="brief-package-overview"><span class="header-section-number">2.1</span> Brief package overview</h2>
<p>Prior to providing a detailed description of an Individual-Based Model (IBM), we present a simple model of birth and death in an age-structured <em>human</em> population. We assume no interactions between individuals, and individuals are characterized by their gender, in addition to their age. In this simple model, all individuals, regardless of gender, can give birth when their age falls between 15 and 40 years, with a constant birth rate of 0.05. The death intensity is assumed to follow a Gompertz-type intensity depending on age. The birth and death intensities are then given by<br>
<span class="math display">\begin{equation*}
    \lambda^b(t, I) = 0.05 \times \mathbf{1}_{[15,40]}(a(I,t)), \quad
    \lambda^d(t, I) = \alpha\exp(\beta a(I,t)),
\end{equation*}</span> with <span class="math inline">a(I,t)</span> the age of individual <span class="math inline">I</span> at time <span class="math inline">t</span>. Birth events are also characterized with a kernel determining the gender of the newborn, who is male with probability <span class="math inline">p_{male}</span>.</p>
<section id="model-creation" class="level3" data-number="2.1.1">
<h3 data-number="2.1.1" class="anchored" data-anchor-id="model-creation"><span class="header-section-number">2.1.1</span> Model creation</h3>
<p>To implement this model in IBMPopSim, it is necessary to individually define each event type. In this example, the <code>mk_event_individual</code> function is used. The creation of an event involves a few lines of <code>cpp</code> instructions defining the intensity and, if applicable, the kernel of the event. For a more in depth description of the event creation step and its parameters, we refer to <a href="#sec-package-events" class="quarto-xref">Section&nbsp;4.2</a>.</p>
<p>The events of this simple model are for example defined through the following calls.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>birth_event <span class="ot">&lt;-</span> <span class="fu">mk_event_individual</span>(</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">type =</span> <span class="st">"birth"</span>, </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">intensity_code =</span> <span class="st">"result = birth_rate(I.age(t));"</span>,</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">kernel_code =</span> <span class="st">"newI.male = CUnif(0,1) &lt; p_male;"</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>death_event <span class="ot">&lt;-</span> <span class="fu">mk_event_individual</span>(</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span class="at">type =</span> <span class="st">"death"</span>,</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span class="at">intensity_code =</span> <span class="st">"result = alpha * exp(beta * I.age(t));"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>In the <code>cpp</code> codes, the names <code>birth_rate</code>, <code>p_male</code>, <code>alpha</code> and <code>beta</code> refer to the model parameters defined in the following list.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>params <span class="ot">&lt;-</span> <span class="fu">list</span>(</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="st">"alpha"</span> <span class="ot">=</span> <span class="fl">0.008</span>, <span class="st">"beta"</span> <span class="ot">=</span> <span class="fl">0.02</span>, </span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="st">"p_male"</span> <span class="ot">=</span> <span class="fl">0.51</span>,</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="st">"birth_rate"</span> <span class="ot">=</span> <span class="fu">stepfun</span>(<span class="fu">c</span>(<span class="dv">15</span>, <span class="dv">40</span>), <span class="fu">c</span>(<span class="dv">0</span>, <span class="fl">0.05</span>, <span class="dv">0</span>)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>In a second step, the model is created by calling the function <code>mk_model</code>. A <code>cpp</code> source code is automatically created through a template mechanism based on the events and parameters, subsequently compiled using the <code>sourceCpp</code> function from the <code>Rcpp</code> package.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>birth_death_model <span class="ot">&lt;-</span> <span class="fu">mk_model</span>(</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">characteristics =</span> <span class="fu">c</span>(<span class="st">"male"</span> <span class="ot">=</span> <span class="st">"bool"</span>),</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">events =</span> <span class="fu">list</span>(death_event, birth_event),</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">parameters =</span> params)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="simulation" class="level3" data-number="2.1.2">
<h3 data-number="2.1.2" class="anchored" data-anchor-id="simulation"><span class="header-section-number">2.1.2</span> Simulation</h3>
<p>Once the model is created and compiled, the <code>popsim</code> function is called to simulate the evolution of a population according to this model. To achieve this, an initial population must be defined. In this example, we extract a population from a dataset specified in the package (a sample of <span class="math inline">100\,000</span> individuals based on the population of England and Wales in 2014). It is also necessary to set bounds for the events intensities. In this example, they are obtained by assuming that the maximum age for an individual is 115 years.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>a_max <span class="ot">&lt;-</span> <span class="dv">115</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>events_bounds <span class="ot">=</span> <span class="fu">c</span>(</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="st">"death"</span> <span class="ot">=</span> params<span class="sc">$</span>alpha <span class="sc">*</span> <span class="fu">exp</span>(params<span class="sc">$</span>beta <span class="sc">*</span> a_max),</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span class="st">"birth"</span> <span class="ot">=</span> <span class="fu">max</span>(params<span class="sc">$</span>birth_rate))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The function <code>popsim</code> can now be called to simulate the population starting from the initial population <code>population(EW_pop_14$sample)</code> up to time <span class="math inline">T = 30</span>.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>sim_out <span class="ot">&lt;-</span> <span class="fu">popsim</span>(</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  birth_death_model, </span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">population</span>(EW_pop_14<span class="sc">$</span>sample), </span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  events_bounds, </span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">parameters =</span> params, <span class="at">age_max =</span> a_max, </span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">time =</span> <span class="dv">30</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The data frame <code>sim_out$population</code> contains the information (birth, death, gender) on individuals who lived in the population over the period <span class="math inline">[0,30]</span>. Functions of the package allows to provide aggregated information on the population.</p>
<p>In the remainder of this section, we define rigorously the class of IBMs that can be simulated in <code>IBMPopSim</code>, along with the assumptions that are required in order for the population to be simulatable. The representation of age-structured IBMs based on measure-valued processes, as introduced in <span class="citation" data-cites="tran_2008">(<a href="#ref-tran_2008" role="doc-biblioref">Tran 2008</a>)</span>, is generalized to a wider class of abstract population dynamics. The modeling differs slightly here, since individuals are <em>kept in the population</em> after their death (or exit), by including the death/exit date as an individual trait.</p>
</section>
</section>
<section id="sec-population" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="sec-population"><span class="header-section-number">2.2</span> Population</h2>
<section id="notations" class="level3" data-number="2.2.1">
<h3 data-number="2.2.1" class="anchored" data-anchor-id="notations"><span class="header-section-number">2.2.1</span> Notations</h3>
<p>In the remainder of the paper, the filtered probability space is denoted by <span class="math inline">(\Omega,\{\mathcal{F}_t \},{\mathbb{P}})</span>, under the usual assumptions. All processes are assumed to be càdlàg and adapted to the filtration <span class="math inline">\{\mathcal{F}_t \}</span> (for instance the history of the population) on a time interval <span class="math inline">[0,T]</span>. For a càdlàg process <span class="math inline">X</span>, we denote <span class="math inline">X_{t^-} := \lim_{\genfrac{}{}{0pt}{2}{s\to t}{s&lt;t}} X_s</span>.</p>
</section>
<section id="individuals" class="level3" data-number="2.2.2">
<h3 data-number="2.2.2" class="anchored" data-anchor-id="individuals"><span class="header-section-number">2.2.2</span> Individuals</h3>
<p>An individual is represented by a triplet <span class="math inline">I = (\tau^b, \tau^d, x) \in \mathcal{I}= {\mathbb{R}}\times \bar {\mathbb{R}}\times {\mathcal{X}}</span> with:</p>
<ul>
<li><span class="math inline">\tau^b \in {\mathbb{R}}</span> the date of birth,</li>
<li><span class="math inline">\tau^d \in \bar {\mathbb{R}}</span> the death date, with <span class="math inline">\tau^d = \infty</span> if the individual is still alive,</li>
<li>a collection <span class="math inline">x \in {\mathcal{X}}</span> of characteristics where <span class="math inline">{\mathcal{X}}</span> is the space of characteristics.</li>
</ul>
<p>Note that in IBMs, individuals are usually characterized by their age <span class="math inline">a(t) =t-\tau^b</span> instead of their date of birth <span class="math inline">\tau^b</span>. However, using the latter is actually easier for the simulation, as it remains constant over time.</p>
</section>
<section id="population-process" class="level3" data-number="2.2.3">
<h3 data-number="2.2.3" class="anchored" data-anchor-id="population-process"><span class="header-section-number">2.2.3</span> Population process</h3>
<p>The population at a given time <span class="math inline">t</span> is a random set <span class="math display">
    Z_t=\{ I_k \in \mathcal{I}; \; k= 1,\dots, N_t\},
</span> composed of all individuals (alive or dead) who have lived in the population before time <span class="math inline">t</span>. As a random set, <span class="math inline">Z_t</span> can be represented by a random counting measure on <span class="math inline">\mathcal{I}</span> , that is an integer-valued measure <span class="math inline">Z: \Omega \times \mathcal{I}\to \bar {\mathbb{N}}</span> where for <span class="math inline">A \in \mathcal{I}</span>, <span class="math inline">Z(A)</span> is the (random) number of individuals <span class="math inline">I</span> in the subset <span class="math inline">A</span>. With this representation: <span id="eq-popZ"><span class="math display">
\begin{aligned}
    Z_t (\mathrm{d}\tau^b, \mathrm{d}\tau^d , \mathrm{d}x) &amp;= \sum_{k=1}^{N_t} \delta_{I_k} (\tau^b, \tau^d,x), \nonumber \\
    \text{ with }  \int_{\mathcal{I}} f(\tau^b, \tau^d, x) Z_t (\mathrm{d}\tau^b, \mathrm{d}\tau^d , \mathrm{d}x) &amp;= \sum_{k=1}^{N_t} f(I_k).
\end{aligned}
\tag{1}</span></span></p>
<p>The number of individuals present in the population <em>before time</em> <span class="math inline">t</span> is obtained by taking <span class="math inline">f\equiv 1</span>: <span class="math display">
    N_t =  \int_{\mathcal{I}}  Z_t(\mathrm{d}\tau^b, \mathrm{d}\tau^d, \mathrm{d}x) = \sum_{k=1}^{N_t} \boldsymbol{1}_{\mathcal{I}} (I_k).
</span> Note that <span class="math inline">(N_t)_{t\geq 0}</span> is an increasing process since dead/exited individuals are kept in the population <span class="math inline">Z</span>. The number of alive individuals in the population at time <span class="math inline">t</span> is: <span id="eq-Nta"><span class="math display">
    N_t^a =  \int_{\mathcal{I}}  \mathsf{1}_{\{\tau^d &gt; t \} }Z_t(\mathrm{d}\tau^b, \mathrm{d}\tau^d, \mathrm{d}x) = \sum_{k=1}^{N_t} \mathsf{1}_{\{\tau^d_k &gt; t \} }.
\tag{2}</span></span> Another example is the number of alive individuals of age over <span class="math inline">a</span> is <span class="math display">
    N_t([a,+\infty)) :=  \int_{\mathcal{I}}  \boldsymbol{1}_{[a,+\infty)}(t-\tau^b)\mathsf{1}_{]t,\infty]}(\tau^d) Z_t(\mathrm{d}\tau^b, \mathrm{d}\tau^d, \mathrm{d}x) = \sum_{k=1}^{N_t}  \boldsymbol{1}_{\{ t -\tau_k^b \geq a \}}\mathsf{1}_{\{\tau^d_k \geq t \} }.
</span></p>
</section>
</section>
<section id="sec-events" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="sec-events"><span class="header-section-number">2.3</span> Events</h2>
<p>The population composition changes at random dates following different types of events. <code>IBMPopSim</code> allows the simulation of IBMs with the following events types:</p>
<ul>
<li><p>A <strong>birth</strong> event at time <span class="math inline">t</span> is the addition of a new individual <span class="math inline">I'=(t,\infty, X)</span> of age <span class="math inline">0</span> to the population. Their date of birth is <span class="math inline">\tau^b =t</span>, and characteristics is <span class="math inline">X</span>, a random variable of distribution defined by the birth kernel <span class="math inline">k^b(t,I,\mathrm{d}x)</span> on <span class="math inline">{\mathcal{X}}</span>, depending on <span class="math inline">t</span> and its parent <span class="math inline">I</span>. The population size becomes <span class="math inline">N_t = N_{t^-} + 1</span>, and the population composition after the event is <span class="math display">Z_t  = Z_{t^-} +  \delta_{(t,\infty, X)}.</span></p></li>
<li><p>An <strong>entry</strong> event at time <span class="math inline">t</span> is also the addition of an individual <span class="math inline">I'</span> in the population. However, this individual is not of age <span class="math inline">0</span>. The date of birth and characteristics of the new individual <span class="math inline">I'= (\tau^b, \infty, X)</span> are random variables of probability distribution defined by the entry kernel <span class="math inline">k^{en}(t, \mathrm{d}s, \mathrm{d}x)</span> on <span class="math inline">{\mathbb{R}}\times {\mathcal{X}}</span>. The population size becomes <span class="math inline">N_t = N_{t^-} + 1</span>, and the population composition after the event is: <span class="math display">
  Z_t  = Z_{t^-} +  \delta_{(\tau^b, \infty, X)}.
</span></p></li>
<li><p>A <strong>death</strong> or <strong>exit</strong> event of an individual <span class="math inline">I= (\tau^b,\infty, x)\in Z_{t^-}</span> at time <span class="math inline">t</span> is the modification of its death date <span class="math inline">\tau^d</span> from <span class="math inline">+\infty</span> to <span class="math inline">t</span>. This event results in the simultaneous addition of the individual <span class="math inline">(\tau^b,t,x)</span> and removal of the individual <span class="math inline">I</span> from the population. The population size is not modified, and the population composition after the event is <span class="math display">
  Z_t  = Z_{t^-} +\delta_{(\tau^b,t,x)}- \delta_{I}.
</span></p></li>
<li><p>A <strong>swap</strong> event (change of characteristics) results in the simultaneous addition and removal of an individual. If an individual <span class="math inline">I= (\tau^b,\infty, x) \in Z_{t^-}</span> changes of characteristics at time <span class="math inline">t</span>, then it is removed from the population and replaced by <span class="math inline">I' = (\tau^b,\infty, X)</span>. The new characteristics <span class="math inline">X</span> is a random variable of distribution <span class="math inline">k^s(t, I,\mathrm{d}x)</span> on <span class="math inline">{\mathcal{X}}</span>, depending on time, the individual’s age and previous characteristics <span class="math inline">x</span>. In this case, the population size is not modified and the population becomes: <span class="math display">
  Z_t  = Z_{t^-}   +  \delta_{(\tau^b,  \infty, X)} -  \delta_{(\tau^b, \infty, x)}.
</span></p></li>
</ul>
<p>To summarize, the space of event types is <span class="math inline">E = \{ b, en, d, s \}</span>, and the jump <span class="math inline">\Delta Z_t = Z_t - Z_{t^-}</span> (change in the population composition) generated by an event of type <span class="math inline">e \in \{ b, en, d, s \}</span> is denoted by <span class="math inline">\phi^e(t, I)</span>. We thus have the following rules summarized in the table <a href="#tbl-event-action" class="quarto-xref">Table&nbsp;1</a>.</p>
<div id="tbl-event-action" class="quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-event-action-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;1: Action in the population for a given event name
</figcaption>
<div aria-describedby="tbl-event-action-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table">
<colgroup>
<col style="width: 13%">
<col style="width: 13%">
<col style="width: 37%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th>Event</th>
<th style="text-align: center;">Type</th>
<th><span class="math inline">\phi^e(t, I)</span></th>
<th>New individual</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Birth</td>
<td style="text-align: center;"><span class="math inline">b</span></td>
<td><span class="math inline">\delta_{(t, \infty,  X)}</span></td>
<td><span class="math inline">\tau^b =t, \; X \sim k^b(t,I,\mathrm{d}x)</span></td>
</tr>
<tr class="even">
<td>Entry</td>
<td style="text-align: center;"><span class="math inline">en</span></td>
<td><span class="math inline">\delta_{(\tau^b, \infty,  X)}</span></td>
<td><span class="math inline">(\tau^b, X) \sim k^{en}(t,\mathrm{d}s, \mathrm{d}x)</span></td>
</tr>
<tr class="odd">
<td>Death/Exit</td>
<td style="text-align: center;"><span class="math inline">d</span></td>
<td><span class="math inline">\delta_{(\tau^b, t,x)} - \delta_{(\tau^b, \infty, x)}</span></td>
<td><span class="math inline">\tau^d = t</span></td>
</tr>
<tr class="even">
<td>Swap</td>
<td style="text-align: center;"><span class="math inline">s</span></td>
<td><span class="math inline">\delta_{(\tau^b, \infty , X)} - \delta_{(\tau^b, \infty, x)}</span></td>
<td><span class="math inline">X \sim k^s(t,I,\mathrm{d}x)</span></td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<div id="rem-popfinale" class="proof remark">
<p><span class="proof-title"><em>Remark 1</em> (Composition of the population). </span></p>
<ul>
<li>At time <span class="math inline">T</span>, the population <span class="math inline">Z_T</span> contains all individuals who lived in the population before <span class="math inline">T</span>, including dead/exited individuals. If there are no swap events, or entries,the population state <span class="math inline">Z_t</span> for any time <span class="math inline">t\leq T</span> can be obtained from <span class="math inline">Z_T</span>. Indeed, if <span class="math inline">Z_T = \sum_{k=1}^{N_T}  \delta_{I_k}</span>, then the population at time <span class="math inline">t\leq T</span> is simply composed of the individuals born before <span class="math inline">t</span>: <span class="math display">
  Z_t = \sum_{k=1}^{N_T} \boldsymbol{1}_{\{\tau^b_k \leq t \}} \delta_{I_k}.
</span></li>
<li>In the presence of entries (open population), a characteristic <span class="math inline">x</span> can track the individuals’ entry dates. Then, the previous equation can be easily modified in order to obtain the population <span class="math inline">Z_t</span> at time <span class="math inline">t\leq T</span> from <span class="math inline">Z_T</span>.</li>
</ul>
</div>
</section>
<section id="sec-event-intensity" class="level2" data-number="2.4">
<h2 data-number="2.4" class="anchored" data-anchor-id="sec-event-intensity"><span class="header-section-number">2.4</span> Events intensity</h2>
<p>Once the different event types have been defined in the population model, the frequency at which each event occur in the population <span class="math inline">e</span> have to be specified. Informally, the intensity <span class="math inline">\Lambda^e_t(Z_t)</span> at which an event <span class="math inline">e</span> can occur is defined by <span class="math display">
    \mathbb P\big( \text{event } e \text { occurs in the population }  Z_t  \in (t,t+\mathrm{d}t] | \mathcal{F}_t \big) \simeq  \Lambda^e_t (Z_t)\mathrm{d}t.
</span> For a more formal definition of stochastic intensities, we refer to <span class="citation" data-cites="bremaud1981point">(<a href="#ref-bremaud1981point" role="doc-biblioref">Brémaud 1981</a>)</span> or <span class="citation" data-cites="KaaElK20">(<a href="#ref-KaaElK20" role="doc-biblioref">Kaakai and El Karoui 2023</a>)</span>. The form of the intensity function <span class="math inline">(\Lambda^e_t (Z_t))</span> determines the population simulation algorithm in <code>IBMPopSim</code>:</p>
<ul>
<li>When the event intensity does not depend on the population state, <span id="eq-poisson-intensity"><span class="math display">
  \big(\Lambda^e_t (Z_t)\big)_{t\in [0,T]} = \big(\mu^e(t)\big)_{t \in [0,T]},
\tag{3}</span></span> with <span class="math inline">\mu^e</span> a deterministic function, the events of type <span class="math inline">e</span> occur at the jump times of an inhomogeneous Poisson process of intensity function <span class="math inline">(\mu^e(t))_{t \in [0,T]}</span>. When such an event occurs, the individual to whom the event happens to is drawn uniformly among alive individuals in the population. In a given model, the set of events <span class="math inline">e\in E</span> with Poisson intensities will be denoted by <span class="math inline">\mathcal{P}</span>.</li>
<li>Otherwise, we assume that the global intensity <span class="math inline">\Lambda^e_t(Z_t)</span> at which the events of type <span class="math inline">e</span> occur in the population can be written as the sum of individual intensities <span class="math inline">\lambda^e_t(I,Z_t)</span>: <span id="eq-global-intensity"><span class="math display">
\begin{aligned}
  &amp;\Lambda^e_t (Z_t) = \sum_{k=1}^{N_t} \lambda^e_t ( I_k,Z_t),  \\
  &amp; \nonumber \text{with } \mathbb P\big( \text{event } e \text { occurs to an individual } I \in (t,t+\mathrm{d}t] | \mathcal{F}_t \big) \simeq  \lambda^e_t (I,Z_t)\mathrm{d}t.
\end{aligned}
\tag{4}</span></span></li>
</ul>
<p>Obviously, nothing can happen to dead or exited individuals, i.e.&nbsp;individuals <span class="math inline">I= (\tau^b, \tau^d, x)</span> with <span class="math inline">\tau^d \leq t</span>. Thus, individual event intensities are assumed to be null for dead/exited individuals: <span class="math display">
    \lambda^e_t ( I,Z_t) = 0, \text{ if }\tau^d \leq t, \text{ so that } \Lambda^e_t (Z_t) = \sum_{k=1}^{N_t^a} \lambda^e_t ( I_k,Z_t),
</span> with <span class="math inline">N^a_t</span> the number of alive individuals at time <span class="math inline">t</span>.</p>
<p>The event’s individual intensity <span class="math inline">\lambda^e_t (I,Z_t)</span> can depend on time (for instance when there is a mortality reduction over time), on the individual’s age <span class="math inline">t-\tau^b</span> and characteristics, but also on the population composition <span class="math inline">Z_t</span>. The dependence of <span class="math inline">\lambda^e</span> on the population <span class="math inline">Z</span> models interactions between individuals in the populations. Hence, two types of individual intensity functions can be implemented in <code>IBMPopSim</code>:</p>
<ol type="1">
<li><p><em>No interactions:</em> The intensity function <span class="math inline">\lambda^e</span> does not depend on the population composition. The intensity at which the event of type <span class="math inline">e</span> occur to an individual <span class="math inline">I</span> only depends on its date of birth and characteristics: <span id="eq-intensity-no-interaction"><span class="math display">
\lambda^e_t (I,Z_t) = \lambda^e(t, I),
\tag{5}</span></span> where <span class="math inline">\lambda^e: \mathbb{R}_+ \times \mathcal{I}\to {\mathbb{R}}^+</span> is a deterministic function. In a given model, we denote by <span class="math inline">\mathcal{E}</span> the set of event types with individual intensity <a href="#eq-intensity-no-interaction" class="quarto-xref">Equation&nbsp;5</a>.</p></li>
<li><p><em>“Quadratic” interactions:</em> The intensity at which an event of type <span class="math inline">e</span> occurs to an individual <span class="math inline">I</span> depends on <span class="math inline">I</span> and on the population composition, through an interaction function <span class="math inline">W^e</span>. The quantity <span class="math inline">W^e(t, I,J)</span> describes the intensity of interactions between two alive individuals <span class="math inline">I</span> and <span class="math inline">J</span> at time <span class="math inline">t</span>, for instance in the presence of competition or cooperation. In this case, we have <span id="eq-intensity-interaction"><span class="math display">
\lambda^e_t(I,Z_t)=\sum_{j=1}^{N_t} W^e(t, I, I_j) = \int_{\mathcal{I}} W^e(t, I, (\tau^b,\tau^d,x)) Z_t (\mathrm{d}\tau^b,\mathrm{d}\tau^d, \mathrm{d}x),
\tag{6}</span></span> where <span class="math inline">W^e(t, I, (\tau^b,\tau^d,x))  = 0</span> if the individual <span class="math inline">J =(\tau^b,\tau^d,x)</span> is dead, i.e.&nbsp;<span class="math inline">\tau^d \leq t</span>.&nbsp;In a given model, we denote by <span class="math inline">\mathcal{E}_W</span> the set of event types with individual intensity <a href="#eq-intensity-interaction" class="quarto-xref">Equation&nbsp;6</a>.</p></li>
</ol>
<p>To summarize, an individual intensity in IBMPopSim can be written as: <span id="eq-individual-intensity"><span class="math display">
    \lambda^e_t(I,Z_t) = \lambda^e(t, I) \mathbf{1}_{\{e \in \mathcal{E}\}} + \biggl( \sum_{j=1}^{N_t} W^e(t, I, I_j) \biggr) \mathbf{1}_{\{e \in \mathcal{E}_W\}}.
\tag{7}</span></span></p>
<div id="exm-popfinale" class="theorem example">
<p><span class="theorem-title"><strong>Example 1</strong></span> &nbsp;</p>
<ol type="1">
<li><p>An example of death intensity without interaction for an individual <span class="math inline">I=(\tau^b, \tau^d, x)</span> alive at time <span class="math inline">t</span>, <span class="math inline">t &lt; \tau^d</span>, is: <span class="math display">
\lambda^d(t,I) =  \alpha_x \exp(\beta_x a(I,t)), \text{ where }  a(I,t) = t-\tau^b
</span> is the age of the individual <span class="math inline">I</span> at time <span class="math inline">t</span>. In this classical case, the death rate of an individual <span class="math inline">I</span> is an exponential (Gompertz) function of the individual’s age, with coefficients depending on the individual’s characteristics <span class="math inline">x</span>.</p></li>
<li><p>In the presence of competition between individuals, the death intensity of an individual <span class="math inline">I</span> also depend on other individuals <span class="math inline">J</span> in the population. For example, if <span class="math inline">I=(\tau^b,\tau^d, x)</span>, with <span class="math inline">x</span> its size, then we can have: <span id="eq-ex-interation"><span class="math display">
W^d(t,I,J) = (x_J - x)^+ \mathbf{1}_{\{\tau^d_J &gt; t\}}, \quad \forall \; J=(\tau^b_J,\tau^d_J , x_J).
\tag{8}</span></span> This can be interpreted as follows: if the individual <span class="math inline">I</span> meets randomly an individual <span class="math inline">J</span> alive at time <span class="math inline">t</span>, and of bigger size <span class="math inline">x_J &gt; x</span>, then he can die at the intensity <span class="math inline">x_J-x</span>. If <span class="math inline">J</span> is smaller than <span class="math inline">I</span>, then he cannot kill <span class="math inline">I</span>. The bigger is the size <span class="math inline">x</span> of <span class="math inline">I</span>, the lower is his death intensity <span class="math inline">\lambda^d_t(I,Z_t)</span> defined by <span class="math display">
\lambda^d_t(I,Z_t) = \sum_{\genfrac{}{}{0pt}{2}{J\in Z_t,}{x_J &gt; x}} (x_J -x)\mathbf{1}_{\{\tau^d_J &gt; t\}}.
</span></p></li>
<li><p><code>IBMPopSim</code> can simulate IBMs that include intensities expressed as a sum of Poisson intensities and individual intensities of the form <span class="math inline">\Lambda^e(Z_t) =\mu^e_t + \sum_{k=1}^{N_t} \lambda^e(I_k, Z_t)</span>. Other examples are provided in <a href="#sec-insurance-portfolio" class="quarto-xref">Section&nbsp;5</a> and <a href="#sec-example-interaction" class="quarto-xref">Section&nbsp;6</a>. Finally, the global intensity at which an event can occur in the population is defined by: <span id="eq-global-ev-intensity"><span class="math display">
\Lambda_t(Z_t) = \sum_{e\in \mathcal{P}} \mu^e(t) + \sum_{e \in \mathcal E} \Big(\sum_{k=1}^{N_t} \lambda^e(t, I_k)\Big) + \sum_{e \in \mathcal E_W} \Big(\sum_{k=1}^{N_t}\sum_{j=1}^{N_t} W^e(t, I_k, I_j)\Big).
\tag{9}</span></span> An important point is that for events <span class="math inline">e \in \mathcal E</span> without interactions, the global event intensity <span class="math inline">\Lambda^e_t(Z_t) = \sum_{k=1}^{N_t} \lambda^e(t, I_k)</span> is <em>of order</em> <span class="math inline">N_t^a</span> defined in <a href="#eq-Nta" class="quarto-xref">Equation&nbsp;2</a> (number of alive individuals at time <span class="math inline">t</span>). On the other hand, for events <span class="math inline">e \in \mathcal{E}_W</span> with interactions, <span class="math inline">\Lambda^e_t(Z_t) = \sum_{k=1}^{N_t}\sum_{j=1}^{N_t} W^e(t, I_k, I_j)</span> is of order <span class="math inline">(N_t^a)^2</span>. Informally, this means that when the population size increases, events with interaction are more costly to simulate. Furthermore, the numerous computations of the interaction kernel <span class="math inline">W^e</span> can also be quite costly. The randomized Algorithm <a href="#algo::rzndomized" data-reference-type="ref" data-reference="algo::rzndomized">[algo::rzndomized]</a>, detailed in Section <a href="#sec::simulation_algo_randomized" data-reference-type="ref" data-reference="sec::simulation_algo_randomized">2.3</a>, allows us to overcome these limitations.</p></li>
</ol>
</div>
<section id="events-intensity-bounds" class="level3" data-number="2.4.1">
<h3 data-number="2.4.1" class="anchored" data-anchor-id="events-intensity-bounds"><span class="header-section-number">2.4.1</span> Events intensity bounds</h3>
<p>The simulation algorithms implemented in <code>IBMPopSim</code> are based on an acceptance/rejection procedure, which requires to specify bounds for the various events intensities <span class="math inline">\Lambda^e_t(Z_t)</span>. These bounds are defined differently depending on the expression of the intensity.</p>
<div id="cnj-intensity-poisson" class="theorem conjecture">
<p><span class="theorem-title"><strong>Assumption 1</strong></span> For all events <span class="math inline">e \in \mathcal{P}</span> with Poisson intensity <a href="#eq-poisson-intensity" class="quarto-xref">Equation&nbsp;3</a>, the intensity is assumed to be bounded on <span class="math inline">[0,T]</span>: <span class="math display">
    \forall t \in [0,T], \quad \Lambda^e_t(Z_t) = \mu^e(t) \leq \bar \mu^e.
</span></p>
</div>
<p>When <span class="math inline">e \in \mathcal{E} \cup \mathcal{E}_W</span>, <span class="math inline">\Lambda^e_t(Z_t) =\sum_{k=1}^{N_t} \lambda^e_t(I_k,Z_t)</span>, assuming that <span class="math inline">\Lambda^e_t(Z_t)</span> is uniformly bounded is too restrictive since the event intensity depends on the population size. In this case, the assumption is made on the individual intensity <span class="math inline">\lambda^e</span> or on the interaction function <span class="math inline">W^e</span>, depending on the situation.</p>
<div id="cnj-intensity1" class="theorem conjecture">
<p><span class="theorem-title"><strong>Assumption 2</strong></span> For all event types <span class="math inline">e \in \mathcal{E}</span>, the associated individual event intensity <span class="math inline">\lambda^e</span> with no interactions, <em>i.e.</em> <span class="math inline">\lambda^e</span> verifies <a href="#eq-intensity-no-interaction" class="quarto-xref">Equation&nbsp;5</a>, is assumed to be uniformly bounded: <span class="math display">
    \lambda^e(t, I) \leq \bar \lambda^e, \quad \forall \;  t\in [0, T],  \;   I \in \mathcal{I}.
</span> In particular, <span id="eq-def-bar-Lambda"><span class="math display">
    \forall t \in [0,T], \quad \Lambda^e_t (Z_t) = \sum_{k=1}^{N_t} \lambda^e(t, I) \leq \bar \lambda^e  N_t .
\tag{10}</span></span></p>
</div>
<div id="cnj-intensity2" class="theorem conjecture">
<p><span class="theorem-title"><strong>Assumption 3</strong></span> For all event types <span class="math inline">e \in \mathcal{E}_W</span>, the associated interaction function <span class="math inline">W^e</span> is assumed to be uniformly bounded: <span class="math display">
    W^e(t, I, J) \leq \bar W^e, \quad \forall \; t\in [0,T], \;   I, J \in \mathcal{I}.
</span> In particular, <span class="math inline">\forall t \in [0,T]</span>, <span class="math display">
    \lambda^e_t (I,Z_t) = \sum_{j=1}^{N_t} W^e(t, I, I_j)  \leq  \bar W^e N_t, \quad \text{and} \quad \Lambda^e_t (Z_t) \leq \bar W^e (N_t)^2.
</span></p>
</div>
<p><a href="#cnj-intensity-poisson" class="quarto-xref">Assumption&nbsp;1</a>, <a href="#cnj-intensity1" class="quarto-xref">Assumption&nbsp;2</a> and <a href="#cnj-intensity2" class="quarto-xref">Assumption&nbsp;3</a> yield that events in the population occur with the global event intensity&nbsp;<span class="math inline">\Lambda_t(Z_t)</span>, given in <a href="#eq-global-ev-intensity" class="quarto-xref">Equation&nbsp;9</a>, which is dominated by a polynomial function in the population size: <span id="eq-def-bar-Lambda"><span class="math display">
    \Lambda_t(Z_t) \leq \bar \Lambda(N_t), \quad \text{with }  \bar \Lambda (n) = \sum_{e \in \mathcal{P}} \bar \mu^e + \sum_{e\in \mathcal{E}}\bar \lambda^e  n + \sum_{e \in \mathcal E_W} \bar W^e n^2.
\tag{11}</span></span> This bound is linear in the population size if there are no interactions, and quadratic if there at least is an event including interactions. This assumption is the key to the algorithms implemented in <code>IBMPopSim</code>. Before presenting the simulation algorithm, we close this section with a rigorous definition of an IBM, based on the pathwise representation of its dynamics a Stochastic Differential Equation (SDE) driven by Poisson random measures.</p>
</section>
</section>
<section id="pathwise-representation" class="level2" data-number="2.5">
<h2 data-number="2.5" class="anchored" data-anchor-id="pathwise-representation"><span class="header-section-number">2.5</span> Pathwise representation</h2>
<p>Since the seminal paper of <span class="citation" data-cites="FouMel04">(<a href="#ref-FouMel04" role="doc-biblioref">Fournier and Méléard 2004</a>)</span>, it has been shown in many examples that a stochastic IBM dynamics can be defined rigorously as the unique solution of an SDE driven by Poisson measures, under reasonable non explosion conditions. In the following, we introduce a unified framework for the pathwise representation of the class of stochastic IBMs introduced above. Some recalls on Poisson random measures are presented in the Appendix <a href="#sec-recall-poisson" class="quarto-xref">Section&nbsp;6.1</a>, and for more details on these representations on particular examples, we refer to the abundant literature on the subject.</p>
<p>In the following we consider an individual-based stochastic population <span class="math inline">(Z_t)_{t\in [0,T]}</span>, keeping the notations introduced in <a href="#sec-events" class="quarto-xref">Section&nbsp;2.3</a> and <a href="#sec-event-intensity" class="quarto-xref">Section&nbsp;2.4</a> for the events and their intensities. In particular, the set of events types that define the population evolution is denoted by <span class="math inline">\mathcal{P} \cup \mathcal{E} \cup \mathcal{E}_W \subset E</span>, with <span class="math inline">\mathcal{P}</span> the set of events types with Poisson intensity verifying <a href="#cnj-intensity-poisson" class="quarto-xref">Assumption&nbsp;1</a>, <span class="math inline">\mathcal{E}</span> the set of events types with individual intensity and no interaction, verifying <a href="#cnj-intensity1" class="quarto-xref">Assumption&nbsp;2</a> and finally <span class="math inline">\mathcal{E}_W</span> the set of event types with interactions, verifying <a href="#cnj-intensity2" class="quarto-xref">Assumption&nbsp;3</a>.</p>
<section id="non-explosion-criterion" class="level3" data-number="2.5.1">
<h3 data-number="2.5.1" class="anchored" data-anchor-id="non-explosion-criterion"><span class="header-section-number">2.5.1</span> Non explosion criterion</h3>
<p>First, one has to ensure that the number of events occurring in the population will not explode in finite time, leading to an infinite simulation time. <a href="#cnj-intensity1" class="quarto-xref">Assumption&nbsp;2</a> and <a href="#cnj-intensity2" class="quarto-xref">Assumption&nbsp;3</a> are not sufficient to guarantee the non explosion of the event number, due to the potential explosion of the population size in the presence of interactions. An example is the case when only birth events occur, with an intensity <span class="math inline">\Lambda^b_t(Z_t) = C_b (N_t^a)^2</span> (<span class="math inline">W^b(t, I,J) =C_b</span>). Then, the number of alive individuals <span class="math inline">(N_t^a)_{t\geq 0}</span> is a well-known pure birth process of intensity function <span class="math inline">g(n) = C_b n^2</span> (intensity of moving from state <span class="math inline">n</span> to <span class="math inline">n+1</span>). This process explodes in finite time, since <span class="math inline">g</span> does not verify the necessary and sufficient non explosion criterion for pure birth Markov processes: <span class="math inline">\sum_{n=1}^\infty \frac{1}{g(n)} = \infty</span> (see e.g.&nbsp;Theorem 2.2 in <span class="citation" data-cites="BanMel15">(<a href="#ref-BanMel15" role="doc-biblioref">Bansaye and Méléard 2015</a>)</span>). There is thus an explosion in finite time of birth events.</p>
<p>This example shows that the important point for non explosion is to control the population size. We give below a general sufficient condition on birth and entry event intensities, in order for the population size to stay finite in finite time. This ensures that the number of events does not explode in finite time. Informally, the idea is to control the intensities by a pure birth intensity function verifying the non-explosion criterion.</p>
<div id="cnj-non-explosion" class="theorem conjecture">
<p><span class="theorem-title"><strong>Assumption 4</strong></span> Let <span class="math inline">e=b</span> or <span class="math inline">en</span>, a birth or entry event type. If the intensity at which the events of type <span class="math inline">e</span> occur in the population are not Poissonian, i.e.&nbsp;<span class="math inline">e \in \mathcal{E} \cup \mathcal{E}_W</span>, then there exists a function <span class="math inline">f^e : {\mathbb{N}}\to (0, +\infty)</span>, such that <span class="math display">
    \sum_{n=1}^{\infty} \frac{1}{nf^e(n)} = \infty,
</span> and for all individual <span class="math inline">I \in \mathcal{I}</span> and population measure <span class="math inline">Z = \sum_{k=1}^{n} \delta_{I_k}</span> of size <span class="math inline">n</span>, <span class="math display">
    \lambda^e_t (I, Z) \leq f^e(n), \; \forall \; 0\leq t \leq T.
</span></p>
</div>
<div id="rem">
<p>If <span class="math inline">e \in \mathcal{E}</span>, <span class="math inline">\lambda_t^e(I,Z) = \lambda^e(t,I) \leq \bar{\lambda}^e</span> by the domination <a href="#cnj-intensity2" class="quarto-xref">Assumption&nbsp;3</a>, then <a href="#cnj-non-explosion" class="quarto-xref">Assumption&nbsp;4</a> is always verified with <span class="math inline">f^e(n) = \bar{\lambda}^e</span>.</p>
</div>
<p><a href="#cnj-non-explosion" class="quarto-xref">Assumption&nbsp;4</a> yields that the global intensity <span class="math inline">\Lambda_t^e(\cdot)</span> of event <span class="math inline">e</span> is bounded by a function <span class="math inline">g^e</span> only depending on the population size: <span class="math display">
    \Lambda_t^e (Z) \leq g^e(n) := nf^e(n), \quad \text{with }\sum_{n=1}^{\infty} \frac{1}{g^e(n)} = \infty.
</span> If <span class="math inline">e\in \mathcal{P}</span> has a Poisson intensity, then <span class="math inline">\Lambda_t^e(Z) =\mu^e_t</span> always verifies the previous equation with <span class="math inline">g^e(n) = \bar \mu^e</span>.</p>
<p>Before introducing the IBM SDE, let us give an idea of the equation construction. Between two successive events, the population composition <span class="math inline">Z_t</span> stays constant, since the population process <span class="math inline">(Z_t)_{t \geq 0}</span> is a pure jump process. Furthermore, since each event type is characterized by an intensity function, the jumps occurring in the population can be represented by restriction and projection of a Poisson measure defined on a larger state space. More precisely, we introduce a random Poisson measure <span class="math inline">Q</span> on <span class="math inline">\mathbb R^+ \times \mathcal{J}\times \mathbb{R}^+</span>, with <span class="math inline">\mathcal{J}= \mathbb N \times(\mathcal E \cup \mathcal{E}_W)</span>. <span class="math inline">Q</span> is composed of random quadruplets <span class="math inline">(\tau, k , e, \theta)</span>, where <span class="math inline">\tau</span> represents a potential event time for an individual <span class="math inline">I_k</span> and event type <span class="math inline">e</span>. The last variable <span class="math inline">\theta</span> is used to accept/reject this proposed event, depending on the event intensity. Hence, the Poisson measure is restricted to a certain random set and then projected on the space of interest <span class="math inline">{\mathbb{R}}^+ \times \mathcal{J}</span>. If the event is accepted, then a jump <span class="math inline">\phi^e(\tau,I_k)</span> occurs.</p>
<div id="thm-eq-Z" class="theorem">
<p><span class="theorem-title"><strong>Theorem 1 (Pathwise representation)</strong></span> Let <span class="math inline">T\in {\mathbb{R}}^+</span> and <span class="math inline">\mathcal{J}= \mathbb N \times(\mathcal E \cup \mathcal{E}_W)</span>. Let <span class="math inline">Q</span> be a random Poisson measure on <span class="math inline">\mathbb R^+ \times \mathcal{J}\times \mathbb{R}^+</span>, of intensity <span class="math inline">\mathrm{d}t \delta_{\mathcal{J}}(\mathrm{d}k,\mathrm{d}e)  \mathbf{1}_{[0,\bar \lambda^e]} (\theta)\mathrm{d}\theta</span>, with <span class="math inline">\delta_{\mathcal{J}}</span> the counting measure on <span class="math inline">\mathcal{J}</span>. Finally, let <span class="math inline">Q^{\mathcal P}</span> be a random Poisson measure on <span class="math inline">\mathbb R^+ \times \mathcal{P}  \times \mathbb{R}^+</span>, of intensity <span class="math inline">\mathrm{d}t \delta_{\cal P}(\mathrm{d}e)  \mathbf{1}_{[0,\bar \mu^e]} (\theta)\mathrm{d}\theta</span>, and <span class="math inline">Z_0= \sum_{k=1}^{N_0} \delta_{I_k}</span> an initial population. Then, under <a href="#cnj-non-explosion" class="quarto-xref">Assumption&nbsp;4</a> , there exists a unique measure-valued population process <span class="math inline">Z</span>, strong solution on the following SDE driven by the Poisson measure <span class="math inline">Q</span>: <span id="eq-sde-eq-Z"><span class="math display">
    \begin{aligned}
    Z_t = Z_0 &amp;+ \int_0^t \int_{ \mathcal{J}\times \mathbb R^+ }\phi^e (s , I_k)  \mathbf{1}_{\{k \leq N_{s^-}\} }\mathbf{1}_{\{\theta \leq \lambda_s^e(I_k, Z_{s^-})\}} Q (\mathrm{d}s ,\mathrm{d}k , \mathrm{d}e, \mathrm{d}\theta ) \\
    \nonumber &amp;+   \int_0^t \int_{\mathcal{P} \times \mathbb R^+}  \phi^e(s, I_{s^-}) \mathbf{1}_{\{\theta \leq \mu^e(s) \}} Q^{\mathcal{P}} (\mathrm{d}s ,\mathrm{d}e,  \mathrm{d}\theta),  \qquad \forall  0 \leq t \leq T,
\end{aligned}
\tag{12}</span></span> and where <span class="math inline">I_{s^-}</span> is an individual, chosen uniformly among alive individuals in the population <span class="math inline">Z_{s^-}</span>.</p>
</div>
<p>The proof of <a href="#thm-eq-Z" class="quarto-xref">Theorem&nbsp;1</a> is detailed in the Appendix, <a href="#sec-prf-thm-eq-Z" class="quarto-xref">Section&nbsp;6.2.2</a>. Note that <a href="#eq-sde-eq-Z" class="quarto-xref">Equation&nbsp;12</a> is an SDE describing the evolution of the IBM, the intensity of the events in the right hand side of the equation depending on the population process <span class="math inline">Z</span> itself. The main idea of the proof of <a href="#thm-eq-Z" class="quarto-xref">Theorem&nbsp;1</a> is to use the non explosion property of <a href="#lem-non-explosion" class="quarto-xref">Lemma&nbsp;1</a>, and to write the r.h.s of <a href="#eq-sde-eq-Z" class="quarto-xref">Equation&nbsp;12</a> as a sum of simple equations between two successive events, solved by induction.</p>
<div id="lem-non-explosion" class="theorem lemma">
<p><span class="theorem-title"><strong>Lemma 1</strong></span> Let <span class="math inline">Z</span> be a solution of <a href="#eq-sde-eq-Z" class="quarto-xref">Equation&nbsp;12</a> on <span class="math inline">{\mathbb{R}}^+</span>, with <span class="math inline">(T_n)_{n\geq 0}</span> its jump times, <span class="math inline">T_0 = 0</span>. If <a href="#cnj-non-explosion" class="quarto-xref">Assumption&nbsp;4</a> is satisfied, then <span class="math display">
    \lim_{n \to \infty} T_n = \infty, \quad {\mathbb{P}}\text{-a.s.}
</span></p>
</div>
<p>The proof of <a href="#lem-non-explosion" class="quarto-xref">Lemma&nbsp;1</a>, detailed in Appendix <strong>?@sec-prf-lem-non-explosion</strong> is more technical and rely on pathwise comparison result, generalizing those obtained in <span class="citation" data-cites="KaaElK20">(<a href="#ref-KaaElK20" role="doc-biblioref">Kaakai and El Karoui 2023</a>)</span>. An alternative pathwise representation of the population process, inspired by the randomized <strong>?@cnj-randomized</strong> is given as well in <strong>?@thm-randomized</strong>.</p>
</section>
</section>
</section>
<section id="sec-simulation" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Population simulation</h1>
<p>We now present the main algorithm for simulating the evolution of an IBM over <span class="math inline">[0,T]</span>.The algorithm implemented in <code>IBMPopSim</code> allows the exact simulation of <a href="#eq-sde-eq-Z" class="quarto-xref">Equation&nbsp;12</a>, based on an acceptance/reject algorithm for simulating random times called <em>thinning</em>. The exact simulation of event times with this acceptance/reject procedure is closely related to the simulations of inhomogeneous Poisson processes by the so-called thinning algorithm, often attributed to <span class="citation" data-cites="LewShe79">(<a href="#ref-LewShe79" role="doc-biblioref">Lewis and Shedler 1979</a>)</span>. The simulation methods for inhomogeneous Poisson processes can be adapted to IBMs, and we introduce in this section a general algorithm extending those by <span class="citation" data-cites="FouMel04">(<a href="#ref-FouMel04" role="doc-biblioref">Fournier and Méléard 2004</a>)</span> (see also <span class="citation" data-cites="FerTra09">(<a href="#ref-FerTra09" role="doc-biblioref">Ferrière and Tran 2009</a>)</span>, <span class="citation" data-cites="Ben10">(<a href="#ref-Ben10" role="doc-biblioref">Bensusan 2010</a>)</span>).</p>
<p>The algorithm is based on exponential “candidate” event times, chosen with a (constant) intensity which must be greater than the global event intensity <span class="math inline">\Lambda_t(Z_t)</span> (<a href="#eq-global-intensity" class="quarto-xref">Equation&nbsp;4</a>). Starting from time <span class="math inline">t</span>, once a candidate event time <span class="math inline">t + \bar T_\ell</span> has been proposed, a candidate event type <span class="math inline">e</span> (birth, death,...) is chosen with a probability <span class="math inline">p^e</span> depending on the event intensity bounds <span class="math inline">\bar \mu^e</span>, <span class="math inline">\bar \lambda^e</span> and <span class="math inline">\bar W^e</span>, as defined in <a href="#cnj-intensity1" class="quarto-xref">Assumption&nbsp;2</a> and <a href="#cnj-intensity2" class="quarto-xref">Assumption&nbsp;3</a>. An individual <span class="math inline">I</span> is then drawn from the population. Finally, it remains to accept or reject the candidate event with a probability <span class="math inline">q^e(t,I,Z_t)</span> depending on the true event intensity. If the candidate event time is accepted, then the event <span class="math inline">e</span> occurs at time <span class="math inline">t + \bar T_\ell</span> to the individual <span class="math inline">I</span>. The main idea of the algorithm implemented can be summarized as follows:</p>
<ol type="1">
<li>Draw a candidate time <span class="math inline">t + \bar T_\ell</span> and candidate event type <span class="math inline">e</span>.</li>
<li>Draw a uniform variable <span class="math inline">\theta \sim \mathcal{U}([0, 1])</span> and individual <span class="math inline">I</span>.</li>
<li><strong>If</strong> <span class="math inline">\theta \leq q^e(t,I,Z_t)</span> <strong>then</strong> event <span class="math inline">e</span> occur to individual <span class="math inline">I</span>, <strong>else</strong> Do nothing and start again from <span class="math inline">t + \bar T_\ell</span>.</li>
</ol>
<p>Before introducing the main algorithms in more details, we recall briefly the thinning procedure for simulating inhomogeneous Poisson processes, as well as the links with pathwise representations. Some recalls on Poisson random measures are presented in <a href="#sec-recall-poisson" class="quarto-xref">Section&nbsp;6.1</a>. For a more general presentation of thinning of a Poisson random measure, see <span class="citation" data-cites="Dev86 Cin11 Kal17">(<a href="#ref-Dev86" role="doc-biblioref">Devroye 1986</a>; <a href="#ref-Cin11" role="doc-biblioref">Çinlar 2011</a>; <a href="#ref-Kal17" role="doc-biblioref">Kallenberg 2017</a>)</span>.</p>
<section id="sec-thinning" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="sec-thinning"><span class="header-section-number">3.1</span> Thinning of Poisson measure</h2>
<p>Let us start with the simulation and pathwise representation of an inhomogeneous Poisson process on <span class="math inline">[0,T]</span> with intensity <span class="math inline">(\Lambda(t))_{t\in [0,T]}</span>. The thinning procedure is based on the fundamental assumption that <span class="math inline">\Lambda(t) \leq  \bar \Lambda</span> is bounded on <span class="math inline">[0,T]</span>. In this case, the inhomogeneous Poisson can be obtained from an homogeneous Poisson process of intensity <span class="math inline">\bar \Lambda</span>, which can be simulated easily.</p>
<p>First, the Poisson process can be extended to a Marked Poisson measure <span class="math inline">\bar Q:= \sum_{\ell \ge 1} \delta_{(\bar T_\ell, \bar \Theta_\ell)}</span> on <span class="math inline">(\mathbb{R}^+)^2</span>, defined as follow:</p>
<ul>
<li><p>The jump times of <span class="math inline">(\bar T_\ell)_{\ell \ge 1}</span> of <span class="math inline">\bar Q</span> are the jump times of a Poisson process of intensity <span class="math inline">\bar \Lambda</span>.</p></li>
<li><p>The marks <span class="math inline">(\bar \Theta_\ell)_{\ell \ge 1}</span> are <em>i.i.d.</em> random variables, uniformly distributed on <span class="math inline">[0, \bar \Lambda]</span>.</p></li>
</ul>
<p>By <a href="#prp-marked-poisson" class="quarto-xref">Proposition&nbsp;6</a> , <span class="math inline">\bar{Q}</span> is a Poisson random measure with mean measure <span class="math display">
    \bar \mu(\mathrm{d}t, \mathrm{d}\theta): = \bar \Lambda \mathrm{d}t
    \frac{\mathbf{1}_{[0, \bar \Lambda]}(\theta)}{\bar \Lambda} \mathrm{d}\theta= \mathrm{d}t  \mathbf{1}_{[0, \bar \Lambda]}(\theta) \mathrm{d}\theta.
</span> In particular, the average number of atoms <span class="math inline">(\bar T_\ell, \bar \Theta_\ell)</span> in <span class="math inline">[0,t]\times [0,h]</span> is <span class="math display">
    \mathbb{E}[Q([0,t]\times [0,h])]={\mathbb{E}}[\sum_{\ell} \boldsymbol{1}_{[0,t]\times [0,h]} (\bar T_\ell, \bar \Theta_{\ell})]  = \int_{(\mathbb{R}^+)^2}  \bar \mu(\mathrm{d}t, \mathrm{d}\theta)  = t (\bar \Lambda \wedge h).
</span> The thinning is based on the restriction property for Poisson measure: for a measurable set <span class="math inline">\Delta\subset {\mathbb{R}}^+\times {\mathbb{R}}^+</span>, the restriction <span class="math inline">Q^\Delta:= \boldsymbol{1}_{\Delta}\bar Q</span> of <span class="math inline">\bar Q</span> to <span class="math inline">\Delta</span> (by taking only atoms in <span class="math inline">\Delta</span>) is also a Poisson random measure of mean measure <span class="math inline">\mu^{\Delta}(\mathrm{d}t, \mathrm{d}\theta)  = \boldsymbol{1}_{\Delta}(t,\theta) \bar \mu(\mathrm{d}t, \mathrm{d}\theta).</span></p>
<p>In order to obtain an inhomogeneous Poisson measure of intensity <span class="math inline">(\Lambda(t))</span>, the “good” choice of <span class="math inline">\Delta</span> is the hypograph of <span class="math inline">\Lambda</span>: <span class="math inline">\Delta =\{ (t,\theta) \in [0,T]\times [0,\bar \Lambda] ; \; \theta \leq \Lambda(t)\}</span> (see <a href="#fig-thinning" class="quarto-xref">Figure&nbsp;1</a>). Then, <span class="math display">
    Q^\Delta = \sum_{\ell \ge 1} \mathbf{1}_{\left\{\bar \Theta_\ell \le \Lambda(\bar T_\ell)\right\}} \delta_{(\bar T_\ell, \bar \Theta_\ell)},
</span> and since <span class="math inline">\Lambda(t) \leq \bar \Lambda</span>, on <span class="math inline">[0,T]</span>: <span class="math display">
\begin{aligned}
    \mu^{\Delta}(\mathrm{d}t, \mathrm{d}\theta) &amp; = \boldsymbol{1}_{\{ \theta \leq \Lambda(t)\}}  \mathrm{d}t
\mathbf{1}_{[0, \bar \Lambda]}(\theta)\mathrm{d}\theta = \boldsymbol{1}_{\{\theta \leq \Lambda(t)\}} \mathrm{d}t \mathrm{d}\theta.
\end{aligned}
</span></p>
<div id="fig-thinning" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-thinning-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<embed src="img/plot_thinning.tex" class="img-fluid">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-thinning-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: test
</figcaption>
</figure>
</div>
<p>Finally, the inhomogeneous Poisson process is obtained by the projection <a href="#prp-proj-poisson-measure" class="quarto-xref">Proposition&nbsp;5</a>, which states that the jump times of <span class="math inline">Q^\Delta</span> are the jump times of an inhomogeneous Poisson process of intensity <span class="math inline">(\Lambda(t))</span>.</p>
<div id="prp-thinning" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 1</strong></span> The counting process <span class="math inline">N^\Lambda</span>, projection of <span class="math inline">Q^{\Delta}</span> on the time component and defined by, <span id="eq-thinning-inhomogeneous-poisson"><span class="math display">
    N^{\Lambda}_t := Q^{\Delta}( [0,t] \times {\mathbb{R}}^+) = \int_0^t \int_{{\mathbb{R}}^+} \boldsymbol{1}_{\{\theta \leq \Lambda(s)\}} \bar Q(\mathrm{d}s, \mathrm{d}\theta) = \sum_{\ell \geq 1} \mathsf{1}_{\{ \bar T_\ell \leq t \}} \mathsf{1}_{\{\bar \Theta_\ell \leq  \Lambda(\bar T_\ell) \}},  \quad \forall t \in [0,T],
\tag{13}</span></span> is an inhomogeneous Poisson process on <span class="math inline">[0,T]</span> of intensity function <span class="math inline">(\Lambda(t))_{t\in [0,T]}</span>. The thinning <a href="#eq-thinning-inhomogeneous-poisson" class="quarto-xref">Equation&nbsp;13</a> is a pathwise representation of <span class="math inline">N^\Lambda</span> by <em>restriction and projection</em> of the Poisson measure <span class="math inline">Q</span> on <span class="math inline">[0,T]</span>.</p>
</div>
<p>The previous proposition yields a straightforward thinning algorithm to simulate the jump times <span class="math inline">(T_k)_{k \ge 1}</span> of an inhomogeneous Poisson process of intensity <span class="math inline">\Lambda(t)</span>, by selecting jump times <span class="math inline">\bar T_\ell</span> such that <span class="math inline">\bar \Theta_\ell \le \Lambda(\bar T_\ell)</span>.</p>
<section id="sec-vector" class="level3" data-number="3.1.1">
<h3 data-number="3.1.1" class="anchored" data-anchor-id="sec-vector"><span class="header-section-number">3.1.1</span> Multivariate Poisson process</h3>
<p>This can be extended to the simulation of multivariate inhomogeneous Poisson processes, which is an important example before tackling the simulation of an IBM.</p>
<p>Let <span class="math inline">(N^j)_{j \in \mathcal{J}}</span> be a (inhomogeneous) multivariate Poisson process indexed by a finite set <span class="math inline">\mathcal{J}</span>, such that <span class="math inline">\forall j \in \mathcal{J}</span>, the intensity <span class="math inline">(\lambda_j(t))_{t\in [0,T]}</span> of <span class="math inline">N_j</span> is bounded on <span class="math inline">[0,T]</span>: <span class="math display">
    \sup_{t\in[0,T]} \lambda_j(t) \le \bar \lambda_j, \text{ and let }
    \bar \Lambda = \sum_{j \in \mathcal{J}} \bar \lambda_j.
</span> Recall that such multivariate counting process can be rewritten as a Poisson random measure <span class="math inline">N= \sum_{k\geq 1} \delta_{(T_k,J_k)}</span> on <span class="math inline">{\mathbb{R}}^+\times \mathcal{J}</span> (see e.g.&nbsp;Sec. 2 of Chapter 6 in&nbsp;<span class="citation" data-cites="Cin11">(<a href="#ref-Cin11" role="doc-biblioref">Çinlar 2011</a>)</span>), where <span class="math inline">T_k</span> is the <span class="math inline">k</span>th jump time of <span class="math inline">\sum_{j\in \mathcal{J}} N^j</span> and <span class="math inline">J_k</span> corresponds to the component of the the vector which jumps. In particular, <span class="math inline">N^j_t = N([0,t]\times \{j\})</span>.</p>
<p>Once again the simulation of such process can be obtained from the simulation of a (homogeneous) multivariate Poisson process of intensity vector <span class="math inline">(\bar{\lambda}_j)_{j \in \mathcal{J}}</span>, extended into a Poisson measures by adding marks on <span class="math inline">{\mathbb{R}}^+</span>. Thus, we introduce the Marked Poisson measure <span class="math inline">\bar Q = \sum \delta_{(\bar T_\ell, \bar J_\ell, \bar \Theta_\ell)}</span> on <span class="math inline">{\mathbb{R}}^+  \times \mathcal{J}\times {\mathbb{R}}^+</span>, such that:</p>
<ul>
<li>The jump times <span class="math inline">(\bar T_\ell)</span> of <span class="math inline">\bar Q</span> are the jump times of a Poisson measure of intensity <span class="math inline">\bar \Lambda</span>.</li>
<li>The variables <span class="math inline">(\bar J_\ell)</span> are <em>i.i.d.</em> random variables on <span class="math inline">\mathcal{J}</span>, with <span class="math inline">\displaystyle p_j= {\mathbb{P}}(\bar J_1 = j)= \bar \lambda_j/\bar \Lambda</span> and representing the component of the vector which jumps.</li>
<li>The marks <span class="math inline">(\bar \Theta_\ell)</span> are independent variables with <span class="math inline">\bar \Theta_\ell</span> a uniform random variable on <span class="math inline">[0,\bar \lambda_{{\bar J}_\ell}]</span>, <span class="math inline">\forall \ell \geq 1</span>.</li>
</ul>
<p>By <a href="#prp-marked-poisson" class="quarto-xref">Proposition&nbsp;6</a> and <a href="#prp-proj-poisson-measure" class="quarto-xref">Proposition&nbsp;5</a>, each measure <span class="math inline">\bar Q_j (\mathrm{d}t, \mathrm{d}\theta) = \bar Q(\mathrm{d}t, \{j\}, \mathrm{d}\theta) = \sum_{\ell \geq 1} \mathsf{1}_{\{\bar J_\ell=j \}} \delta_{(\bar T_\ell, \bar \Theta_\ell)}</span> is a marked Poisson measure of intensity <span class="math display">
    \bar \mu_j ( \mathrm{d}t  ,\mathrm{d}\theta) = \bar{\Lambda}p_j \mathrm{d}t  \frac{\mathsf{1}_{\{\theta \leq \bar \lambda_{j}\}}(\theta)}{\bar \lambda_{j}} \mathrm{d}\theta = \mathrm{d}t  \mathsf{1}_{\{\theta \leq \bar \lambda_{j}\}}(\theta) \mathrm{d}\theta.
</span> As a direct application of <a href="#prp-thinning" class="quarto-xref">Proposition&nbsp;1</a> , the inhomogeneous multivariate Poisson process is obtained by restriction of each measures <span class="math inline">\bar Q_j</span> to <span class="math inline">\Delta_j = \{ (t, \theta) \in [0,T] \times [0,\bar \lambda_j] ;\; \theta \leq \lambda_j(t) \}</span> and projection.</p>
<div id="prp-thinning-vector" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 2</strong></span> The multivariate counting process <span class="math inline">(N^j)_{j \in \mathcal{J}}</span>, defined for all <span class="math inline">j \in \mathcal{J}</span> and <span class="math inline">t \in [0,T]</span> by thinning and projection of <span class="math inline">\bar Q</span>: <span class="math display">
    N^j_t  := \int_0^t \int_{ {\mathbb{R}}^+} \boldsymbol{1}_{\{\theta \leq \lambda_j(s)\}} \bar{Q}(\mathrm{d}s, \{j\}, \mathrm{d}\theta) = \sum_{\ell \geq 1} \mathsf{1}_{\{ \bar T_\ell \leq t \}}\mathsf{1}_{\{\bar J_\ell = j\}} \mathsf{1}_{\{\bar \Theta_\ell \leq  \lambda_j (\bar T_\ell ) \}},
</span> is an inhomogeneous Poisson process of intensity vector <span class="math inline">(\lambda_j(t))_{j\in\mathcal{J}}</span> on <span class="math inline">[0,T]</span>.</p>
</div>
<p><a href="#prp-thinning-vector" class="quarto-xref">Proposition&nbsp;2</a> yields the following simulation <a href="#alg-thinning2">Algorithm 1</a> for multivariate Poisson processes.</p>
<div id="alg-thinning2" class="pseudocode-container" data-no-end="false" data-pseudocode-index="1" data-indent-size="1.2em" data-line-number-punc=":" data-line-number="true" data-alg-title="Algorithm" data-comment-delimiter="//">
<div class="pseudocode">
\begin{algorithm} \caption{Thinning algorithm for multivariate inhomogeneous Poisson processes.} \begin{algorithmic} \State \textbf{Input:} Functions $\lambda_j: [0,T] \to [0,\bar \lambda]$ and $\bar \lambda_j$, $\bar \Lambda = \sum_{j \in \mathcal{J}} \bar \lambda_j$ \State \textbf{Output:} Points $(T_k, J_k)$ of Poisson measure $N$ on $[0,T] \times \mathcal{J}$ \State Initialization $T_0 \longleftarrow 0$, $\bar T_0 \longleftarrow 0$ \While{$T_k &lt; T$} \Repeat \State increment iterative variable $\ell \longleftarrow \ell+1$ \State compute next proposed time $\bar T_{\ell} \longleftarrow \bar T_{\ell-1} + S_\ell$ with $S_\ell \sim \mathcal{E}(\bar \Lambda)$ \State draw $\bar J_\ell \sim \mathcal{U}\big\{ \bar \lambda_j / \bar \Lambda, j \in \mathcal{J} \big\}$ i.e. $\mathbb{P}(\bar J_\ell = j) = \bar \lambda_j / \bar \Lambda$ \State draw $\bar \Theta_\ell \sim \mathcal{U}([0,\bar \lambda_{\bar J_\ell}])$ \Until{accepted event $\bar \Theta_\ell \le \lambda_{\bar J_\ell}(\bar T_{\ell})$} \State record $(T_k, J_k) \longleftarrow (\bar T_{\ell}, \bar J_\ell)$ as accepted point \EndWhile \end{algorithmic} \end{algorithm}
</div>
</div>
<div id="rem-alternate-thinning" class="proof remark">
<p><span class="proof-title"><em>Remark 2</em>. </span>The acceptance/rejection <a href="#alg-thinning2">Algorithm 1</a> can be efficient when the functions <span class="math inline">\lambda_j</span> are of different order, and thus bounded by different <span class="math inline">\bar \lambda_j</span>. However, it is important to note that the simulation of the discrete random variables <span class="math inline">(\bar J_\ell)</span> can be costly (compared to a uniform law) when <span class="math inline">\mathcal{J}</span> is large, for instance when an individual is drawn from a large population. In this case, an alternative is to choose the same bound <span class="math inline">\bar \lambda_j= \bar \lambda</span> for all <span class="math inline">j \in \mathcal{J}</span>. Then the marks <span class="math inline">(\bar J_\ell, \bar \Theta_\ell)</span> are <em>i.i.d.</em> uniform variables on <span class="math inline">\mathcal{J}\times [0,\bar \lambda]</span>, faster to simulate.</p>
</div>
</section>
</section>
<section id="sec-simulation-algo" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="sec-simulation-algo"><span class="header-section-number">3.2</span> Simulation algorithm</h2>
<p>Let us now come back to the simulation of the IBM introduced in <a href="#sec-ibm" class="quarto-xref">Section&nbsp;2</a>. For ease of notations, we assume that there are no event with Poisson intensity (<span class="math inline">\mathcal{P} =\emptyset</span>), so that all events that occur are of type <span class="math inline">e \in \mathcal{E} \cup \mathcal{E}_W</span>, with individual intensity <span class="math inline">\lambda_t^e(I,Z_t)</span> depending on the population composition <span class="math inline">Z_t</span> (<span class="math inline">e \in \mathcal{E}_W</span>) or not (<span class="math inline">e \in \mathcal{E}</span>), as defined in <a href="#eq-individual-intensity" class="quarto-xref">Equation&nbsp;7</a> and verifying either <a href="#cnj-intensity1" class="quarto-xref">Assumption&nbsp;2</a> or <a href="#cnj-intensity2" class="quarto-xref">Assumption&nbsp;3</a>. The global intensity <a href="#eq-global-ev-intensity" class="quarto-xref">Equation&nbsp;9</a> at time <span class="math inline">t \in [0,T]</span> is thus <span id="eq-def-intensity"><span class="math display">
    \Lambda_t(Z_t) = \sum_{e \in \mathcal{E}} \Big( \sum_{k=1}^{N_t} \lambda^e(t, I_k) \Big)
    + \sum_{e \in \mathcal{E}_W} \Big( \sum_{k=1}^{N_t} \sum_{j=1}^{N_t} W^e(t, I_k, I_j) \Big) \leq \bar \Lambda(N_t),
\tag{14}</span></span> with <span class="math inline">\bar \Lambda(n) = \big(\sum_{e \in \mathcal{E}} \bar \lambda^e \big) n + \big( \sum_{e \in \mathcal{E}_W} \bar W^e \big) n^2</span>.</p>
<p>One of the main difficulty is that the intensity of events is not deterministic as in the case of inhomogeneous Poisson processes, but a function <span class="math inline">\Lambda_t(Z_t)</span> of the population state, bounded by a function which also depends on the population size. However, the <a href="#alg-thinning2">Algorithm 1</a> can be adapted to simulate the IBM. The construction is done by induction, by conditioning on the state of the population <span class="math inline">Z_{T_k}</span> at the <span class="math inline">k</span>th event time <span class="math inline">T_k</span> (<span class="math inline">T_0 = 0</span>).</p>
<p>We first present the construction of the first event at time <span class="math inline">T_1</span>.</p>
<section id="first-event-simulation" class="level3" data-number="3.2.1">
<h3 data-number="3.2.1" class="anchored" data-anchor-id="first-event-simulation"><span class="header-section-number">3.2.1</span> First event simulation</h3>
<p>Before the first event time, on <span class="math inline">\{ t &lt; T_1 \}</span>, the population composition is constant : <span class="math inline">Z_t = Z_0 = \{ I_1, \dots, I_{N_0}\}</span>. For each type of event <span class="math inline">e</span> and individual <span class="math inline">I_k</span>, <span class="math inline">k \in \{1,\dots N_0\}</span>, we denote by <span class="math inline">N^{k,e}</span> the counting process of intensity <span class="math inline">\lambda_t^e (I_k,Z_t)</span>, counting the occurrences of the events of type <span class="math inline">e</span> happening to the individual <span class="math inline">I_k</span>. Then, the first event <span class="math inline">T_1</span> is the first jump time of the multivariate counting vector <span class="math inline">(N^{(k,e)})_{ (k,e) \in \mathcal{J}_0}</span>, with <span class="math inline">\mathcal{J}_0 = \{1,\dots , N_0\}\times \big(\mathcal{E} \cup \mathcal{E}_W \big)</span>.</p>
<p>Since the population composition is constant before the first event time, each counting process <span class="math inline">N^{j}</span> coincides on <span class="math inline">[0,T_1[</span> with an inhomogeneous Poisson process, of intensity <span class="math inline">\lambda_t^e (I_k,Z_0)</span>. Thus (conditionally to <span class="math inline">Z_0</span>), <span class="math inline">T_1</span> is also the first jump time of an inhomogeneous multivariate Poisson process <span class="math inline">N^0 = (N^{0,j})_{j \in \mathcal{J}_0}</span> of intensity function <span class="math inline">(\lambda_j)_{j\in \mathcal J_0}</span>, defined for all <span class="math inline">j = (k,e) \in \mathcal{J}_0</span> by: <span class="math display">
    \lambda_j(t) = \lambda^e_t(I_k,Z_0) \le \bar \lambda^e_0 \quad \text{with} \quad \bar \lambda^e_0 = \bar \lambda^e \mathbf{1}_{e \in \mathcal{E}} + \bar W^e N_0 \mathbf{1}_{e \in \mathcal{E}_W},
</span> by <a href="#cnj-intensity1" class="quarto-xref">Assumption&nbsp;2</a> and <a href="#cnj-intensity2" class="quarto-xref">Assumption&nbsp;3</a>. In particular, the jump times of <span class="math inline">N^0</span> occur at the intensity <span class="math display">
    \Lambda(t) =\sum_{j \in \mathcal{J}_0} \lambda_j(t)  =\sum_{e \in \mathcal{E} \cup \mathcal{E}_W} \sum_{k=1}^{N_0}  \lambda^e_t(I_k,Z_0) \leq \bar \Lambda(N_0)=N_0 \sum_{e \in \mathcal{E} \cup \mathcal{E}_W} \bar \lambda^e_0.
</span> By <a href="#prp-thinning-vector" class="quarto-xref">Proposition&nbsp;2</a>, <span class="math inline">N^0</span> can be obtained by thinning of the marked Poisson measure <span class="math inline">\bar Q^0 = \sum_{\ell \geq 1} \delta_{(\bar T_\ell , (\bar{K}_\ell, \bar E_\ell), \bar \Theta_\ell)}</span> on <span class="math inline">{\mathbb{R}}^+\times\mathcal{J}_0 \times {\mathbb{R}}^+</span>, with:</p>
<ul>
<li><span class="math inline">(\bar T_\ell)_{\ell \in {\mathbb{N}}^*}</span> the jump times of a Poisson process of rate <span class="math inline">\bar \Lambda(N_0)</span>.</li>
<li><span class="math inline">(\bar{K}_\ell, \bar E_\ell)_{\ell \in {\mathbb{N}}^*}</span> discrete <em>i.i.d.</em> random variables on <span class="math inline">\mathcal{J}_0 = \{1,\dots , N_0\}\times \big(\mathcal{E} \cup \mathcal{E}_W \big)</span>, with <span class="math inline">K_\ell</span> representing the index of the chosen individual and <span class="math inline">E_\ell</span> the event type for the proposed event, such that: <span class="math display">
  \mathbb{P}( \bar  K_1 = k, \bar E_1 = e)
  = \frac{\bar \lambda^e_0 }{\bar \Lambda(N_0)}
  = \frac{1}{N_0} \frac{\bar \lambda^e_0 N_0}{\bar \Lambda(N_0)},
</span> i.e.&nbsp;<span class="math inline">(\bar K_1, \bar E_1)</span> are distributed as independent random variables where <span class="math inline">\bar K_1 \sim \mathcal U(\{1,\dots, N_0\})</span> and <span class="math inline">\bar E_1</span> such that <span class="math display">
  p_e := \mathbb{P}( \bar E_1 = e)
      = \frac{\bar \lambda^e_0 N_0}{\bar \Lambda(N_0)}.
</span></li>
<li><span class="math inline">(\bar \Theta_\ell)_{\ell \in {\mathbb{N}}^*}</span> are independent uniform random variables, with <span class="math inline">\bar \Theta_\ell \sim \mathcal{U}([0,\bar \lambda^{\bar E_\ell}]).</span></li>
</ul>
<p>Since the first event is the first jump of <span class="math inline">N^0</span>, by <a href="#prp-thinning-vector" class="quarto-xref">Proposition&nbsp;2</a> and <a href="#alg-thinning2">Algorithm 1</a>, the first event time <span class="math inline">T_1</span> is the first jump time <span class="math inline">\bar T_\ell</span> of <span class="math inline">\bar Q^0</span> such that <span class="math inline">\bar \Theta_\ell \leq \lambda^{\bar E_\ell}_{\bar T_\ell}(I_{\bar K_\ell}, Z_0)</span>.</p>
<p>At <span class="math inline">T_1 =\bar T_{\ell}</span>, the event <span class="math inline">\bar E_\ell</span> occurs to the individual <span class="math inline">I_{\bar K_\ell} = (\tau^b, \infty, x)</span>. For instance, if <span class="math inline">\bar E_\ell =d</span>, a death/exit event occurs, so that <span class="math inline">Z_{T_1} = Z_{0} + \delta_{(\tau^b, T_1, x)} - \delta_{I_{\bar K_\ell}}</span> and <span class="math inline">N_{T_1} = N_{0}</span>. If <span class="math inline">\bar E_\ell =b</span> or <span class="math inline">en</span>, a birth or entry event occurs, so that <span class="math inline">N_{T_1} = N_{0} + 1</span>, and a new individual <span class="math inline">I_{N_0+1}</span> is added to the population, chosen as described in <a href="#tbl-event-action" class="quarto-xref">Table&nbsp;1</a>. Finally, if <span class="math inline">\bar E_\ell=s</span>, a swap event occurs, the population size stays constant and <span class="math inline">I_{\bar K_\ell}</span> is replaced by an individual <span class="math inline">I_{\bar K_\ell}'</span>, chosen as described in <a href="#tbl-event-action" class="quarto-xref">Table&nbsp;1</a>.</p>
<p>The steps for simulating the first event in the population can be iterated in order to simulate the population. At the <span class="math inline">k</span>th step, the same procedure is repeated to simulate the <span class="math inline">k</span>th event, starting from a population <span class="math inline">Z_{T_{k-1}}</span> of size <span class="math inline">N_{T_{k-1}}</span>.</p>
<div id="alg-no-interaction" class="pseudocode-container" data-no-end="false" data-pseudocode-index="2" data-indent-size="1.2em" data-line-number-punc=":" data-line-number="true" data-alg-title="Algorithm" data-comment-delimiter="//">
<div class="pseudocode">
\begin{algorithm} \caption{IBM simulation algorithm (without events of Poissonian intensity)} \begin{algorithmic} \State \textbf{Input:} Initial population $Z_0$, horizon $T &gt; 0$, and events described by: \State - Intensity functions and bounds $(\lambda^e, \bar \lambda^e)$ for $e \in \mathcal{E}$ and $(W^e, \bar W^e)$ for $e \in \mathcal{E}_W$ \State - Event action functions $\phi^e(t, I)$ for $e \in \mathcal{E} \cup \mathcal{E}_W$ (see @tbl-event-action) \State \textbf{Output:} Population $Z_T$ \State Initialization $T_0 \longleftarrow 0$, $\bar T_0 \longleftarrow 0$ \While{$T_k &lt; T$} \Repeat \State increment iterative variable $\ell \longleftarrow \ell+1$ \State compute next proposed time $\bar T_{\ell} \longleftarrow \bar T_{\ell-1} + \mathcal{E}\big(\bar \Lambda(N_{T_k}) \big)$ \State draw a proposed event $\bar E_\ell \sim \mathcal{U}\{p_e\}$ with $p_e = \frac{\bar \lambda^e \mathbf{1}_{e \in \mathcal{E}} + \bar W^e N_{T_k} \mathbf{1}_{e \in \mathcal{E}_W}}{\sum_{e \in \mathcal{E}} \bar \lambda^e + \sum_{e \in \mathcal{E}_W} \bar W^e N_{T_k}}$ \State draw an individual index $\bar K_\ell \sim \mathcal{U}(\{1,\dots,N_{T_k}\})$ \State draw $\bar \Theta_\ell \sim \mathcal{U}([0, \bar \lambda^{\bar E_\ell}])$ if $\bar E_\ell \in \mathcal{E}$ or $\bar \Theta_\ell \sim \mathcal{U}([0, \bar W^{\bar E_\ell} N_{T_k}])$ if $\bar E_\ell \in \mathcal{E}_W$ \Until{accepted event $\bar \Theta_\ell \le \lambda^{\bar E_\ell}_{\bar T_\ell}(I_{\bar K_\ell},Z_{T_{k}})$} \State increment iterative variable $k \longleftarrow k+1$ \State record $(T_k, E_k, I_k) \longleftarrow (\bar T_{\ell}, \bar E_\ell, I_{\bar K_\ell})$ as accepted time, event and individual \State update the population $Z_{T_k} = Z_{T_{k-1}} + \phi^{E_k}(T_k, I_k)$ \EndWhile \end{algorithmic} \end{algorithm}
</div>
</div>
<div id="thm-no-interaction" class="theorem">
<p><span class="theorem-title"><strong>Theorem 2</strong></span> <a href="#alg-no-interaction">Algorithm 2</a> are exact simulations of solution of the SDE <a href="#eq-sde-eq-Z" class="quarto-xref">Equation&nbsp;12</a>.</p>
</div>
<p>The proof of <a href="#thm-no-interaction" class="quarto-xref">Theorem&nbsp;2</a> is detailed in the Appendix <strong>?@prf-no-interaction</strong>.</p>
<div id="rem-remvoval-dead" class="proof remark">
<p><span class="proof-title"><em>Remark 3</em>. </span>The population <span class="math inline">Z_{T_k}</span> includes dead/exited individuals before the event time <span class="math inline">T_k</span>. Thus, <span class="math inline">N_{T_k} &gt; N_{T_k}^a</span> is greater than the number of alive individuals at time <span class="math inline">T_k</span>. When a dead individual <span class="math inline">I_{\bar K_l}</span> is drawn from the population during the rejection/acceptance phase of the algorithm, the proposed event <span class="math inline">(\bar T_{\ell}, \bar E_\ell,  I_{\bar K_\ell})</span> is automatically rejected since the event intensity is <span class="math inline">\lambda^{\bar E_\ell}_{T_\ell}(I_{\bar K_\ell}, Z_{T_k}) = 0</span> (nothing can happen to a dead individual). This can slow down the algorithm, especially when the proportion of dead/exited individuals in the population increases. However, the computational cost of keeping dead/exited individuals in the population is much lower than the cost of removing an individual from the population at each death/exit event, which is linear in the population size.</p>
<p>Actually, dead/exited individuals are regularly removed from the population in the <code>IBMPopSim</code> algorithm, in order to optimize the trade-off between having to many dead individuals and removing dead individuals from the population too often. The frequency at which dead individuals are “removed from the population” can be chosen by the user, as an optional argument of the main function <code>popsim</code> (see details in <a href="#sec-simulation" class="quarto-xref">Section&nbsp;3</a>).</p>
</div>
<div id="rem-sharp-bounds" class="proof remark">
<p><span class="proof-title"><em>Remark 4</em>. </span>In practice, the bounds <span class="math inline">\bar \lambda^e</span> and <span class="math inline">\bar W^e</span> should be chosen as sharp as possible. It is easy to see that conditionally to <span class="math inline">\{\bar E_\ell = e, \bar T_\ell = t, \bar K_\ell = l \}</span> the probability of accepting the event is, depending if there are interactions, <span class="math display">
    \mathbb{P}\big(\bar \Theta_\ell \le \lambda^e_t(I_l,Z_{T_k})| \mathcal{F}_{T_k}\big)
    = \frac{\lambda^e(t, I_l)}{\bar \lambda^e} \mathbf{1}_{e \in \mathcal{E}} +  \frac{\sum_{j=1}^{N_{T_k}} W^e(t, I_l, I_j)}{\bar W^e N_{T_k}} \mathbf{1}_{e \in \mathcal{E}_W}.
</span> The sharper the bounds <span class="math inline">\bar \lambda^e</span> and <span class="math inline">\bar W^e</span> are, the higher is the acceptance rate. For even sharper bounds, an alternative is to define bounds <span class="math inline">\bar \lambda^e(I_l)</span> and <span class="math inline">\bar W^e(I_l)</span> depending on the individuals’ characteristics. However, the algorithm is modified and the individual <span class="math inline">I_l</span> is not chosen uniformly in the population anymore. Due to the population size, this is way more costly than choosing uniform bounds, as explained in <a href="#rem-alternate-thinning" class="quarto-xref">Remark&nbsp;2</a>.</p>
</div>
</section>
</section>
<section id="sec-simulation-randomized" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="sec-simulation-randomized"><span class="header-section-number">3.3</span> Simulation algorithm with randomization</h2>
<p>Let <span class="math inline">e \in \cal E_W</span> be an event with interactions. In order to evaluate the individual intensity <span class="math inline">\lambda^e_t (I,Z_t) = \sum_{j=1}^{N_t} W^e(t, I,I_j)</span> one must compute <span class="math inline">W^e(t, I_l, I_j)</span> for all individuals in the population. This step can be computationally costly, especially for large populations. One way to avoid this summation is to use randomization (see also&nbsp;<span class="citation" data-cites="FouMel04">(<a href="#ref-FouMel04" role="doc-biblioref">Fournier and Méléard 2004</a>)</span> in a model without age). The randomization consists in replacing the summation by an evaluation of the interaction function <span class="math inline">W^e</span> using an individual <span class="math inline">J</span> drawn uniformly from the population.</p>
<p>More precisely, if <span class="math inline">J \sim \mathcal{U}(\{1, \dots, N_{T_k}\})</span> is independent of <span class="math inline">\bar \Theta_\ell</span>, we have <span id="eq-randomized-event"><span class="math display">
    \mathbb{P}\Big(\bar \Theta_\ell \le
    \sum_{j=1}^{N_{T_k}} W^e(t, I_l, I_j) | \mathcal{F}_{T_k} \Big)
    = \mathbb{P}\big(\bar \Theta_\ell
    \le N_{T_k} W^e(t, I_l, I_J) | \mathcal{F}_{T_k}\big).
\tag{15}</span></span> Equivalently, we can write this probability as <span class="math inline">\mathbb{P}\big(\tilde \Theta_\ell \le W^e(t, I_l, I_J) \big)</span> where <span class="math inline">\tilde \Theta_\ell  = \frac{\bar \Theta_\ell}{N_{T_k}}\sim \mathcal{U}([0, \bar W^e])</span> is independent of <span class="math inline">J \sim \mathcal{U}(\{1, \dots, N_{T_k}\})</span>.</p>
<div id="rem">
<p>The efficiency of the randomization procedure increases with the population homogeneity. If the function <span class="math inline">W^e</span> varies little according to the individuals in the population, the randomization approach is very efficient in practice, especially when the population is large.</p>
</div>
<p>We now present the main algorithm implemented in the <code>popsim</code> function of the <code>IBMPopSim</code> package in the case where events arrive with individual intensities, but also with interactions (using randomization) and Poisson intensities. In this general case, <span class="math inline">\bar \Lambda(n)</span> is defined by <a href="#eq-def-bar-Lambda" class="quarto-xref">Equation&nbsp;11</a>.</p>
<div id="prp-randomized" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 3</strong></span> &nbsp;</p>
</div>
<p>TODO</p>
</section>
</section>
<section id="sec-package" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Model creation and simulation with IBMPopSim</h1>
<p>The use of the <code>IBMPopSim</code> package is mainly done in two steps: a first model creation followed by the simulation of the population evolution. The creation of a model is itself based on two steps: the description of the population <span class="math inline">Z_t</span>, as introduced in <a href="#sec-population" class="quarto-xref">Section&nbsp;4.1</a>, and the description of the events types, along with their associated intensities, as detailed in <a href="#sec-events" class="quarto-xref">Section&nbsp;2.3</a> and <a href="#sec-event-intensity" class="quarto-xref">Section&nbsp;2.4</a>. A model is compiled by calling the <code>mk_model</code> function, which internally uses a template mechanism to generate automatically the source code describing the model, which is subsequently compiled using the <code>Rcpp</code> package to produce the object code.</p>
<p>After the compilation of the model, the simulations are launched by calling the <code>popsim</code> function. This function depends on the previously compiled model and simulates a random trajectory of the population evolution based on an initial population and on parameter values, which can change from a call to another.</p>
<p>In this section, we take a closer look at each component of a model in <code>IBMPopSim</code>. We also refer to the <a href="https://daphnegiorgi.github.io/IBMPopSim/">IBMPopSim website</a> and to the <code>vignettes</code> of the package for more details on the package and various examples of model creation.</p>
<section id="sec-population" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="sec-population"><span class="header-section-number">4.1</span> Population</h2>
<p>A population <span class="math inline">Z</span> is represented by an object of class <code>population</code> containing a data frame where each row corresponds to an individual <span class="math inline">I=(\tau^b, \tau^d, x)</span>, and which has at least two columns, <code>birth</code> and <code>death</code>, corresponding to the birth date <span class="math inline">\tau^b</span> and death/exit date <span class="math inline">\tau^d</span> (<span class="math inline">\tau^d</span> is set to <code>NA</code> for alive individuals). The data frame can contain more than two columns if individuals are described by additional characteristics <span class="math inline">x= (x_1,\dots x_n)</span>.</p>
<p>If entry events can occur in the population, the population shall contain a characteristic named <code>entry</code>. This can be done by setting the flag <code>entry=TRUE</code> in the <code>population</code> function, or by calling the <code>add_characteristic</code> function on an existing population. During the simulation, the date at which an individual enters the population is automatically recorded in the variable <code>I.entry</code>. If exit events can occur, the population shall contain a characteristic named <code>out</code>. This can be done by setting the flag <code>out=TRUE</code> in the <code>population</code> function, or by calling the <code>add_characteristic</code> function. When an individual <code>I</code> exits the population during the simulation, <code>I.out</code> is set to <code>TRUE</code> and its exit time is recorded as a “death” date.</p>
<p>In the example below, individuals are described by their birth and death dates, as well a Boolean characteristics called male, and the <code>entry</code> characteristic. For instance, the first individual is a female whose age at <span class="math inline">t_0=0</span> is <span class="math inline">107</span> and who was originally in the population.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>pop_init <span class="ot">&lt;-</span> <span class="fu">population</span>(EW_pop_14<span class="sc">$</span>sample, <span class="at">entry=</span><span class="cn">TRUE</span>)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(pop_init)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Classes 'population' and 'data.frame':  100000 obs. of  4 variables:
 $ birth: num  -107 -107 -105 -104 -104 ...
 $ death: num  NA NA NA NA NA NA NA NA NA NA ...
 $ male : logi  FALSE FALSE TRUE FALSE FALSE FALSE ...
 $ entry: logi  NA NA NA NA NA NA ...</code></pre>
</div>
</div>
<section id="individual" class="level3" data-number="4.1.1">
<h3 data-number="4.1.1" class="anchored" data-anchor-id="individual"><span class="header-section-number">4.1.1</span> Individual</h3>
<p>In the <code>C++</code> model which is automatically generated and compiled, an individual <code>I</code> is an object of an internal class containing some attributes (<code>birth_date</code>, <code>death_date</code> and the characteristics), and some methods including:</p>
<ul>
<li><code>I.age(t)</code>: a <code>const</code> method returning the age of an individual <code>I</code> at time <code>t</code>,</li>
<li><code>I.set_age(a, t)</code>: a method to set the age <code>a</code> at time <code>t</code> of an individual <code>I</code> (set <code>birth_date</code> at <code>t-a</code>),</li>
<li><code>I.is_dead(t)</code>: a <code>const</code> method returning <code>true</code> if the individual <code>I</code> is dead at time <code>t</code>.</li>
</ul>
<div id="rem-characteristics" class="proof remark">
<p><span class="proof-title"><em>Remark 5</em>. </span>A characteristic <span class="math inline">x_i</span> must be of atomic type: <code>logical</code>, <code>integer</code>, <code>double</code> or <code>character</code>. The function <code>get_characteristic</code> allows to easily get characteristics names and their types from a population data frame. We draw the attention to the fact that some names for characteristics are forbidden, or reserved to specific cases : this is the case for <code>birth</code>, <code>death</code>, <code>entry</code>, <code>out</code>, <code>id</code>.</p>
</div>
</section>
</section>
<section id="sec-package-events" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="sec-package-events"><span class="header-section-number">4.2</span> Events</h2>
<p>The most important step of the model creation is the events creation. The call to the function creating an event is of form</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mk_event_CLASS</span>(<span class="at">type=</span><span class="st">"TYPE"</span>, <span class="at">name=</span><span class="st">"NAME"</span>, ...)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>where <code>CLASS</code> is replaced by the class of the event intensity, described in <a href="#sec-event-intensity" class="quarto-xref">Section&nbsp;2.4</a> , and <code>type</code> corresponds to the event type, described in Section&nbsp;<a href="#sec-events" class="quarto-xref">Section&nbsp;2.3</a>. <a href="#tbl-intensity-classes" class="quarto-xref">Table&nbsp;2 (a)</a> and <a href="#tbl-event-types" class="quarto-xref">Table&nbsp;2 (b)</a> summarize the different possible choices for intensity classes and types of event. The optional argument <code>name</code> gives a name to the event. If not specified, the name of the event is its type, for instance <code>death</code>. However, a name must be specified if the model is composed of several events with the same type (for instance when there are multiple death events corresponding to different causes of death). The other arguments depend on the intensity class and on the event type.</p>
<div id="tbl-panel" class="quarto-layout-panel anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-panel-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;2: Main caption
</figcaption>
<div aria-describedby="tbl-panel-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-layout-row">
<div class="quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="tbl-panel" style="flex-basis: 50.0%;justify-content: center;">
<div id="tbl-intensity-classes" class="quarto-float anchored">
<figure class="quarto-float quarto-subfloat-tbl figure">
<figcaption class="quarto-float-caption-top quarto-subfloat-caption quarto-subfloat-tbl" id="tbl-intensity-classes-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(a) Intensity Classes
</figcaption>
<div aria-describedby="tbl-intensity-classes-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table">
<thead>
<tr class="header">
<th style="text-align: left;">Intensity class</th>
<th style="text-align: left;">Set</th>
<th style="text-align: left;"><code>CLASS</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Individual</td>
<td style="text-align: left;"><span class="math inline">\mathcal{E}</span></td>
<td style="text-align: left;"><code>individual</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">Interaction</td>
<td style="text-align: left;"><span class="math inline">\mathcal{E}_W</span></td>
<td style="text-align: left;"><code>interaction</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Poisson</td>
<td style="text-align: left;"><span class="math inline">\mathcal{P}</span></td>
<td style="text-align: left;"><code>poisson</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">Inhomogeneous Poisson</td>
<td style="text-align: left;"><span class="math inline">\mathcal{P}</span></td>
<td style="text-align: left;"><code>inhomogeneous_poisson</code></td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
</div>
<div class="quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="tbl-panel" style="flex-basis: 50.0%;justify-content: center;">
<div id="tbl-event-types" class="quarto-float anchored">
<figure class="quarto-float quarto-subfloat-tbl figure">
<figcaption class="quarto-float-caption-top quarto-subfloat-caption quarto-subfloat-tbl" id="tbl-event-types-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(b) Event Types
</figcaption>
<div aria-describedby="tbl-event-types-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table">
<thead>
<tr class="header">
<th style="text-align: left;">Event type</th>
<th style="text-align: left;"><code>TYPE</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Birth</td>
<td style="text-align: left;"><code>birth</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">Death</td>
<td style="text-align: left;"><code>death</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Entry</td>
<td style="text-align: left;"><code>entry</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">Exit</td>
<td style="text-align: left;"><code>exit</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Swap</td>
<td style="text-align: left;"><code>swap</code></td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
</div>
</div>
</div>
</figure>
</div>
<p>The intensity function and the kernel of an event are defined through arguments of the function <code>mk_event_CLASS</code>. These arguments are strings composed of few lines of code. Since the model is compiled using <code>Rcpp</code>, the code should be written in <code>C++</code>. However, thanks to the functions/variables of the package, even the non-experienced <code>C++</code> user can define a model quite easily. To facilitate the implementation, the user can also define a list of <strong>model parameters</strong>, which can be used in the event and intensity definitions. These parameters are stored in a named list and can be of various types: atomic type, numeric vector or matrix, predefined function of one variable (<code>stepfun</code>, <code>linfun</code>, <code>gompertz</code>, <code>weibull</code>, <code>piecewise_x</code>), piecewise functions of two variables (<code>piecewise_xy</code>). We refer to the <code>vignette(IBMPopSim_cpp)</code> for more details on parameters types and basic <code>C++</code> tools. Another advantage of the model parameters is that their value can be modified from a simulation to another without changing the model.</p>
</section>
</section>
<section id="sec-insurance-portfolio" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Insurance portfolio</h1>
<p>TODO</p>
</section>
<section id="sec-example-interaction" class="level1" data-number="6">
<h1 data-number="6"><span class="header-section-number">6</span> Population with genetically variable traits</h1>
<p>TODO</p>
</section>

<section id="references" class="level1 unnumbered">
<h1 class="unnumbered">References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-BanMel15" class="csl-entry" role="listitem">
Bansaye, Vincent, and Sylvie Méléard. 2015. <em>Stochastic Models for Structured Populations</em>. Springer International Publishing.
</div>
<div id="ref-barrieu2012understanding" class="csl-entry" role="listitem">
Barrieu, Pauline, Harry Bensusan, Nicole El Karoui, Caroline Hillairet, Stéphane Loisel, Claudia Ravanelli, and Yahia Salhi. 2012. <span>“Understanding, Modelling and Managing Longevity Risk: Key Issues and Main Challenges.”</span> <em>Scandinavian Actuarial Journal</em> 2012 (3): 203–31.
</div>
<div id="ref-Ben10" class="csl-entry" role="listitem">
Bensusan, Harry. 2010. <span>“<span class="nocase">Interest rate and longevity risk: dynamic model and applications to derivative products and life insurance</span>.”</span> Theses, <span>Ecole Polytechnique X</span>.
</div>
<div id="ref-billiard2016effect" class="csl-entry" role="listitem">
Billiard, Sylvain, Pierre Collet, Régis Ferrière, Sylvie Méléard, and Viet Chi Tran. 2016. <span>“The Effect of Competition and Horizontal Trait Inheritance on Invasion, Fixation, and Polymorphism.”</span> <em>Journal of Theoretical Biology</em> 411: 48–58.
</div>
<div id="ref-Bou16" class="csl-entry" role="listitem">
Boumezoued, Alexandre. 2016. <span>“<span class="nocase">Micro-macro analysis of heterogenous age-structured populations dynamics.Application to self-exciting processes and demography.</span>”</span> Theses, <span>Universit<span>é</span> Pierre et Marie Curie</span>.
</div>
<div id="ref-bremaud1981point" class="csl-entry" role="listitem">
Brémaud, Pierre. 1981. <em>Point Processes and Queues: Martingale Dynamics</em>. Vol. 66. Springer.
</div>
<div id="ref-calvez2020horizontal" class="csl-entry" role="listitem">
Calvez, Vincent, Susely Figueroa Iglesias, Hélène Hivert, Sylvie Méléard, Anna Melnykova, and Samuel Nordmann. 2020. <span>“Horizontal Gene Transfer: Numerical Comparison Between Stochastic and Deterministic Approaches.”</span> <em>ESAIM: Proceedings and Surveys</em> 67: 135–60.
</div>
<div id="ref-champagnat2006unifying" class="csl-entry" role="listitem">
Champagnat, Nicolas, Régis Ferrière, and Sylvie Méléard. 2006. <span>“Unifying Evolutionary Dynamics: From Individual Stochastic Processes to Macroscopic Models.”</span> <em>Theoretical Population Biology</em> 69 (3): 297–321.
</div>
<div id="ref-Cin11" class="csl-entry" role="listitem">
Çinlar, Erhan. 2011. <em><span class="nocase">Probability and Stochastics</span></em>. Springer New York.
</div>
<div id="ref-collet2013rigorous" class="csl-entry" role="listitem">
Collet, Pierre, Sylvie Méléard, and Johan AJ Metz. 2013. <span>“A Rigorous Model Study of the Adaptive Dynamics of Mendelian Diploids.”</span> <em>Journal of Mathematical Biology</em> 67: 569–607.
</div>
<div id="ref-costa2016stochastic" class="csl-entry" role="listitem">
Costa, Manon, Céline Hauzy, Nicolas Loeuille, and Sylvie Méléard. 2016. <span>“Stochastic Eco-Evolutionary Model of a Prey-Predator Community.”</span> <em>Journal of Mathematical Biology</em> 72: 573–622.
</div>
<div id="ref-Dev86" class="csl-entry" role="listitem">
Devroye, Luc. 1986. <em>Nonuniform Random Variate Generation</em>. Springer-Verlag, New York.
</div>
<div id="ref-JSSv040i08" class="csl-entry" role="listitem">
Eddelbuettel, Dirk, and Romain Francois. 2011. <span>“Rcpp: Seamless r and c++ Integration.”</span> <em>Journal of Statistical Software</em> 40 (8): 1–18. <a href="https://doi.org/10.18637/jss.v040.i08">https://doi.org/10.18637/jss.v040.i08</a>.
</div>
<div id="ref-karoui2021simulating" class="csl-entry" role="listitem">
El Karoui, Nicole, Kaouther Hadji, and Sarah Kaakai. 2021. <span>“Simulating Long-Term Impacts of Mortality Shocks: Learning from the Cholera Pandemic.”</span> <em>arXiv Preprint arXiv:2111.08338</em>.
</div>
<div id="ref-FerTra09" class="csl-entry" role="listitem">
Ferrière, Régis, and Viet Chi Tran. 2009. <span>“Stochastic and Deterministic Models for Age-Structured Populations with Genetically Variable Traits.”</span> In, 27:289–310. ESAIM Proc. EDP Sci., Les Ulis.
</div>
<div id="ref-FouMel04" class="csl-entry" role="listitem">
Fournier, Nicolas, and Sylvie Méléard. 2004. <span>“A Microscopic Probabilistic Description of a Locally Regulated Population and Macroscopic Approximations.”</span> <em>Ann. Appl. Probab.</em> 14 (4): 1880–1919.
</div>
<div id="ref-Rdemography" class="csl-entry" role="listitem">
Hyndman, Rob, Heather Booth Booth, Leonie Tickle Tickle, John Maindonald, Simon Wood Wood, and R Core Team. 2023. <em><span class="nocase">demography</span>: Forecasting Mortality, Fertility, Migration and Population Data</em>. <a href="https://cran.r-project.org/package=demography">https://cran.r-project.org/package=demography</a>.
</div>
<div id="ref-KaaElK20" class="csl-entry" role="listitem">
Kaakai, Sarah, and Nicole El Karoui. 2023. <span>“Birth Death Swap Population in Random Environment and Aggregation with Two Timescales.”</span> <em>Stochastic Processes and Their Applications</em> 162: 218–48. https://doi.org/<a href="https://doi.org/10.1016/j.spa.2023.04.017">https://doi.org/10.1016/j.spa.2023.04.017</a>.
</div>
<div id="ref-Kal17" class="csl-entry" role="listitem">
Kallenberg, Olav. 2017. <em>Random Measures, Theory and Applications</em>. Vol. 77. Probability Theory and Stochastic Modelling. Springer, Cham.
</div>
<div id="ref-lavallee2019stochastic" class="csl-entry" role="listitem">
Lavallée, François, Charline Smadi, Isabelle Alvarez, Björn Reineking, François-Marie Martin, Fanny Dommanget, and Sophie Martin. 2019. <span>“A Stochastic Individual-Based Model for the Growth of a Stand of Japanese Knotweed Including Mowing as a Management Technique.”</span> <em>Ecological Modelling</em> 413: 108828.
</div>
<div id="ref-LewShe79" class="csl-entry" role="listitem">
Lewis, Peter, and Gerald Shedler. 1979. <span>“Simulation of Nonhomogeneous Poisson Processes by Thinning.”</span> <em>Naval Research Logistics Quarterly</em> 26 (3): 403–13.
</div>
<div id="ref-meleard2019birth" class="csl-entry" role="listitem">
Méléard, Sylvie, Michael Rera, and Tristan Roget. 2019. <span>“A Birth–Death Model of Ageing: From Individual-Based Dynamics to Evolutive Differential Inclusions.”</span> <em>Journal of Mathematical Biology</em> 79: 901–39.
</div>
<div id="ref-roget2022positive" class="csl-entry" role="listitem">
Roget, Tristan, Pierre Jolivet, Sylvie Méléard, and Michael Rera. 2022. <span>“Positive Selection of Senescence Through Increased Evolvability: Ageing Is Not a by-Product of Evolution.”</span> <em>bioRxiv</em>, 2022–03.
</div>
<div id="ref-tran_2008" class="csl-entry" role="listitem">
Tran, Viet Chi. 2008. <span>“Large Population Limit and Time Behaviour of a Stochastic Particle Model Describing an Age-Structured Population.”</span> <em>ESAIM: Probability and Statistics</em> 12: 345–86. <a href="https://doi.org/10.1051/ps:2007052">https://doi.org/10.1051/ps:2007052</a>.
</div>
<div id="ref-Rstmomo" class="csl-entry" role="listitem">
Villegas, Andres, Pietro Millossovich, and Vladimir Kaishev Hyndman. 2018. <em><span>StMoMo</span>: Stochastic Mortality Modelling</em>. <a href="https://cran.r-project.org/package=StMoMo">https://cran.r-project.org/package=StMoMo</a>.
</div>
<div id="ref-Zin14" class="csl-entry" role="listitem">
Zinn, Sabine. 2014. <span>“<span class="nocase">The MicSim package of R: an entry-level toolkit for continuous-time microsimulation</span>.”</span> <em>International Journal of Microsimulation</em> 7 (3): 3–32.
</div>
<div id="ref-zinn2009mic" class="csl-entry" role="listitem">
Zinn, Sabine, Jutta Gampe, Jan Himmelspach, and Adelinde M Uhrmacher. 2009. <span>“MIC-CORE: A Tool for Microsimulation.”</span> In <em>Proceedings of the 2009 Winter Simulation Conference (WSC)</em>, 992–1002. IEEE.
</div>
</div>
</section>


<div id="quarto-appendix" class="default"><section id="appendix" class="level1 appendix unnumbered"><h2 class="anchored quarto-appendix-heading">Appendix</h2><div class="quarto-appendix-contents">

<section id="sec-recall-poisson" class="level2" data-number="6.1">
<h2 data-number="6.1" class="anchored" data-anchor-id="sec-recall-poisson"><span class="header-section-number">6.1</span> Recall on Poisson random measures</h2>
<p>We recall below some useful properties of Poisson random measures, mainly following Chapter&nbsp;6 of&nbsp;<span class="citation" data-cites="Cin11">(<a href="#ref-Cin11" role="doc-biblioref">Çinlar 2011</a>)</span>. We also refer to&nbsp;<span class="citation" data-cites="Kal17">(<a href="#ref-Kal17" role="doc-biblioref">Kallenberg 2017</a>)</span> for a more comprehensive presentation of random counting measures.</p>
<div id="def-poisson-random-measure" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 1 (Poisson Random Measures)</strong></span> Let <span class="math inline">\mu</span> be a <span class="math inline">\sigma</span>-finite diffuse measure on a Borel subspace <span class="math inline">(E,\mathcal{E})</span> of <span class="math inline">({\mathbb{R}}^d, \mathcal{B}({\mathbb{R}}^d))</span>. A random counting measure <span class="math inline">Q= \sum_{k\geq 1} \delta_{X_k}</span> is a Poisson (counting) random measure of <em>mean measure</em> <span class="math inline">\mu</span> if</p>
<ol type="1">
<li><span class="math inline">\forall A \in \mathcal{E}</span>, <span class="math inline">Q(A)</span> is a Poisson random variable with <span class="math inline">{\mathbb{E}}[Q(A)]= \mu(A)</span>.</li>
<li>For all disjoints subsets <span class="math inline">A_1, \dots, A_n \in \mathcal{E}</span>, <span class="math inline">Q(A_1), \dots, Q(A_n)</span> are independent Poisson random variables.</li>
</ol>
</div>
<p>Let us briefly recall here some simple but useful operations on Poisson measures. In the following, <span class="math inline">Q</span> is a Poisson measure of mean measure <span class="math inline">\mu</span>, unless stated otherwise.</p>
<div id="prp-restriction-poisson-measure" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 4 (Restricted Poisson measure)</strong></span> If <span class="math inline">B \in \mathcal{E}</span>, then, the restriction of <span class="math inline">Q</span> to <span class="math inline">B</span> defined by <span class="math display">
    Q^B = \boldsymbol{1}_B Q = \sum_{k \ge 1} \mathbf{1}_{B}(X_k) \delta_{X_k}
</span> is also a Poisson random measure, of mean measure <span class="math inline">\mu^B = \mu(\cdot \cap B)</span>.</p>
</div>
<div id="prp-proj-poisson-measure" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 5 (Projection of Poisson measure)</strong></span> If <span class="math inline">E = F_1 \times F_2</span> is a product space, then the projection <span class="math display">
    Q_1(\mathrm{d}x) = \int_{F_2} Q(\mathrm{d}x , \mathrm{d}y)
</span> is a Poisson random measure of mean measure <span class="math inline">\mu_1 (\mathrm{d}x ) = \int_{F_2} \mu(\mathrm{d}x, \mathrm{d}y)</span>.</p>
</div>
<section id="link-with-poisson-processes" class="level3" data-number="6.1.1">
<h3 data-number="6.1.1" class="anchored" data-anchor-id="link-with-poisson-processes"><span class="header-section-number">6.1.1</span> Link with Poisson processes</h3>
<p>Let <span class="math inline">Q= \sum_{k\geq 1} \delta_{T_k}</span> a Poisson random measure on <span class="math inline">E={\mathbb{R}}^+</span> with mean measure <span class="math inline">\mu(\mathrm{d}t) = \Lambda (t) \mathrm{d}t</span> absolutely continuous with respect to the Lebesgue measure, <span class="math inline">\mu(A) = \int_A \Lambda(t) \mathrm{d}t</span>. The counting process <span class="math inline">(N_t)_{t \ge 0}</span> defined by <span id="eq-inhomogeneous-pp"><span class="math display">
    N_t = Q([0,t]) = \sum_{k \geq 1} \boldsymbol{1}_{\{T_k \leq t\}}, \quad \forall \; t\geq 0,
\tag{16}</span></span> is an inhomogeneous Poisson process with intensity function (or rate) <span class="math inline">t \mapsto \Lambda(t)</span>. In particular, when <span class="math inline">\Lambda(t) \equiv c</span> is a constant, <span class="math inline">N</span> is a homogeneous Poisson process with rate <span class="math inline">c</span>. Assuming that the atoms are ordered <span class="math inline">T_1&lt; T_2&lt; \dots</span>, we recall that the sequence <span class="math inline">(T_{k+1}-T_k)_{k\geq 1}</span> is a sequence of <em>i.i.d.</em> exponential variables of parameter <span class="math inline">c</span>.</p>
</section>
<section id="marked-poisson-measures-on-e-mathbbr-times-f" class="level3" data-number="6.1.2">
<h3 data-number="6.1.2" class="anchored" data-anchor-id="marked-poisson-measures-on-e-mathbbr-times-f"><span class="header-section-number">6.1.2</span> Marked Poisson measures on <span class="math inline">E = {\mathbb{R}}^+ \times F</span></h3>
<p>We are interested in the particular case when <span class="math inline">E</span> is the product space <span class="math inline">{\mathbb{R}}^+ \times F</span>, with <span class="math inline">(F,\mathcal{F})</span> a Borel subspace of <span class="math inline">{\mathbb{R}}^d</span>. Then, a random counting measure is defined by a random set <span class="math inline">S =\{ (T_k, \Theta_k ), k \geq 1\}</span>. The random variables <span class="math inline">T_k\geq 0</span> can be considered as time variables, and constitute the jump times of the random measure, while the variables <span class="math inline">\Theta_k \in F</span> represent space variables.</p>
<p>We recall in this special case the Theorem&nbsp;VI.3.2 in&nbsp;<span class="citation" data-cites="Cin11">(<a href="#ref-Cin11" role="doc-biblioref">Çinlar 2011</a>)</span>.</p>
<div id="prp-marked-poisson" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 6 (Marked Poisson measure)</strong></span> Let <span class="math inline">m</span> be a <span class="math inline">\sigma</span>–finite diffuse measure on <span class="math inline">{\mathbb{R}}^+</span>, and <span class="math inline">K</span> a transition probability kernel from <span class="math inline">({\mathbb{R}}^+,\mathcal{B}({\mathbb{R}}^+))</span> into <span class="math inline">(F, \mathcal{F})</span>. Assume that the collection <span class="math inline">(T_k)_{k \ge 1}</span> forms a Poisson process <span class="math inline">(N_t) =(\sum_{k\geq 1} \mathsf{1}_{\{T_k \leq t\}})</span> with mean <span class="math inline">m(\mathrm{d}t) =\Lambda(t) \mathrm{d}t</span>, and that given <span class="math inline">(T_k)_{k \ge 1}</span>, the variables <span class="math inline">\Theta_k</span> are conditionally independent and have the respective distributions <span class="math inline">K(T_k, \cdot)</span>.</p>
<ol type="1">
<li><p>Then, <span class="math inline">\{ (T_k, \Theta_k) ;\; k \ge 1\}</span> forms a Poisson random measure <span class="math inline">Q = \sum_{k\ge 1} \delta_{(T_k, \Theta_k)}</span> on <span class="math inline">({\mathbb{R}}^+ \times F, \mathcal{B}({\mathbb{R}}^+) \otimes \mathcal{F})</span>, called a <em>Marked point process</em> , with mean <span class="math inline">\mu</span> defined by <span class="math display">
\mu(\mathrm{d}t, \mathrm{d}y) = \Lambda(t) \mathrm{d}t K(t, \mathrm{d}y).
</span></p></li>
<li><p>Reciprocally let <span class="math inline">Q</span> be a Poisson random measure of mean measure <span class="math inline">\mu(\mathrm{d}t, \mathrm{d}y)</span>, admitting the following disintegration with respect to the first coordinate: <span class="math inline">\mu(\mathrm{d}t , \mathrm{d}y) =\tilde  \Lambda(t) \mathrm{d}t \nu(t, \mathrm{d}y)</span>, with <span class="math inline">\nu(t, F)&lt;\infty</span>. Let <span class="math inline">K(t, \mathrm{d}y) = \dfrac{\nu(t,\mathrm{d}y) }{\nu(t, F) }</span> and <span class="math inline">\Lambda(t) = \nu(t, F)\tilde  \Lambda(t)</span>. Then, <span class="math inline">Q = \sum_{k\ge 1} \delta_{(T_k, \Theta_k)}</span> is a marked Poisson measure with <span class="math inline">(T_k,\Theta_k)_{k\in {\mathbb{N}}^*}</span> defined as above. In particular, the projection <span class="math inline">N= (N_t)_{t\geq0}</span> of the Poisson measure on the first coordinate, <span class="math display">
N_t = Q([0,t] \times F) = \sum_{k\geq 1} \boldsymbol{1}_{[0,t] \times F} (T_k, \Theta_k)  = \sum_{k\geq 1} \boldsymbol{1}_{\{T_k \leq t\}}, \quad \forall \; t \geq 0,
</span> is an inhomogeneous Poisson process of rate <span class="math inline">\Lambda(t)= \nu(t, F)\tilde  \Lambda(t)</span>.</p></li>
</ol>
</div>
<div id="rem">
<p>When the transition probability kernel <span class="math inline">K</span> does not depend on the time: <span class="math inline">K(t, A) = \nu(A)</span> for some probability measure <span class="math inline">\nu</span>, then the marks <span class="math inline">(\Theta_k)_{k \ge 1}</span> form an <em>i.i.d.</em> sequence with distribution <span class="math inline">\nu</span>, independent of <span class="math inline">(T_k)_{k \ge 1}</span>.</p>
</div>
<p>The preceding proposition thus yields a straight forward iterative simulation procedure for a Marked Poisson process on <span class="math inline">[0,T]\times F</span> with mean measure <span class="math inline">\mu(\mathrm{d}t, \mathrm{d}y) = c \mathrm{d}t K(t, \mathrm{d}y)</span> and <span class="math inline">c&gt;0</span>. The procedure is described in <span class="citation" data-cites="alg-marked-poisson">(<a href="#ref-alg-marked-poisson" role="doc-biblioref"><strong>alg-marked-poisson?</strong></a>)</span>.</p>
</section>
</section>
<section id="sec-pathwise-representation" class="level2" data-number="6.2">
<h2 data-number="6.2" class="anchored" data-anchor-id="sec-pathwise-representation"><span class="header-section-number">6.2</span> Pathwise representation of IBMs</h2>
<section id="notation-reminder" class="level3" data-number="6.2.1">
<h3 data-number="6.2.1" class="anchored" data-anchor-id="notation-reminder"><span class="header-section-number">6.2.1</span> Notation reminder</h3>
<p>The population’s evolution is described by the measure valued process <span class="math inline">(Z_t)_{t\geq 0}</span>. Several types of events <span class="math inline">e</span> can occur to individuals denoted by <span class="math inline">I</span>. In an event of type <span class="math inline">e</span> occur to the individual <span class="math inline">I</span> at time <span class="math inline">t</span>, then the population state <span class="math inline">Z_{t^-}</span> is modified by <span class="math inline">\phi^e(t,I)</span>. If <span class="math inline">e\in \mathcal{E} \cup \mathcal{E}_W</span>, then events of type <span class="math inline">e</span> occur with an intensity <span class="math inline">\sum_{k=1}^{N_t} \lambda_t^e(I,Z_t)</span>, with <span class="math inline">\lambda_t^e(I,Z_t)</span> defined by <a href="#eq-individual-intensity" class="quarto-xref">Equation&nbsp;7</a>. If <span class="math inline">e \in \mathcal{P}</span>, then events of type <span class="math inline">e</span> occur in the population at a Poisson intensity of <span class="math inline">(\mu^e_t)</span>.</p>
</section>
<section id="sec-prf-thm-eq-Z" class="level3" data-number="6.2.2">
<h3 data-number="6.2.2" class="anchored" data-anchor-id="sec-prf-thm-eq-Z"><span class="header-section-number">6.2.2</span> Proof of <a href="#thm-eq-Z" class="quarto-xref">Theorem&nbsp;1</a></h3>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>For ease of notation, we prove the case when <span class="math inline">\mathcal{P} =\emptyset</span> (there are no events with Poisson intensity).</p>
<ul>
<li>Step 1. The existence of a solution to <a href="#eq-sde-eq-Z" class="quarto-xref">Equation&nbsp;12</a> is obtained by induction. Let <span class="math inline">Z^1</span> be the unique solution the thinning equation: <span class="math display">
  Z_t^1 = Z_0 + \int_0^t \int_{ \mathcal{J}\times \mathbb R^+ }\phi^e (s , I_k)  \mathbf{1}_{\{k \leq N_{0}\} }\mathbf{1}_{\{\theta \leq \lambda_s^e(I_k, Z_{0})\}} Q (\mathrm{d}s,\mathrm{d}k , \mathrm{d}e, \mathrm{d}\theta ), \quad \forall  0 \leq t \leq T.
</span> Let <span class="math inline">T_1</span> be the first jump time of <span class="math inline">Z^1</span>. Since <span class="math inline">Z_{s^-}^1 = Z_{0}</span> and <span class="math inline">N_{s^-}=N_{0}</span> on <span class="math inline">[0, T_1]</span>, <span class="math inline">Z^1</span> is solution of <a href="#eq-sde-eq-Z" class="quarto-xref">Equation&nbsp;12</a> on <span class="math inline">[0,T_1]</span>.</li>
</ul>
<p>Let us now assume that <a href="#eq-sde-eq-Z" class="quarto-xref">Equation&nbsp;12</a> admits a solution <span class="math inline">Z^n</span> on <span class="math inline">[0,T_n]</span>, with <span class="math inline">T_n</span> the <span class="math inline">n</span>–th event time in the population. Let <span class="math inline">Z^{n+1}</span> be the unique solution of the thinning equation: <span class="math display">
    Z^{n+1}_t  =  Z_{t\wedge T_n}^n + \int_{t\wedge T_n}^{t} \int_{ \mathcal{J}\times \mathbb R^+ }\phi^e (s , I_k)  \mathbf{1}_{\{\theta \leq \lambda_s^e(I_k, Z_{T_n}^n)\}} \mathbf{1}_{\{k \leq N_{T_n}^n \} }Q (\mathrm{d}s ,\mathrm{d}k , \mathrm{d}e, \mathrm{d}\theta ).
</span> First, observe that <span class="math inline">Z^{n+1}</span> coincides with <span class="math inline">Z^n</span> on <span class="math inline">[0,T_n]</span>. Let <span class="math inline">T_{n+1}</span> be the <span class="math inline">(n+1)</span>–th jump of <span class="math inline">Z^{n+1}</span>. Furthermore, <span class="math inline">Z_{s^-}^{n+1} = Z_{T_n}^n</span> and <span class="math inline">N_{s^-}^{n+1}=N_{T_n}^{n}</span> on <span class="math inline">[T_n, T_{n+1}]</span> (nothing happens between two successive event times), <span class="math inline">Z^{n+1}</span> verifies for all <span class="math inline">t\leq T_{n+1}</span>: <span class="math display">
\begin{aligned}
    Z^{n+1}_t  =  Z_{t\wedge T_n}^n +\int_{t\wedge T_n}^{t} \int_{ \mathcal{J}\times \mathbb R^+ }\phi^e (s , I_k)  \mathbf{1}_{\{\theta \leq \lambda_s^e(I_k, Z_{s^-}^{n+1} )\}} \mathbf{1}_{\{k \leq N_{s^-}^{n+1} \} }Q (\mathrm{d}s ,\mathrm{d}k , \mathrm{d}e, \mathrm{d}\theta ).
\end{aligned}
</span> Since, <span class="math inline">Z^n</span> is a solution of <a href="#eq-sde-eq-Z" class="quarto-xref">Equation&nbsp;12</a> on <span class="math inline">[0,T_n]</span> coinciding with <span class="math inline">Z^{n+1}</span>, this achieves to prove that <span class="math inline">Z^{n+1}</span> is solution of <a href="#eq-sde-eq-Z" class="quarto-xref">Equation&nbsp;12</a> on <span class="math inline">[0,T_{n+1}]</span>. Finally, let <span class="math inline">Z =\lim_{n\to \infty } Z^n</span>. For all <span class="math inline">n\geq 1</span>, <span class="math inline">T_n</span> is the <span class="math inline">n</span>–th event time of <span class="math inline">Z</span>, and <span class="math inline">Z</span> is solution of <a href="#eq-sde-eq-Z" class="quarto-xref">Equation&nbsp;12</a> on all time intervals <span class="math inline">[0,T_n\wedge T]</span> by construction.</p>
<p>By <a href="#lem-non-explosion" class="quarto-xref">Lemma&nbsp;1</a> <span class="math inline">T_n \underset{n\to \infty}{\longrightarrow} \infty</span>. Thus, by letting <span class="math inline">n\to \infty</span> we can conclude that <span class="math inline">Z</span> is a solution of <a href="#eq-sde-eq-Z" class="quarto-xref">Equation&nbsp;12</a> on <span class="math inline">[0,T]</span>.</p>
<ul>
<li>Step 2. Let <span class="math inline">\tilde Z</span> be a solution of <a href="#eq-sde-eq-Z" class="quarto-xref">Equation&nbsp;12</a>. Using the same arguments than in Step 1, it is straight forward to show that <span class="math inline">\tilde Z</span> coincides with <span class="math inline">Z^n</span> on <span class="math inline">[0,T_n]</span>, for all <span class="math inline">n \geq 1</span>. Thus, <span class="math inline">\tilde{Z} = Z</span>, with achieves to prove uniqueness.</li>
</ul>
</div>
</section>
</section>
</div></section><section id="session-information" class="level1 appendix unnumbered"><h2 class="anchored quarto-appendix-heading">Session information</h2><div class="quarto-appendix-contents">

<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sessionInfo</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>R version 4.3.3 (2024-02-29)
Platform: aarch64-apple-darwin20 (64-bit)
Running under: macOS Sonoma 14.4

Matrix products: default
BLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib 
LAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0

locale:
[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8

time zone: Europe/Paris
tzcode source: internal

attached base packages:
[1] stats     graphics  grDevices datasets  utils     methods   base     

other attached packages:
[1] IBMPopSim_1.0.0

loaded via a namespace (and not attached):
 [1] gtable_0.3.4             jsonlite_1.8.8           dplyr_1.1.4             
 [4] compiler_4.3.3           renv_1.0.5               tidyselect_1.2.1        
 [7] Rcpp_1.0.12              scales_1.3.0             yaml_2.3.8              
[10] fastmap_1.1.1            ggplot2_3.5.0            readr_2.1.5             
[13] R6_2.5.1                 generics_0.1.3           knitr_1.45              
[16] htmlwidgets_1.6.4        backports_1.4.1          checkmate_2.3.1         
[19] tibble_3.2.1             munsell_0.5.0            pillar_1.9.0            
[22] tzdb_0.4.0               rlang_1.1.3              utf8_1.2.4              
[25] xfun_0.42                cli_3.6.2                magrittr_2.0.3          
[28] digest_0.6.35            grid_4.3.3               hms_1.1.3               
[31] lifecycle_1.0.4          RcppArmadillo_0.12.8.1.0 vctrs_0.6.5             
[34] evaluate_0.23            glue_1.7.0               fansi_1.0.6             
[37] colorspace_2.1-0         rmarkdown_2.26           tools_4.3.3             
[40] pkgconfig_2.0.3          htmltools_0.5.7         </code></pre>
</div>
</div>
<!-- -->

</div></section><section class="quarto-appendix-contents" id="quarto-reuse"><h2 class="anchored quarto-appendix-heading">Reuse</h2><div class="quarto-appendix-contents"><div><a rel="license" href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a></div></div></section><section class="quarto-appendix-contents" id="quarto-citation"><h2 class="anchored quarto-appendix-heading">Citation</h2><div><div class="quarto-appendix-secondary-label">BibTeX citation:</div><pre class="sourceCode code-with-copy quarto-appendix-bibtex"><code class="sourceCode bibtex">@article{giorgi2024,
  author = {Giorgi, Daphné and Lemaire, Vincent and Kaakai, Sarah},
  publisher = {Société Française de Statistique},
  title = {Efficient Simulation of Individual-Based Population Models},
  journal = {Computo},
  date = {2024-03-18},
  url = {https://computo.sfds.asso.fr/template-computo-quarto},
  doi = {xxxx},
  issn = {2824-7795},
  langid = {en},
  abstract = {The `R` Package `IBMPopSim` aims to simulate the random
    evolution of heterogeneous populations using stochastic
    Individual-Based Models (IBMs). The package enables users to
    simulate population evolution, in which individuals are
    characterized by their age and some characteristics, and the
    population is modified by different types of events, including
    births/arrivals, death/exit events, or changes of characteristics.
    The frequency at which an event can occur to an individual can
    depend on their age and characteristics, but also on the
    characteristics of other individuals (interactions). Such models
    have a wide range of applications in fields including actuarial
    science, biology, ecology or epidemiology. `IBMPopSim` overcomes the
    limitations of time-consuming IBMs simulations by implementing new
    efficient algorithms based on thinning methods, which are compiled
    using the `Rcpp` package while providing a user-friendly interface.}
}
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre><div class="quarto-appendix-secondary-label">For attribution, please cite this work as:</div><div id="ref-giorgi2024" class="csl-entry quarto-appendix-citeas" role="listitem">
Giorgi, Daphné, Vincent Lemaire, and Sarah Kaakai. 2024.
<span>“Efficient Simulation of Individual-Based Population
Models.”</span> <em>Computo</em>, March. <a href="https://doi.org/xxxx">https://doi.org/xxxx</a>.
</div></div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
          // target, if specified
          link.setAttribute("target", "_blank");
          if (link.getAttribute("rel") === null) {
            link.setAttribute("rel", "noopener");
          }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb11" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> "Efficient simulation of individual-based population models"</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="an">subtitle:</span><span class="co"> "The `R` package `IBMPopSim`"</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="an">author:</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="co">  - name: Daphné Giorgi </span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="co">    email: daphne.giorgi@sorbonne-universite.fr</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="co">    url: https://perso.lpsm.paris/~giorgi/</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="co">    affiliations:</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="co">      - name: Sorbonne Université, CNRS</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="co">        department: Laboratoire de Probabilités, Statistique et Modélisation</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="co">        url: https://www.lpsm.paris/</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a><span class="co">  - name: Vincent Lemaire </span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a><span class="co">    corresponding: true</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a><span class="co">    email: vincent.lemaire@sorbonne-universite.fr</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a><span class="co">    url: https://perso.lpsm.paris/~vlemaire/</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a><span class="co">    orcid: 0000-0002-0433-7722</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a><span class="co">    affiliations:</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a><span class="co">      - name: Sorbonne Université, CNRS</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a><span class="co">        department: Laboratoire de Probabilités, Statistique et Modélisation</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a><span class="co">        url: https://www.lpsm.paris/</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a><span class="co">  - name: Sarah Kaakai</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a><span class="co">    corresponding: true</span></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a><span class="co">    email: sarah.kaakai@univ-lemans.fr</span></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a><span class="co">    url: https://perso.univ-lemans.fr/~skaakai/</span></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a><span class="co">    affiliations:</span></span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a><span class="co">      - name: Le Mans Université, CNRS, Institut du Risque et de l'Assurance </span></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a><span class="co">        department: Laboratoire Manceau de Mathématiques</span></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a><span class="co">        url: https://lmm.univ-lemans.fr/fr/</span></span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a><span class="an">date:</span><span class="co"> last-modified</span></span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a><span class="an">date-modified:</span><span class="co"> last-modified</span></span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a><span class="an">description:</span><span class="co"> |</span></span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a><span class="co">    TODO</span></span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a><span class="an">abstract:</span><span class="co"> &gt;+</span></span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a><span class="co">    The `R` Package `IBMPopSim` aims to simulate the random evolution of heterogeneous populations using stochastic Individual-Based Models (IBMs). The package enables users to simulate population evolution, in which individuals are characterized by their age and some characteristics, and the population is modified by different types of events, including births/arrivals, death/exit events, or changes of characteristics. The frequency at which an event can occur to an individual can depend on their age and characteristics, but also on the characteristics of other individuals (interactions). Such models have a wide range of applications in fields including  actuarial science, biology, ecology or epidemiology. `IBMPopSim` overcomes the limitations of time-consuming IBMs simulations by implementing new efficient algorithms  based on thinning methods, which are compiled using the `Rcpp` package while providing a user-friendly interface.</span></span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true" tabindex="-1"></a><span class="an">keywords:</span><span class="co"> [Individual-based models, stochastic simulation, population dynamics, Poisson measures, thinning method, actuarial science, insurance portfolio simulation]</span></span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true" tabindex="-1"></a><span class="an">citation:</span></span>
<span id="cb11-37"><a href="#cb11-37" aria-hidden="true" tabindex="-1"></a><span class="co">  type: article-journal</span></span>
<span id="cb11-38"><a href="#cb11-38" aria-hidden="true" tabindex="-1"></a><span class="co">  container-title: "Computo"</span></span>
<span id="cb11-39"><a href="#cb11-39" aria-hidden="true" tabindex="-1"></a><span class="co">  doi: "xxxx"</span></span>
<span id="cb11-40"><a href="#cb11-40" aria-hidden="true" tabindex="-1"></a><span class="co">  url: https://computo.sfds.asso.fr/template-computo-quarto</span></span>
<span id="cb11-41"><a href="#cb11-41" aria-hidden="true" tabindex="-1"></a><span class="co">  publisher: "Société Française de Statistique"</span></span>
<span id="cb11-42"><a href="#cb11-42" aria-hidden="true" tabindex="-1"></a><span class="co">  issn: "2824-7795"</span></span>
<span id="cb11-43"><a href="#cb11-43" aria-hidden="true" tabindex="-1"></a><span class="an">bibliography:</span><span class="co"> references.bib</span></span>
<span id="cb11-44"><a href="#cb11-44" aria-hidden="true" tabindex="-1"></a><span class="an">github-user:</span><span class="co"> VincentLemaire</span></span>
<span id="cb11-45"><a href="#cb11-45" aria-hidden="true" tabindex="-1"></a><span class="an">repo:</span><span class="co"> "ibmpopsim_computo"</span></span>
<span id="cb11-46"><a href="#cb11-46" aria-hidden="true" tabindex="-1"></a><span class="an">draft:</span><span class="co"> true # set to false once the build is running</span></span>
<span id="cb11-47"><a href="#cb11-47" aria-hidden="true" tabindex="-1"></a><span class="an">published:</span><span class="co"> false # will be set to true once accepted</span></span>
<span id="cb11-48"><a href="#cb11-48" aria-hidden="true" tabindex="-1"></a><span class="an">format:</span></span>
<span id="cb11-49"><a href="#cb11-49" aria-hidden="true" tabindex="-1"></a><span class="co">  computo-html: default</span></span>
<span id="cb11-50"><a href="#cb11-50" aria-hidden="true" tabindex="-1"></a><span class="co">  computo-pdf: default</span></span>
<span id="cb11-51"><a href="#cb11-51" aria-hidden="true" tabindex="-1"></a><span class="an">crossref:</span></span>
<span id="cb11-52"><a href="#cb11-52" aria-hidden="true" tabindex="-1"></a><span class="co">    cnj-title: Assumption</span></span>
<span id="cb11-53"><a href="#cb11-53" aria-hidden="true" tabindex="-1"></a><span class="co">    cnj-prefix: Assumption </span></span>
<span id="cb11-54"><a href="#cb11-54" aria-hidden="true" tabindex="-1"></a><span class="an">execute:</span></span>
<span id="cb11-55"><a href="#cb11-55" aria-hidden="true" tabindex="-1"></a><span class="co">    eval: true</span></span>
<span id="cb11-56"><a href="#cb11-56" aria-hidden="true" tabindex="-1"></a><span class="co">    echo: true</span></span>
<span id="cb11-57"><a href="#cb11-57" aria-hidden="true" tabindex="-1"></a><span class="co">    warning: false</span></span>
<span id="cb11-58"><a href="#cb11-58" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb11-59"><a href="#cb11-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-60"><a href="#cb11-60" aria-hidden="true" tabindex="-1"></a><span class="fu"># Introduction</span></span>
<span id="cb11-61"><a href="#cb11-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-62"><a href="#cb11-62" aria-hidden="true" tabindex="-1"></a>In various fields, advances in probability have contributed to the development of a new mathematical framework for so-called individual-based stochastic population dynamics, also called stochastic Individual-Based Models (IBMs).</span>
<span id="cb11-63"><a href="#cb11-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-64"><a href="#cb11-64" aria-hidden="true" tabindex="-1"></a>Stochastic IBMs allow the modeling in continuous time of populations dynamics structured by age and/or characteristics. In the field of mathematical biology and ecology, a large community has used this formalism for the study of the evolution of structured populations (see e.g. <span class="co">[</span><span class="ot">@FerTra09; @collet2013rigorous; @BanMel15; @costa2016stochastic; @billiard2016effect; @lavallee2019stochastic; @meleard2019birth; @calvez2020horizontal</span><span class="co">]</span>), after the pioneer works&nbsp;<span class="co">[</span><span class="ot">@FouMel04; @champagnat2006unifying; @tran_2008</span><span class="co">]</span>.</span>
<span id="cb11-65"><a href="#cb11-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-66"><a href="#cb11-66" aria-hidden="true" tabindex="-1"></a>IBMs are also useful in demography and actuarial sciences, for the modeling of human populations dynamics (see e.g. <span class="co">[</span><span class="ot">@Ben10; @Bou16; @karoui2021simulating</span><span class="co">]</span>). They allow the modeling of heterogeneous and complex population dynamics, which can be used to compute demographic indicators or simulate the evolution of insurance portfolios in order to study the basis risk, compute cash flows for annuity products or pension schemes, or for a fine assessment of mortality models <span class="co">[</span><span class="ot">@barrieu2012understanding</span><span class="co">]</span>. There are other domains in which stochastic IBMs can be used, for example in epidemiology with stochastic compartmental models, neurosciences, cyber risk, or Agent-Based Models (ABMs) in economy and social sciences, which can be seen as IBMs.</span>
<span id="cb11-67"><a href="#cb11-67" aria-hidden="true" tabindex="-1"></a>Many mathematical results have been obtained in the literature cited above, for quantifying the limit behaviors of IBMs in long time or in large population. In particular, pathwise representations of IBMs have been introduced in <span class="co">[</span><span class="ot">@FouMel04</span><span class="co">]</span> (and extended to age-structured populations in <span class="co">[</span><span class="ot">@tran_2008</span><span class="co">]</span>), as measure-valued pure jumps Markov processes, solutions of SDEs driven by Poisson measures. These pathwise representations are based on the *thinning* and projection of Poisson random measures defined on extended spaces. However, the simulation of large and interacting populations is often referred as computationally expensive.</span>
<span id="cb11-68"><a href="#cb11-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-69"><a href="#cb11-69" aria-hidden="true" tabindex="-1"></a>The aim of the <span class="in">`R`</span> package <span class="in">`IBMPopSim`</span> is to meet the needs of the various communities for efficient tools in order to simulate the evolution of stochastic IBMs. <span class="in">`IBMPopSim`</span> provides a general framework for the simulation of a wide class of IBMs, where individuals are characterized by their age and/or a set of characteristics. Different types of events can be included in the modeling by users, depending on their needs: births, deaths, entry or exit in/to the population and changes of characteristics (swap events). Furthermore, the various events that can happen to individuals in the population can occur at a non-stationary frequency, depending on the individuals' characteristics and time, and also including potential interactions between individuals.</span>
<span id="cb11-70"><a href="#cb11-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-71"><a href="#cb11-71" aria-hidden="true" tabindex="-1"></a>We introduce a unified mathematical and simulation framework for this class of IBMs, generalizing the pathwise representation of IBMs by thinning of Poisson measures, as well as the associated population simulation algorithm, based on an acceptance/rejection procedure. In particular, we provide general sufficient conditions on the event intensities under which the simulation of a particular model is possible.</span>
<span id="cb11-72"><a href="#cb11-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-73"><a href="#cb11-73" aria-hidden="true" tabindex="-1"></a>We opted to implement the algorithms of the <span class="in">`IBMPopSim`</span> package using the <span class="in">`Rcpp`</span> package, a tool facilitating the seamless integration of high-performance <span class="in">`C++`</span> code into easily callable <span class="in">`R`</span> functions <span class="co">[</span><span class="ot">@JSSv040i08</span><span class="co">]</span>. With just a few lines of <span class="in">`C++`</span> code, <span class="in">`IBMPopSim`</span> offers user-friendly R functions for defining IBMs. Once events and their associated intensities are specified, an automated procedure creates the model. This involves integrating the user's source code into the primary <span class="in">`C++`</span> code using a template mechanism. Subsequently, <span class="in">`Rcpp`</span> is invoked to compile the model and integrate it into the <span class="in">`R`</span> session. Following this process, the model becomes callable with varying parameters, enabling the generation of diverse population evolution scenarios. Combined with the design of the simulation algorithms, the package structure yields very competitive simulation runtimes for IBMs, while staying user-friendly for <span class="in">`R`</span> users. Several outputs function are also implemented in <span class="in">`IBMPopSim`</span>. For instance the package allows the construction and visualization of age pyramids, as well as the construction of death and exposures table from the censored individual data, compatible with <span class="in">`R`</span> packages concerned with mortality modelling, such as <span class="co">[</span><span class="ot">@Rdemography</span><span class="co">]</span> or <span class="co">[</span><span class="ot">@Rstmomo</span><span class="co">]</span>. Several examples are provided in the form of <span class="in">`R`</span> vignettes on the <span class="co">[</span><span class="ot">website</span><span class="co">](https://daphnegiorgi.github.io/IBMPopSim/)</span>, and in recent works of <span class="co">[</span><span class="ot">@karoui2021simulating</span><span class="co">]</span> and <span class="co">[</span><span class="ot">@roget2022positive</span><span class="co">]</span>.</span>
<span id="cb11-74"><a href="#cb11-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-75"><a href="#cb11-75" aria-hidden="true" tabindex="-1"></a>Designed for applications in social sciences, the <span class="in">`R`</span> package <span class="in">`MicSim`</span>&nbsp;<span class="co">[</span><span class="ot">@Zin14</span><span class="co">]</span> can be used for continuous time microsimulation. In continuous-time microsimulation, individual life-courses are usually specified by sequences of state transitions (events) and the time spans between these transitions. The state space is usually discrete and finite, which is no necessarily the case in <span class="in">`IBMPopSim`</span>, where individuals can have continuous characteristics. But most importantly, microsimulation does not allow for interactions between individuals. Indeed, microsimulation produces separately the life courses of all individuals in the populations, based on the computation of the distribution functions of the waiting times in the distinct states of the state space, for each individual <span class="co">[</span><span class="ot">@Zin14</span><span class="co">]</span>. This can be slow in comparison to the simulation by thinning of event times occurring in the population, which is based on selecting event times among some competing proposed event times. Finally, <span class="in">`MicSim`</span> simplifies the Mic-Core microsimulation tool implemented in Java <span class="co">[</span><span class="ot">@zinn2009mic</span><span class="co">]</span>. However, the implementation in <span class="in">`R`</span> of simulation algorithms yields longer simulation run times than when using <span class="in">`Rcpp`</span>. To the best of our knowledge, there are no other <span class="in">`R`</span> packages currently available addressing the issue of IBMs efficient simulation.</span>
<span id="cb11-76"><a href="#cb11-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-77"><a href="#cb11-77" aria-hidden="true" tabindex="-1"></a>In @sec-ibm, we introduce the mathematical framework that characterizes the class of Stochastic Individual-Based Models (IBMs) that can be implemented in the <span class="in">`IBMPopSim`</span> package. In particular, a general pathwise representation of IBMs is presented. The population dynamics is obtained as the solution of an SDE driven by Poisson measures, for which we obtain existence and uniqueness results in @thm-eq-Z. Additionally, a succinct overview of the package is provided. </span>
<span id="cb11-78"><a href="#cb11-78" aria-hidden="true" tabindex="-1"></a>In @sec-simulation the two main algorithms for simulating the population evolution of an IBM across the interval $<span class="co">[</span><span class="ot">0, T</span><span class="co">]</span>$ are detailed. </span>
<span id="cb11-79"><a href="#cb11-79" aria-hidden="true" tabindex="-1"></a>In @sec-package we present the main functions of the <span class="in">`IBMPopSim`</span> package, which allow for the definition of events and their intensities, the creation of a model, and the simulation of scenarios. </span>
<span id="cb11-80"><a href="#cb11-80" aria-hidden="true" tabindex="-1"></a>Two examples are detailed in @sec-insurance-portfolio and sec-example-interaction, featuring applications involving an heterogeneous insurance portfolio characterized by entry and exit events, and an age and size-structured population with intricate interactions.</span>
<span id="cb11-81"><a href="#cb11-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-82"><a href="#cb11-82" aria-hidden="true" tabindex="-1"></a><span class="fu"># Stochastic Individual-Based Models (IBMs) in IBMPopSim {#sec-ibm}</span></span>
<span id="cb11-83"><a href="#cb11-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-84"><a href="#cb11-84" aria-hidden="true" tabindex="-1"></a>Stochastic Individual-Based Models (IBMs) represent a broad class of random population dynamics models, allowing the description of populations evolution on a microscopic scale. Informally, an IBM can be summarized by the description of the individuals constituting the population, the various types of events that can occur to these individuals, along with their respective frequencies. In <span class="in">`IBMPopSim`</span>, individuals can be characterized by their age and/or a collection of discrete or continuous characteristics. Moreover, the package enables users to simulate efficiently populations in which one or more of the following event types may occur:</span>
<span id="cb11-85"><a href="#cb11-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-86"><a href="#cb11-86" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Birth event**: addition of an individual of age 0 to the population.</span>
<span id="cb11-87"><a href="#cb11-87" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Death event**: removal of an individual from the population.</span>
<span id="cb11-88"><a href="#cb11-88" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Entry event**: arrival of an individual in the population.</span>
<span id="cb11-89"><a href="#cb11-89" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Exit (emigration) event**: exit from the population (other than death).</span>
<span id="cb11-90"><a href="#cb11-90" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Swap event**: an individual changes characteristics.</span>
<span id="cb11-91"><a href="#cb11-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-92"><a href="#cb11-92" aria-hidden="true" tabindex="-1"></a>Each event type is linked to an associated event kernel, describing how the population is modified following the occurrence of the event. For some event types, the event kernel requires explicit specification. This is the case for entry events when a new individual joins the population. Then,the model should specify how the age and characteristics of this new individual are chosen. For instance, the characteristics of a new individual in the population can be chosen uniformly in the space of all characteristics, or can depend on the distribution of his parents or those of the other individuals composing the population.</span>
<span id="cb11-93"><a href="#cb11-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-94"><a href="#cb11-94" aria-hidden="true" tabindex="-1"></a>The last component of an IBM are the event intensities. Informally, an event intensity is a function $\lambda^e_t(I, Z)$ describing the frequency at which an event $e$ can occur to an individual $I$ in a population $Z$ at a time $t$. Given a history of the population $(\mathcal{F}_t)$, the probability of event $e$ occurring to individual $I$ during a small interval of time $(t,t+dt]$ is proportional to $\lambda^e(I,t)$:</span>
<span id="cb11-95"><a href="#cb11-95" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-96"><a href="#cb11-96" aria-hidden="true" tabindex="-1"></a>    \mathbb{P}(\text{event } e \text{ occurring to $I$ during } (t,t+dt] | \mathcal{F}_t) \simeq \lambda^e_t(I, Z)dt.</span>
<span id="cb11-97"><a href="#cb11-97" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-98"><a href="#cb11-98" aria-hidden="true" tabindex="-1"></a>The intensity function $\lambda^e$ can include dependency on the individual's $I$ age and characteristics, the time $t$, or the population composition $Z$ in the presence of interactions.</span>
<span id="cb11-99"><a href="#cb11-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-100"><a href="#cb11-100" aria-hidden="true" tabindex="-1"></a><span class="fu">## Brief package overview</span></span>
<span id="cb11-101"><a href="#cb11-101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-102"><a href="#cb11-102" aria-hidden="true" tabindex="-1"></a>Prior to providing a detailed description of an Individual-Based Model (IBM), we present a simple model of birth and death in an age-structured _human_ population. We assume no interactions between individuals, and individuals are characterized by their gender, in addition to their age.</span>
<span id="cb11-103"><a href="#cb11-103" aria-hidden="true" tabindex="-1"></a>In this simple model, all individuals, regardless of gender, can give birth when their age falls between 15 and 40 years, with a constant birth rate of 0.05. The death intensity is assumed to follow a Gompertz-type intensity depending on age. </span>
<span id="cb11-104"><a href="#cb11-104" aria-hidden="true" tabindex="-1"></a>The birth and death intensities are then given by  </span>
<span id="cb11-105"><a href="#cb11-105" aria-hidden="true" tabindex="-1"></a>\begin{equation*}</span>
<span id="cb11-106"><a href="#cb11-106" aria-hidden="true" tabindex="-1"></a>    \lambda^b(t, I) = 0.05 \times \mathbf{1}_{<span class="co">[</span><span class="ot">15,40</span><span class="co">]</span>}(a(I,t)), \quad </span>
<span id="cb11-107"><a href="#cb11-107" aria-hidden="true" tabindex="-1"></a>    \lambda^d(t, I) = \alpha\exp(\beta a(I,t)), </span>
<span id="cb11-108"><a href="#cb11-108" aria-hidden="true" tabindex="-1"></a>\end{equation*} </span>
<span id="cb11-109"><a href="#cb11-109" aria-hidden="true" tabindex="-1"></a>with $a(I,t)$ the age of individual $I$ at time $t$. </span>
<span id="cb11-110"><a href="#cb11-110" aria-hidden="true" tabindex="-1"></a>Birth events are also characterized with a kernel determining the gender of the newborn, who is male with probability $p_{male}$. </span>
<span id="cb11-111"><a href="#cb11-111" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-112"><a href="#cb11-112" aria-hidden="true" tabindex="-1"></a><span class="fu">### Model creation </span></span>
<span id="cb11-113"><a href="#cb11-113" aria-hidden="true" tabindex="-1"></a>To implement this model in IBMPopSim, it is necessary to individually define each event type. In this example, the <span class="in">`mk_event_individual`</span> function is used. The creation of an event involves  a few lines of <span class="in">`cpp`</span> instructions defining the intensity and, if applicable, the kernel of the event. For a more in depth description of the event creation step and its parameters, we refer to @sec-package-events.</span>
<span id="cb11-114"><a href="#cb11-114" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-115"><a href="#cb11-115" aria-hidden="true" tabindex="-1"></a>The events of this simple model are for example defined through the following calls.</span>
<span id="cb11-118"><a href="#cb11-118" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb11-119"><a href="#cb11-119" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb11-120"><a href="#cb11-120" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-121"><a href="#cb11-121" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(IBMPopSim)</span>
<span id="cb11-122"><a href="#cb11-122" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb11-123"><a href="#cb11-123" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-126"><a href="#cb11-126" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb11-127"><a href="#cb11-127" aria-hidden="true" tabindex="-1"></a>birth_event <span class="ot">&lt;-</span> <span class="fu">mk_event_individual</span>(</span>
<span id="cb11-128"><a href="#cb11-128" aria-hidden="true" tabindex="-1"></a>  <span class="at">type =</span> <span class="st">"birth"</span>, </span>
<span id="cb11-129"><a href="#cb11-129" aria-hidden="true" tabindex="-1"></a>  <span class="at">intensity_code =</span> <span class="st">"result = birth_rate(I.age(t));"</span>,</span>
<span id="cb11-130"><a href="#cb11-130" aria-hidden="true" tabindex="-1"></a>  <span class="at">kernel_code =</span> <span class="st">"newI.male = CUnif(0,1) &lt; p_male;"</span>)</span>
<span id="cb11-131"><a href="#cb11-131" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-132"><a href="#cb11-132" aria-hidden="true" tabindex="-1"></a>death_event <span class="ot">&lt;-</span> <span class="fu">mk_event_individual</span>(</span>
<span id="cb11-133"><a href="#cb11-133" aria-hidden="true" tabindex="-1"></a>  <span class="at">type =</span> <span class="st">"death"</span>,</span>
<span id="cb11-134"><a href="#cb11-134" aria-hidden="true" tabindex="-1"></a>  <span class="at">intensity_code =</span> <span class="st">"result = alpha * exp(beta * I.age(t));"</span>)</span>
<span id="cb11-135"><a href="#cb11-135" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb11-136"><a href="#cb11-136" aria-hidden="true" tabindex="-1"></a>In the <span class="in">`cpp`</span> codes, the names <span class="in">`birth_rate`</span>, <span class="in">`p_male`</span>, <span class="in">`alpha`</span> and <span class="in">`beta`</span> refer to the model parameters defined in the following list. </span>
<span id="cb11-139"><a href="#cb11-139" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb11-140"><a href="#cb11-140" aria-hidden="true" tabindex="-1"></a>params <span class="ot">&lt;-</span> <span class="fu">list</span>(</span>
<span id="cb11-141"><a href="#cb11-141" aria-hidden="true" tabindex="-1"></a>  <span class="st">"alpha"</span> <span class="ot">=</span> <span class="fl">0.008</span>, <span class="st">"beta"</span> <span class="ot">=</span> <span class="fl">0.02</span>, </span>
<span id="cb11-142"><a href="#cb11-142" aria-hidden="true" tabindex="-1"></a>  <span class="st">"p_male"</span> <span class="ot">=</span> <span class="fl">0.51</span>,</span>
<span id="cb11-143"><a href="#cb11-143" aria-hidden="true" tabindex="-1"></a>  <span class="st">"birth_rate"</span> <span class="ot">=</span> <span class="fu">stepfun</span>(<span class="fu">c</span>(<span class="dv">15</span>, <span class="dv">40</span>), <span class="fu">c</span>(<span class="dv">0</span>, <span class="fl">0.05</span>, <span class="dv">0</span>)))</span>
<span id="cb11-144"><a href="#cb11-144" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb11-145"><a href="#cb11-145" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-146"><a href="#cb11-146" aria-hidden="true" tabindex="-1"></a>In a second step, the model is created by calling the function <span class="in">`mk_model`</span>. A <span class="in">`cpp`</span> source code is automatically created through a template mechanism based on the events and parameters, subsequently compiled using the <span class="in">`sourceCpp`</span> function from the <span class="in">`Rcpp`</span> package.</span>
<span id="cb11-149"><a href="#cb11-149" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb11-150"><a href="#cb11-150" aria-hidden="true" tabindex="-1"></a>birth_death_model <span class="ot">&lt;-</span> <span class="fu">mk_model</span>(</span>
<span id="cb11-151"><a href="#cb11-151" aria-hidden="true" tabindex="-1"></a>  <span class="at">characteristics =</span> <span class="fu">c</span>(<span class="st">"male"</span> <span class="ot">=</span> <span class="st">"bool"</span>),</span>
<span id="cb11-152"><a href="#cb11-152" aria-hidden="true" tabindex="-1"></a>  <span class="at">events =</span> <span class="fu">list</span>(death_event, birth_event),</span>
<span id="cb11-153"><a href="#cb11-153" aria-hidden="true" tabindex="-1"></a>  <span class="at">parameters =</span> params)</span>
<span id="cb11-154"><a href="#cb11-154" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb11-155"><a href="#cb11-155" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-156"><a href="#cb11-156" aria-hidden="true" tabindex="-1"></a><span class="fu">### Simulation </span></span>
<span id="cb11-157"><a href="#cb11-157" aria-hidden="true" tabindex="-1"></a>Once the model is created and compiled, the <span class="in">`popsim`</span> function is called to simulate the evolution of a population according to this model. To achieve this, an initial population must be defined. In this example, we extract a population from a dataset specified in the package (a sample of $100\,000$ individuals based on the population of England and Wales in 2014). It is also necessary to set bounds for the events intensities. In this example, they are obtained by assuming that the maximum age for an individual is 115 years. </span>
<span id="cb11-160"><a href="#cb11-160" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb11-161"><a href="#cb11-161" aria-hidden="true" tabindex="-1"></a>a_max <span class="ot">&lt;-</span> <span class="dv">115</span></span>
<span id="cb11-162"><a href="#cb11-162" aria-hidden="true" tabindex="-1"></a>events_bounds <span class="ot">=</span> <span class="fu">c</span>(</span>
<span id="cb11-163"><a href="#cb11-163" aria-hidden="true" tabindex="-1"></a>  <span class="st">"death"</span> <span class="ot">=</span> params<span class="sc">$</span>alpha <span class="sc">*</span> <span class="fu">exp</span>(params<span class="sc">$</span>beta <span class="sc">*</span> a_max),</span>
<span id="cb11-164"><a href="#cb11-164" aria-hidden="true" tabindex="-1"></a>  <span class="st">"birth"</span> <span class="ot">=</span> <span class="fu">max</span>(params<span class="sc">$</span>birth_rate))</span>
<span id="cb11-165"><a href="#cb11-165" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb11-166"><a href="#cb11-166" aria-hidden="true" tabindex="-1"></a>The function <span class="in">`popsim`</span> can now be called to simulate the population starting from the initial population <span class="in">`population(EW_pop_14$sample)`</span> up to time $T = 30$. </span>
<span id="cb11-169"><a href="#cb11-169" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb11-170"><a href="#cb11-170" aria-hidden="true" tabindex="-1"></a>sim_out <span class="ot">&lt;-</span> <span class="fu">popsim</span>(</span>
<span id="cb11-171"><a href="#cb11-171" aria-hidden="true" tabindex="-1"></a>  birth_death_model, </span>
<span id="cb11-172"><a href="#cb11-172" aria-hidden="true" tabindex="-1"></a>  <span class="fu">population</span>(EW_pop_14<span class="sc">$</span>sample), </span>
<span id="cb11-173"><a href="#cb11-173" aria-hidden="true" tabindex="-1"></a>  events_bounds, </span>
<span id="cb11-174"><a href="#cb11-174" aria-hidden="true" tabindex="-1"></a>  <span class="at">parameters =</span> params, <span class="at">age_max =</span> a_max, </span>
<span id="cb11-175"><a href="#cb11-175" aria-hidden="true" tabindex="-1"></a>  <span class="at">time =</span> <span class="dv">30</span>)</span>
<span id="cb11-176"><a href="#cb11-176" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb11-177"><a href="#cb11-177" aria-hidden="true" tabindex="-1"></a>The data frame <span class="in">`sim_out$population`</span> contains the information (birth, death, gender) on individuals who lived in the population over the period $<span class="co">[</span><span class="ot">0,30</span><span class="co">]</span>$. Functions of the package allows to provide aggregated information on the population.</span>
<span id="cb11-178"><a href="#cb11-178" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-179"><a href="#cb11-179" aria-hidden="true" tabindex="-1"></a>In the remainder of this section,  we define rigorously the class of IBMs that can be simulated in <span class="in">`IBMPopSim`</span>, along with the assumptions that are required in order for the population to be simulatable. The representation of age-structured IBMs based on measure-valued processes, as introduced in <span class="co">[</span><span class="ot">@tran_2008</span><span class="co">]</span>, is generalized to a wider class of abstract population dynamics. The modeling differs slightly here, since individuals are _kept in the population_ after their death (or exit), by including the death/exit date as an individual trait. </span>
<span id="cb11-180"><a href="#cb11-180" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-181"><a href="#cb11-181" aria-hidden="true" tabindex="-1"></a><span class="fu">## Population {#sec-population}</span></span>
<span id="cb11-182"><a href="#cb11-182" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-183"><a href="#cb11-183" aria-hidden="true" tabindex="-1"></a><span class="fu">### Notations</span></span>
<span id="cb11-184"><a href="#cb11-184" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-185"><a href="#cb11-185" aria-hidden="true" tabindex="-1"></a>In the remainder of the paper, the filtered probability space is denoted by $(\Omega,<span class="sc">\{</span>\mathcal{F}_t \},{\mathbb{P}})$, under the usual assumptions. All processes are assumed to be càdlàg and adapted to the filtration $\{\mathcal{F}_t \}$ (for instance the history of the population) on a time interval $[0,T]$. For a càdlàg process $X$, we denote $X_{t^-} := \lim_{\genfrac{}{}{0pt}{2}{s\to t}{s&lt;t}} X_s$.</span>
<span id="cb11-186"><a href="#cb11-186" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-187"><a href="#cb11-187" aria-hidden="true" tabindex="-1"></a><span class="fu">### Individuals</span></span>
<span id="cb11-188"><a href="#cb11-188" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-189"><a href="#cb11-189" aria-hidden="true" tabindex="-1"></a>An individual is represented by a triplet $I = (\tau^b, \tau^d, x) \in \mathcal{I}= {\mathbb{R}}\times \bar {\mathbb{R}}\times {\mathcal{X}}$ with:</span>
<span id="cb11-190"><a href="#cb11-190" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-191"><a href="#cb11-191" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$\tau^b \in {\mathbb{R}}$ the date of birth,</span>
<span id="cb11-192"><a href="#cb11-192" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$\tau^d \in \bar {\mathbb{R}}$ the death date, with $\tau^d = \infty$ if the individual is still alive,</span>
<span id="cb11-193"><a href="#cb11-193" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>a collection $x \in {\mathcal{X}}$ of characteristics where ${\mathcal{X}}$ is the space of characteristics.</span>
<span id="cb11-194"><a href="#cb11-194" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-195"><a href="#cb11-195" aria-hidden="true" tabindex="-1"></a>Note that in IBMs, individuals are usually characterized by their age $a(t) =t-\tau^b$ instead of their date of birth $\tau^b$. However, using the latter is actually easier for the simulation, as it remains constant over time.</span>
<span id="cb11-196"><a href="#cb11-196" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-197"><a href="#cb11-197" aria-hidden="true" tabindex="-1"></a><span class="fu">### Population process</span></span>
<span id="cb11-198"><a href="#cb11-198" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-199"><a href="#cb11-199" aria-hidden="true" tabindex="-1"></a>The population at a given time $t$ is a random set</span>
<span id="cb11-200"><a href="#cb11-200" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-201"><a href="#cb11-201" aria-hidden="true" tabindex="-1"></a>    Z_t=<span class="sc">\{</span> I_k \in \mathcal{I}; \; k= 1,\dots, N_t<span class="sc">\}</span>,</span>
<span id="cb11-202"><a href="#cb11-202" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-203"><a href="#cb11-203" aria-hidden="true" tabindex="-1"></a>composed of all individuals (alive or dead) who have lived in the population before time $t$. As a random set, $Z_t$ can be represented by a random counting measure on $\mathcal{I}$ , that is an integer-valued measure $Z: \Omega \times \mathcal{I}\to \bar {\mathbb{N}}$ where for $A \in \mathcal{I}$, $Z(A)$ is the (random) number of individuals $I$ in the subset $A$. With this representation: </span>
<span id="cb11-204"><a href="#cb11-204" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-205"><a href="#cb11-205" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb11-206"><a href="#cb11-206" aria-hidden="true" tabindex="-1"></a>    Z_t (\mathrm{d}\tau^b, \mathrm{d}\tau^d , \mathrm{d}x) &amp;= \sum_{k=1}^{N_t} \delta_{I_k} (\tau^b, \tau^d,x), \nonumber <span class="sc">\\</span></span>
<span id="cb11-207"><a href="#cb11-207" aria-hidden="true" tabindex="-1"></a>    \text{ with }  \int_{\mathcal{I}} f(\tau^b, \tau^d, x) Z_t (\mathrm{d}\tau^b, \mathrm{d}\tau^d , \mathrm{d}x) &amp;= \sum_{k=1}^{N_t} f(I_k).</span>
<span id="cb11-208"><a href="#cb11-208" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb11-209"><a href="#cb11-209" aria-hidden="true" tabindex="-1"></a>$$ {#eq-popZ}</span>
<span id="cb11-210"><a href="#cb11-210" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-211"><a href="#cb11-211" aria-hidden="true" tabindex="-1"></a>The number of individuals present in the population *before time* $t$ is obtained by taking $f\equiv 1$:</span>
<span id="cb11-212"><a href="#cb11-212" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-213"><a href="#cb11-213" aria-hidden="true" tabindex="-1"></a>    N_t =  \int_{\mathcal{I}}  Z_t(\mathrm{d}\tau^b, \mathrm{d}\tau^d, \mathrm{d}x) = \sum_{k=1}^{N_t} \boldsymbol{1}_{\mathcal{I}} (I_k).</span>
<span id="cb11-214"><a href="#cb11-214" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-215"><a href="#cb11-215" aria-hidden="true" tabindex="-1"></a>Note that $(N_t)_{t\geq 0}$ is an increasing process since dead/exited individuals are kept in the population $Z$. The number of alive individuals in the population at time $t$ is: </span>
<span id="cb11-216"><a href="#cb11-216" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-217"><a href="#cb11-217" aria-hidden="true" tabindex="-1"></a>    N_t^a =  \int_{\mathcal{I}}  \mathsf{1}_{\{\tau^d &gt; t \} }Z_t(\mathrm{d}\tau^b, \mathrm{d}\tau^d, \mathrm{d}x) = \sum_{k=1}^{N_t} \mathsf{1}_{<span class="sc">\{</span>\tau^d_k &gt; t <span class="sc">\}</span> }.</span>
<span id="cb11-218"><a href="#cb11-218" aria-hidden="true" tabindex="-1"></a>$$ {#eq-Nta}</span>
<span id="cb11-219"><a href="#cb11-219" aria-hidden="true" tabindex="-1"></a>Another example is the number of alive individuals of age over $a$ is</span>
<span id="cb11-220"><a href="#cb11-220" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-221"><a href="#cb11-221" aria-hidden="true" tabindex="-1"></a>    N_t(<span class="co">[</span><span class="ot">a,+\infty)) :=  \int_{\mathcal{I}}  \boldsymbol{1}_{[a,+\infty)}(t-\tau^b)\mathsf{1}_{]t,\infty</span><span class="co">]</span>}(\tau^d) Z_t(\mathrm{d}\tau^b, \mathrm{d}\tau^d, \mathrm{d}x) = \sum_{k=1}^{N_t}  \boldsymbol{1}_{\{ t -\tau_k^b \geq a \}}\mathsf{1}_{<span class="sc">\{</span>\tau^d_k \geq t <span class="sc">\}</span> }.</span>
<span id="cb11-222"><a href="#cb11-222" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-223"><a href="#cb11-223" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-224"><a href="#cb11-224" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-225"><a href="#cb11-225" aria-hidden="true" tabindex="-1"></a><span class="fu">## Events {#sec-events}</span></span>
<span id="cb11-226"><a href="#cb11-226" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-227"><a href="#cb11-227" aria-hidden="true" tabindex="-1"></a>The population composition changes at random dates following different types of events. <span class="in">`IBMPopSim`</span> allows the simulation of IBMs with the following events types:</span>
<span id="cb11-228"><a href="#cb11-228" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-229"><a href="#cb11-229" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>A **birth** event at time $t$ is the addition of a new individual $I'=(t,\infty, X)$ of age $0$ to the population. Their date of birth is $\tau^b =t$, and characteristics is $X$, a random variable of distribution defined by the birth kernel $k^b(t,I,\mathrm{d}x)$ on ${\mathcal{X}}$, depending on $t$ and its parent $I$. The population size becomes $N_t = N_{t^-} + 1$, and the population composition after the event is $$Z_t  = Z_{t^-} +  \delta_{(t,\infty, X)}.$$</span>
<span id="cb11-230"><a href="#cb11-230" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-231"><a href="#cb11-231" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>An **entry** event at time $t$ is also the addition of an individual $I'$ in the population. However, this individual is not of age $0$. The date of birth and characteristics of the new individual $I'= (\tau^b, \infty, X)$ are random variables of probability distribution defined by the entry kernel $k^{en}(t, \mathrm{d}s, \mathrm{d}x)$ on ${\mathbb{R}}\times {\mathcal{X}}$. The population size becomes $N_t = N_{t^-} + 1$, and the population composition after the event is: </span>
<span id="cb11-232"><a href="#cb11-232" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-233"><a href="#cb11-233" aria-hidden="true" tabindex="-1"></a>    Z_t  = Z_{t^-} +  \delta_{(\tau^b, \infty, X)}.</span>
<span id="cb11-234"><a href="#cb11-234" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-235"><a href="#cb11-235" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-236"><a href="#cb11-236" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>A **death** or **exit** event of an individual $I= (\tau^b,\infty, x)\in Z_{t^-}$ at time $t$ is the modification of its death date $\tau^d$ from $+\infty$ to $t$. This event results in the simultaneous addition of the individual $(\tau^b,t,x)$ and removal of the individual $I$ from the population. The population size is not modified, and the population composition after the event is </span>
<span id="cb11-237"><a href="#cb11-237" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-238"><a href="#cb11-238" aria-hidden="true" tabindex="-1"></a>    Z_t  = Z_{t^-} +\delta_{(\tau^b,t,x)}- \delta_{I}.</span>
<span id="cb11-239"><a href="#cb11-239" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-240"><a href="#cb11-240" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-241"><a href="#cb11-241" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>A **swap** event (change of characteristics) results in the simultaneous addition and removal of an individual. If an individual $I= (\tau^b,\infty, x) \in Z_{t^-}$ changes of characteristics at time $t$, then it is removed from the population and replaced by $I' = (\tau^b,\infty, X)$. The new characteristics $X$ is a random variable of distribution $k^s(t, I,\mathrm{d}x)$ on ${\mathcal{X}}$, depending on time, the individual's age and previous characteristics $x$. In this case, the population size is not modified and the population becomes:</span>
<span id="cb11-242"><a href="#cb11-242" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-243"><a href="#cb11-243" aria-hidden="true" tabindex="-1"></a>    Z_t  = Z_{t^-}   +  \delta_{(\tau^b,  \infty, X)} -  \delta_{(\tau^b, \infty, x)}.</span>
<span id="cb11-244"><a href="#cb11-244" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-245"><a href="#cb11-245" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-246"><a href="#cb11-246" aria-hidden="true" tabindex="-1"></a>To summarize, the space of event types is $E = <span class="sc">\{</span> b, en, d, s <span class="sc">\}</span>$, and the jump $\Delta Z_t = Z_t - Z_{t^-}$ (change in the population composition) generated by an event of type $e \in <span class="sc">\{</span> b, en, d, s <span class="sc">\}</span>$ is denoted by $\phi^e(t, I)$. We thus have the following rules summarized in the table @tbl-event-action.</span>
<span id="cb11-247"><a href="#cb11-247" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-248"><a href="#cb11-248" aria-hidden="true" tabindex="-1"></a>Event | Type | $\phi^e(t, I)$ | New individual</span>
<span id="cb11-249"><a href="#cb11-249" aria-hidden="true" tabindex="-1"></a>------|:----:|----------------|---------------</span>
<span id="cb11-250"><a href="#cb11-250" aria-hidden="true" tabindex="-1"></a>Birth | $b$ | $\delta_{(t, \infty,  X)}$ | $\tau^b =t, \; X \sim k^b(t,I,\mathrm{d}x)$ </span>
<span id="cb11-251"><a href="#cb11-251" aria-hidden="true" tabindex="-1"></a>Entry | $en$ | $\delta_{(\tau^b, \infty,  X)}$ | $(\tau^b, X) \sim k^{en}(t,\mathrm{d}s, \mathrm{d}x)$ </span>
<span id="cb11-252"><a href="#cb11-252" aria-hidden="true" tabindex="-1"></a>Death/Exit | $d$ | $\delta_{(\tau^b, t,x)} - \delta_{(\tau^b, \infty, x)}$ | $\tau^d = t$</span>
<span id="cb11-253"><a href="#cb11-253" aria-hidden="true" tabindex="-1"></a>Swap | $s$ | $\delta_{(\tau^b, \infty , X)} - \delta_{(\tau^b, \infty, x)}$ | $X \sim k^s(t,I,\mathrm{d}x)$</span>
<span id="cb11-254"><a href="#cb11-254" aria-hidden="true" tabindex="-1"></a>: Action in the population for a given event name {#tbl-event-action}</span>
<span id="cb11-255"><a href="#cb11-255" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-256"><a href="#cb11-256" aria-hidden="true" tabindex="-1"></a>::: {#rem-popfinale}</span>
<span id="cb11-257"><a href="#cb11-257" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-258"><a href="#cb11-258" aria-hidden="true" tabindex="-1"></a><span class="fu">## Composition of the population </span></span>
<span id="cb11-259"><a href="#cb11-259" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-260"><a href="#cb11-260" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>At time $T$, the population $Z_T$ contains all individuals who lived in the population before $T$, including dead/exited individuals. If there are no swap events, or entries,the population state $Z_t$ for any time $t\leq T$ can be obtained from $Z_T$. Indeed, if $Z_T = \sum_{k=1}^{N_T}  \delta_{I_k}$, then the population at time $t\leq T$ is simply composed of the individuals born before $t$: $$</span>
<span id="cb11-261"><a href="#cb11-261" aria-hidden="true" tabindex="-1"></a>    Z_t = \sum_{k=1}^{N_T} \boldsymbol{1}_{\{\tau^b_k \leq t \}} \delta_{I_k}.</span>
<span id="cb11-262"><a href="#cb11-262" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-263"><a href="#cb11-263" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>In the presence of entries (open population), a characteristic $x$ can track the individuals' entry dates. Then, the previous equation can be easily modified in order to obtain the population $Z_t$ at time $t\leq T$ from $Z_T$.</span>
<span id="cb11-264"><a href="#cb11-264" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-265"><a href="#cb11-265" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb11-266"><a href="#cb11-266" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-267"><a href="#cb11-267" aria-hidden="true" tabindex="-1"></a><span class="fu">## Events intensity {#sec-event-intensity}</span></span>
<span id="cb11-268"><a href="#cb11-268" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-269"><a href="#cb11-269" aria-hidden="true" tabindex="-1"></a>Once the different event types have been defined in the population model, the frequency at which each event occur in the population $e$ have to be specified.</span>
<span id="cb11-270"><a href="#cb11-270" aria-hidden="true" tabindex="-1"></a>Informally, the intensity $\Lambda^e_t(Z_t)$ at which an event $e$ can occur is defined by</span>
<span id="cb11-271"><a href="#cb11-271" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-272"><a href="#cb11-272" aria-hidden="true" tabindex="-1"></a>    \mathbb P\big( \text{event } e \text { occurs in the population }  Z_t  \in (t,t+\mathrm{d}t] | \mathcal{F}_t \big) \simeq  \Lambda^e_t (Z_t)\mathrm{d}t.</span>
<span id="cb11-273"><a href="#cb11-273" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-274"><a href="#cb11-274" aria-hidden="true" tabindex="-1"></a>For a more formal definition of stochastic intensities, we refer to <span class="co">[</span><span class="ot">@bremaud1981point</span><span class="co">]</span> or <span class="co">[</span><span class="ot">@KaaElK20</span><span class="co">]</span>. The form of the intensity function $(\Lambda^e_t (Z_t))$ determines the population simulation algorithm in <span class="in">`IBMPopSim`</span>:</span>
<span id="cb11-275"><a href="#cb11-275" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-276"><a href="#cb11-276" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>When the event intensity does not depend on the population state, </span>
<span id="cb11-277"><a href="#cb11-277" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-278"><a href="#cb11-278" aria-hidden="true" tabindex="-1"></a>    \big(\Lambda^e_t (Z_t)\big)_{t\in [0,T]} = \big(\mu^e(t)\big)_{t \in <span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>},</span>
<span id="cb11-279"><a href="#cb11-279" aria-hidden="true" tabindex="-1"></a>$$ {#eq-poisson-intensity}</span>
<span id="cb11-280"><a href="#cb11-280" aria-hidden="true" tabindex="-1"></a>with $\mu^e$ a deterministic function, the events of type $e$ occur at the jump times of an inhomogeneous Poisson process of intensity function $(\mu^e(t))_{t \in <span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>}$. When such an event occurs, the individual to whom the event happens to is drawn uniformly among alive individuals in the population.</span>
<span id="cb11-281"><a href="#cb11-281" aria-hidden="true" tabindex="-1"></a>In a given model, the set of events $e\in E$ with Poisson intensities will be denoted by $\mathcal{P}$.</span>
<span id="cb11-282"><a href="#cb11-282" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Otherwise, we assume that the global intensity $\Lambda^e_t(Z_t)$ at which the events of type $e$ occur in the population can be written as the sum of individual intensities $\lambda^e_t(I,Z_t)$:</span>
<span id="cb11-283"><a href="#cb11-283" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-284"><a href="#cb11-284" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb11-285"><a href="#cb11-285" aria-hidden="true" tabindex="-1"></a>    &amp;\Lambda^e_t (Z_t) = \sum_{k=1}^{N_t} \lambda^e_t ( I_k,Z_t),  <span class="sc">\\</span></span>
<span id="cb11-286"><a href="#cb11-286" aria-hidden="true" tabindex="-1"></a>    &amp; \nonumber \text{with } \mathbb P\big( \text{event } e \text { occurs to an individual } I \in (t,t+\mathrm{d}t] | \mathcal{F}_t \big) \simeq  \lambda^e_t (I,Z_t)\mathrm{d}t.</span>
<span id="cb11-287"><a href="#cb11-287" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb11-288"><a href="#cb11-288" aria-hidden="true" tabindex="-1"></a>$$ {#eq-global-intensity}</span>
<span id="cb11-289"><a href="#cb11-289" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-290"><a href="#cb11-290" aria-hidden="true" tabindex="-1"></a>Obviously, nothing can happen to dead or exited individuals, i.e. individuals $I= (\tau^b, \tau^d, x)$ with $\tau^d \leq t$. Thus, individual event intensities are assumed to be null for dead/exited individuals:</span>
<span id="cb11-291"><a href="#cb11-291" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-292"><a href="#cb11-292" aria-hidden="true" tabindex="-1"></a>    \lambda^e_t ( I,Z_t) = 0, \text{ if }\tau^d \leq t, \text{ so that } \Lambda^e_t (Z_t) = \sum_{k=1}^{N_t^a} \lambda^e_t ( I_k,Z_t),</span>
<span id="cb11-293"><a href="#cb11-293" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-294"><a href="#cb11-294" aria-hidden="true" tabindex="-1"></a>with $N^a_t$ the number of alive individuals at time $t$.</span>
<span id="cb11-295"><a href="#cb11-295" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-296"><a href="#cb11-296" aria-hidden="true" tabindex="-1"></a>The event's individual intensity $\lambda^e_t (I,Z_t)$ can depend on time (for instance when there is a mortality reduction over time), on the individual's age $t-\tau^b$ and characteristics, but also on the population composition $Z_t$. The dependence of $\lambda^e$ on the population $Z$ models interactions between individuals in the populations. Hence, two types of individual intensity functions can be implemented in <span class="in">`IBMPopSim`</span>:</span>
<span id="cb11-297"><a href="#cb11-297" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-298"><a href="#cb11-298" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>*No interactions:* The intensity function $\lambda^e$ does not depend on the population composition. The intensity at which the event of type $e$ occur to an individual $I$ only depends on its date of birth and characteristics: </span>
<span id="cb11-299"><a href="#cb11-299" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-300"><a href="#cb11-300" aria-hidden="true" tabindex="-1"></a>    \lambda^e_t (I,Z_t) = \lambda^e(t, I),</span>
<span id="cb11-301"><a href="#cb11-301" aria-hidden="true" tabindex="-1"></a>$$ {#eq-intensity-no-interaction}</span>
<span id="cb11-302"><a href="#cb11-302" aria-hidden="true" tabindex="-1"></a>where $\lambda^e: \mathbb{R}_+ \times \mathcal{I}\to {\mathbb{R}}^+$ is a deterministic function. In a given model, we denote by $\mathcal{E}$ the set of event types with individual intensity @eq-intensity-no-interaction.</span>
<span id="cb11-303"><a href="#cb11-303" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-304"><a href="#cb11-304" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>*"Quadratic" interactions:* The intensity at which an event of type $e$ occurs to an individual $I$ depends on $I$ and on the population composition, through an interaction function $W^e$. The quantity $W^e(t, I,J)$ describes the intensity of interactions between two alive individuals $I$ and $J$ at time $t$, for instance in the presence of competition or cooperation. In this case, we have</span>
<span id="cb11-305"><a href="#cb11-305" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-306"><a href="#cb11-306" aria-hidden="true" tabindex="-1"></a>    \lambda^e_t(I,Z_t)=\sum_{j=1}^{N_t} W^e(t, I, I_j) = \int_{\mathcal{I}} W^e(t, I, (\tau^b,\tau^d,x)) Z_t (\mathrm{d}\tau^b,\mathrm{d}\tau^d, \mathrm{d}x),</span>
<span id="cb11-307"><a href="#cb11-307" aria-hidden="true" tabindex="-1"></a>$$ {#eq-intensity-interaction}</span>
<span id="cb11-308"><a href="#cb11-308" aria-hidden="true" tabindex="-1"></a>where $W^e(t, I, (\tau^b,\tau^d,x))  = 0$ if the individual $J =(\tau^b,\tau^d,x)$ is dead, i.e. $\tau^d \leq t$.\ In a given model, we denote by $\mathcal{E}_W$ the set of event types with individual intensity @eq-intensity-interaction.</span>
<span id="cb11-309"><a href="#cb11-309" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-310"><a href="#cb11-310" aria-hidden="true" tabindex="-1"></a>To summarize, an individual intensity in IBMPopSim can be written as:</span>
<span id="cb11-311"><a href="#cb11-311" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-312"><a href="#cb11-312" aria-hidden="true" tabindex="-1"></a>    \lambda^e_t(I,Z_t) = \lambda^e(t, I) \mathbf{1}_{\{e \in \mathcal{E}\}} + \biggl( \sum_{j=1}^{N_t} W^e(t, I, I_j) \biggr) \mathbf{1}_{<span class="sc">\{</span>e \in \mathcal{E}_W<span class="sc">\}</span>}.</span>
<span id="cb11-313"><a href="#cb11-313" aria-hidden="true" tabindex="-1"></a>$$ {#eq-individual-intensity}</span>
<span id="cb11-314"><a href="#cb11-314" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-315"><a href="#cb11-315" aria-hidden="true" tabindex="-1"></a>::: {#exm-popfinale}</span>
<span id="cb11-316"><a href="#cb11-316" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-317"><a href="#cb11-317" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>An example of death intensity without interaction for an individual $I=(\tau^b, \tau^d, x)$ alive at time $t$, $t &lt; \tau^d$, is:</span>
<span id="cb11-318"><a href="#cb11-318" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-319"><a href="#cb11-319" aria-hidden="true" tabindex="-1"></a>    \lambda^d(t,I) =  \alpha_x \exp(\beta_x a(I,t)), \text{ where }  a(I,t) = t-\tau^b</span>
<span id="cb11-320"><a href="#cb11-320" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-321"><a href="#cb11-321" aria-hidden="true" tabindex="-1"></a>is the age of the individual $I$ at time $t$. In this classical case, the death rate of an individual $I$ is an exponential (Gompertz) function of the individual's age, with coefficients depending on the individual's characteristics $x$.</span>
<span id="cb11-322"><a href="#cb11-322" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-323"><a href="#cb11-323" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>In the presence of competition between individuals, the death intensity of an individual $I$ also depend on other individuals $J$ in the population. For example, if $I=(\tau^b,\tau^d, x)$, with $x$ its size, then we can have: </span>
<span id="cb11-324"><a href="#cb11-324" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-325"><a href="#cb11-325" aria-hidden="true" tabindex="-1"></a>    W^d(t,I,J) = (x_J - x)^+ \mathbf{1}_{<span class="sc">\{</span>\tau^d_J &gt; t<span class="sc">\}</span>}, \quad \forall \; J=(\tau^b_J,\tau^d_J , x_J).</span>
<span id="cb11-326"><a href="#cb11-326" aria-hidden="true" tabindex="-1"></a>$$ {#eq-ex-interation}</span>
<span id="cb11-327"><a href="#cb11-327" aria-hidden="true" tabindex="-1"></a>This can be interpreted as follows: if the individual $I$ meets randomly an individual $J$ alive at time $t$, and of bigger size $x_J &gt; x$, then he can die at the intensity $x_J-x$. If $J$ is smaller than $I$, then he cannot kill $I$. The bigger is the size $x$ of $I$, the lower is his death intensity $\lambda^d_t(I,Z_t)$ defined by </span>
<span id="cb11-328"><a href="#cb11-328" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-329"><a href="#cb11-329" aria-hidden="true" tabindex="-1"></a>    \lambda^d_t(I,Z_t) = \sum_{\genfrac{}{}{0pt}{2}{J\in Z_t,}{x_J &gt; x}} (x_J -x)\mathbf{1}_{<span class="sc">\{</span>\tau^d_J &gt; t<span class="sc">\}</span>}.</span>
<span id="cb11-330"><a href="#cb11-330" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-331"><a href="#cb11-331" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-332"><a href="#cb11-332" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span><span class="in">`IBMPopSim`</span> can simulate IBMs that include intensities expressed as a sum of Poisson intensities and individual intensities of the form $\Lambda^e(Z_t) =\mu^e_t + \sum_{k=1}^{N_t} \lambda^e(I_k, Z_t)$. Other examples are provided in @sec-insurance-portfolio and @sec-example-interaction.</span>
<span id="cb11-333"><a href="#cb11-333" aria-hidden="true" tabindex="-1"></a>Finally, the global intensity at which an event can occur in the population is defined by: </span>
<span id="cb11-334"><a href="#cb11-334" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-335"><a href="#cb11-335" aria-hidden="true" tabindex="-1"></a>    \Lambda_t(Z_t) = \sum_{e\in \mathcal{P}} \mu^e(t) + \sum_{e \in \mathcal E} \Big(\sum_{k=1}^{N_t} \lambda^e(t, I_k)\Big) + \sum_{e \in \mathcal E_W} \Big(\sum_{k=1}^{N_t}\sum_{j=1}^{N_t} W^e(t, I_k, I_j)\Big).</span>
<span id="cb11-336"><a href="#cb11-336" aria-hidden="true" tabindex="-1"></a>$$ {#eq-global-ev-intensity}</span>
<span id="cb11-337"><a href="#cb11-337" aria-hidden="true" tabindex="-1"></a>An important point is that for events $e \in \mathcal E$ without interactions, the global event intensity $\Lambda^e_t(Z_t) = \sum_{k=1}^{N_t} \lambda^e(t, I_k)$ is _of order_ $N_t^a$ defined in @eq-Nta (number of alive individuals at time $t$). On the other hand, for events $e \in \mathcal{E}_W$ with interactions, $\Lambda^e_t(Z_t) = \sum_{k=1}^{N_t}\sum_{j=1}^{N_t} W^e(t, I_k, I_j)$ is of order $(N_t^a)^2$. </span>
<span id="cb11-338"><a href="#cb11-338" aria-hidden="true" tabindex="-1"></a>Informally, this means that when the population size increases, events with interaction are more costly to simulate. Furthermore, the numerous computations of the interaction kernel $W^e$ can also be quite costly. The randomized Algorithm <span class="co">[</span><span class="ot">\[algo::rzndomized\]</span><span class="co">](#algo::rzndomized)</span>{reference-type="ref" reference="algo::rzndomized"}, detailed in Section <span class="co">[</span><span class="ot">2.3</span><span class="co">](#sec::simulation_algo_randomized)</span>{reference-type="ref" reference="sec::simulation_algo_randomized"}, allows us to overcome these limitations.</span>
<span id="cb11-339"><a href="#cb11-339" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-340"><a href="#cb11-340" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb11-341"><a href="#cb11-341" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-342"><a href="#cb11-342" aria-hidden="true" tabindex="-1"></a><span class="fu">### Events intensity bounds</span></span>
<span id="cb11-343"><a href="#cb11-343" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-344"><a href="#cb11-344" aria-hidden="true" tabindex="-1"></a>The simulation algorithms implemented in <span class="in">`IBMPopSim`</span> are based on an acceptance/rejection procedure, which requires to specify bounds for the various events intensities $\Lambda^e_t(Z_t)$. These bounds are defined differently depending on the expression of the intensity.</span>
<span id="cb11-345"><a href="#cb11-345" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-346"><a href="#cb11-346" aria-hidden="true" tabindex="-1"></a>::: {#cnj-intensity-poisson} </span>
<span id="cb11-347"><a href="#cb11-347" aria-hidden="true" tabindex="-1"></a>For all events $e \in \mathcal{P}$ with Poisson intensity @eq-poisson-intensity, the intensity is assumed to be bounded on $<span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>$:</span>
<span id="cb11-348"><a href="#cb11-348" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-349"><a href="#cb11-349" aria-hidden="true" tabindex="-1"></a>    \forall t \in <span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>, \quad \Lambda^e_t(Z_t) = \mu^e(t) \leq \bar \mu^e.</span>
<span id="cb11-350"><a href="#cb11-350" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-351"><a href="#cb11-351" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb11-352"><a href="#cb11-352" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-353"><a href="#cb11-353" aria-hidden="true" tabindex="-1"></a>When $e \in \mathcal{E} \cup \mathcal{E}_W$, $\Lambda^e_t(Z_t) =\sum_{k=1}^{N_t} \lambda^e_t(I_k,Z_t)$, assuming that $\Lambda^e_t(Z_t)$ is uniformly bounded is too restrictive since the event intensity depends on the population size. In this case, the assumption is made on the individual intensity $\lambda^e$ or on the interaction function $W^e$, depending on the situation.</span>
<span id="cb11-354"><a href="#cb11-354" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-355"><a href="#cb11-355" aria-hidden="true" tabindex="-1"></a>::: {#cnj-intensity1}</span>
<span id="cb11-356"><a href="#cb11-356" aria-hidden="true" tabindex="-1"></a>For all event types $e \in \mathcal{E}$, the associated individual event intensity $\lambda^e$ with no interactions, _i.e._ $\lambda^e$ verifies @eq-intensity-no-interaction, is assumed to be uniformly bounded:</span>
<span id="cb11-357"><a href="#cb11-357" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-358"><a href="#cb11-358" aria-hidden="true" tabindex="-1"></a>    \lambda^e(t, I) \leq \bar \lambda^e, \quad \forall \;  t\in <span class="co">[</span><span class="ot">0, T</span><span class="co">]</span>,  \;   I \in \mathcal{I}.</span>
<span id="cb11-359"><a href="#cb11-359" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-360"><a href="#cb11-360" aria-hidden="true" tabindex="-1"></a>In particular, </span>
<span id="cb11-361"><a href="#cb11-361" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-362"><a href="#cb11-362" aria-hidden="true" tabindex="-1"></a>    \forall t \in <span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>, \quad \Lambda^e_t (Z_t) = \sum_{k=1}^{N_t} \lambda^e(t, I) \leq \bar \lambda^e  N_t .</span>
<span id="cb11-363"><a href="#cb11-363" aria-hidden="true" tabindex="-1"></a>$$ {#eq-def-bar-Lambda}</span>
<span id="cb11-364"><a href="#cb11-364" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb11-365"><a href="#cb11-365" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-366"><a href="#cb11-366" aria-hidden="true" tabindex="-1"></a>::: {#cnj-intensity2}</span>
<span id="cb11-367"><a href="#cb11-367" aria-hidden="true" tabindex="-1"></a>For all event types $e \in \mathcal{E}_W$, the associated interaction function $W^e$ is assumed to be uniformly bounded:</span>
<span id="cb11-368"><a href="#cb11-368" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-369"><a href="#cb11-369" aria-hidden="true" tabindex="-1"></a>    W^e(t, I, J) \leq \bar W^e, \quad \forall \; t\in <span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>, \;   I, J \in \mathcal{I}.</span>
<span id="cb11-370"><a href="#cb11-370" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-371"><a href="#cb11-371" aria-hidden="true" tabindex="-1"></a>In particular, $\forall t \in <span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>$,</span>
<span id="cb11-372"><a href="#cb11-372" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-373"><a href="#cb11-373" aria-hidden="true" tabindex="-1"></a>    \lambda^e_t (I,Z_t) = \sum_{j=1}^{N_t} W^e(t, I, I_j)  \leq  \bar W^e N_t, \quad \text{and} \quad \Lambda^e_t (Z_t) \leq \bar W^e (N_t)^2.</span>
<span id="cb11-374"><a href="#cb11-374" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-375"><a href="#cb11-375" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb11-376"><a href="#cb11-376" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-377"><a href="#cb11-377" aria-hidden="true" tabindex="-1"></a>@cnj-intensity-poisson, @cnj-intensity1 and @cnj-intensity2 yield that events in the population occur with the global event intensity&nbsp;$\Lambda_t(Z_t)$, given in @eq-global-ev-intensity, which is dominated by a polynomial function in the population size: </span>
<span id="cb11-378"><a href="#cb11-378" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-379"><a href="#cb11-379" aria-hidden="true" tabindex="-1"></a>    \Lambda_t(Z_t) \leq \bar \Lambda(N_t), \quad \text{with }  \bar \Lambda (n) = \sum_{e \in \mathcal{P}} \bar \mu^e + \sum_{e\in \mathcal{E}}\bar \lambda^e  n + \sum_{e \in \mathcal E_W} \bar W^e n^2.</span>
<span id="cb11-380"><a href="#cb11-380" aria-hidden="true" tabindex="-1"></a>$$ {#eq-def-bar-Lambda}</span>
<span id="cb11-381"><a href="#cb11-381" aria-hidden="true" tabindex="-1"></a>This bound is linear in the population size if there are no interactions, and quadratic if there at least is an event including interactions. This assumption is the key to the algorithms implemented in <span class="in">`IBMPopSim`</span>. Before presenting the simulation algorithm, we close this section with a rigorous definition of an IBM, based on the pathwise representation of its dynamics a Stochastic Differential Equation (SDE) driven by Poisson random measures.</span>
<span id="cb11-382"><a href="#cb11-382" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-383"><a href="#cb11-383" aria-hidden="true" tabindex="-1"></a><span class="fu">## Pathwise representation</span></span>
<span id="cb11-384"><a href="#cb11-384" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-385"><a href="#cb11-385" aria-hidden="true" tabindex="-1"></a>Since the seminal paper of <span class="co">[</span><span class="ot">@FouMel04</span><span class="co">]</span>, it has been shown in many examples that a stochastic IBM dynamics can be defined rigorously as the unique solution of an SDE driven by Poisson measures, under reasonable non explosion conditions. In the following, we introduce a unified framework for the pathwise representation of the class of stochastic IBMs introduced above. </span>
<span id="cb11-386"><a href="#cb11-386" aria-hidden="true" tabindex="-1"></a>Some recalls on Poisson random measures are presented in the Appendix @sec-recall-poisson, and for more details on these representations on particular examples, we refer to the abundant literature on the subject.</span>
<span id="cb11-387"><a href="#cb11-387" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-388"><a href="#cb11-388" aria-hidden="true" tabindex="-1"></a>In the following we consider an individual-based stochastic population $(Z_t)_{t\in <span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>}$, keeping the notations introduced in @sec-events and @sec-event-intensity for the events and their intensities.</span>
<span id="cb11-389"><a href="#cb11-389" aria-hidden="true" tabindex="-1"></a>In particular, the set of events types that define the population evolution is denoted by $\mathcal{P} \cup \mathcal{E} \cup \mathcal{E}_W \subset E$, with $\mathcal{P}$ the set of events types with Poisson intensity verifying @cnj-intensity-poisson, $\mathcal{E}$ the set of events types with individual intensity and no interaction, verifying @cnj-intensity1 and finally $\mathcal{E}_W$ the set of event types with interactions, verifying @cnj-intensity2.</span>
<span id="cb11-390"><a href="#cb11-390" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-391"><a href="#cb11-391" aria-hidden="true" tabindex="-1"></a><span class="fu">### Non explosion criterion</span></span>
<span id="cb11-392"><a href="#cb11-392" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-393"><a href="#cb11-393" aria-hidden="true" tabindex="-1"></a>First, one has to ensure that the number of events occurring in the population will not explode in finite time, leading to an infinite simulation time. @cnj-intensity1 and @cnj-intensity2 are not sufficient to guarantee the non explosion of the event number, due to the potential explosion of the population size in the presence of interactions. An example is the case when only birth events occur, with an intensity $\Lambda^b_t(Z_t) = C_b (N_t^a)^2$ ($W^b(t, I,J) =C_b$). Then, the number of alive individuals $(N_t^a)_{t\geq 0}$ is a well-known pure birth process of intensity function $g(n) = C_b n^2$ (intensity of moving from state $n$ to $n+1$). This process explodes in finite time, since $g$ does not verify the necessary and sufficient non explosion criterion for pure birth Markov processes: $\sum_{n=1}^\infty \frac{1}{g(n)} = \infty$ (see e.g. Theorem 2.2 in <span class="co">[</span><span class="ot">@BanMel15</span><span class="co">]</span>). There is thus an explosion in finite time of birth events.</span>
<span id="cb11-394"><a href="#cb11-394" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-395"><a href="#cb11-395" aria-hidden="true" tabindex="-1"></a>This example shows that the important point for non explosion is to control the population size. We give below a general sufficient condition on birth and entry event intensities, in order for the population size to stay finite in finite time. This ensures that the number of events does not explode in finite time. Informally, the idea is to control the intensities by a pure birth intensity function verifying the non-explosion criterion.</span>
<span id="cb11-396"><a href="#cb11-396" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-397"><a href="#cb11-397" aria-hidden="true" tabindex="-1"></a>::: {#cnj-non-explosion} </span>
<span id="cb11-398"><a href="#cb11-398" aria-hidden="true" tabindex="-1"></a>Let $e=b$ or $en$, a birth or entry event type. If the intensity at which the events of type $e$ occur in the population are not Poissonian, i.e. $e \in \mathcal{E} \cup \mathcal{E}_W$, then there exists a function $f^e : {\mathbb{N}}\to (0, +\infty)$, such that</span>
<span id="cb11-399"><a href="#cb11-399" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-400"><a href="#cb11-400" aria-hidden="true" tabindex="-1"></a>    \sum_{n=1}^{\infty} \frac{1}{nf^e(n)} = \infty,</span>
<span id="cb11-401"><a href="#cb11-401" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-402"><a href="#cb11-402" aria-hidden="true" tabindex="-1"></a>and for all individual $I \in \mathcal{I}$ and population measure $Z = \sum_{k=1}^{n} \delta_{I_k}$ of size $n$,</span>
<span id="cb11-403"><a href="#cb11-403" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-404"><a href="#cb11-404" aria-hidden="true" tabindex="-1"></a>    \lambda^e_t (I, Z) \leq f^e(n), \; \forall \; 0\leq t \leq T.</span>
<span id="cb11-405"><a href="#cb11-405" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-406"><a href="#cb11-406" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb11-407"><a href="#cb11-407" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-408"><a href="#cb11-408" aria-hidden="true" tabindex="-1"></a>::: {#rem}</span>
<span id="cb11-409"><a href="#cb11-409" aria-hidden="true" tabindex="-1"></a>If $e \in \mathcal{E}$, $\lambda_t^e(I,Z) = \lambda^e(t,I) \leq \bar{\lambda}^e$ by the domination @cnj-intensity2, then @cnj-non-explosion is always verified with $f^e(n) = \bar{\lambda}^e$.</span>
<span id="cb11-410"><a href="#cb11-410" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb11-411"><a href="#cb11-411" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-412"><a href="#cb11-412" aria-hidden="true" tabindex="-1"></a>@cnj-non-explosion yields that the global intensity $\Lambda_t^e(\cdot)$ of event $e$ is bounded by a function $g^e$ only depending on the population size:</span>
<span id="cb11-413"><a href="#cb11-413" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-414"><a href="#cb11-414" aria-hidden="true" tabindex="-1"></a>    \Lambda_t^e (Z) \leq g^e(n) := nf^e(n), \quad \text{with }\sum_{n=1}^{\infty} \frac{1}{g^e(n)} = \infty.</span>
<span id="cb11-415"><a href="#cb11-415" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-416"><a href="#cb11-416" aria-hidden="true" tabindex="-1"></a>If $e\in \mathcal{P}$ has a Poisson intensity, then $\Lambda_t^e(Z) =\mu^e_t$ always verifies the previous equation with $g^e(n) = \bar \mu^e$.</span>
<span id="cb11-417"><a href="#cb11-417" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-418"><a href="#cb11-418" aria-hidden="true" tabindex="-1"></a>Before introducing the IBM SDE, let us give an idea of the equation construction. Between two successive events, the population composition $Z_t$ stays constant, since the population process $(Z_t)_{t \geq 0}$ is a pure jump process.</span>
<span id="cb11-419"><a href="#cb11-419" aria-hidden="true" tabindex="-1"></a>Furthermore, since each event type is characterized by an intensity function, the jumps occurring in the population can be represented by restriction and projection of a Poisson measure defined on a larger state space. </span>
<span id="cb11-420"><a href="#cb11-420" aria-hidden="true" tabindex="-1"></a>More precisely, we introduce a random Poisson measure $Q$ on $\mathbb R^+ \times \mathcal{J}\times \mathbb{R}^+$, with $\mathcal{J}= \mathbb N \times(\mathcal E \cup \mathcal{E}_W)$. $Q$ is composed of random quadruplets $(\tau, k , e, \theta)$, where $\tau$ represents a potential event time for an individual $I_k$ and event type $e$. </span>
<span id="cb11-421"><a href="#cb11-421" aria-hidden="true" tabindex="-1"></a>The last variable $\theta$ is used to accept/reject this proposed event, depending on the event intensity. Hence, the Poisson measure is restricted to a certain random set and then projected on the space of interest ${\mathbb{R}}^+ \times \mathcal{J}$. If the event is accepted, then a jump $\phi^e(\tau,I_k)$ occurs.</span>
<span id="cb11-422"><a href="#cb11-422" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-423"><a href="#cb11-423" aria-hidden="true" tabindex="-1"></a>::: {#thm-eq-Z} </span>
<span id="cb11-424"><a href="#cb11-424" aria-hidden="true" tabindex="-1"></a><span class="fu">## Pathwise representation</span></span>
<span id="cb11-425"><a href="#cb11-425" aria-hidden="true" tabindex="-1"></a>Let $T\in {\mathbb{R}}^+$ and $\mathcal{J}= \mathbb N \times(\mathcal E \cup \mathcal{E}_W)$. </span>
<span id="cb11-426"><a href="#cb11-426" aria-hidden="true" tabindex="-1"></a>Let $Q$ be a random Poisson measure on $\mathbb R^+ \times \mathcal{J}\times \mathbb{R}^+$, of intensity $\mathrm{d}t \delta_{\mathcal{J}}(\mathrm{d}k,\mathrm{d}e)  \mathbf{1}_{[0,\bar \lambda^e]} (\theta)\mathrm{d}\theta$, with $\delta_{\mathcal{J}}$ the counting measure on $\mathcal{J}$. </span>
<span id="cb11-427"><a href="#cb11-427" aria-hidden="true" tabindex="-1"></a>Finally, let $Q^{\mathcal P}$ be a random Poisson measure on $\mathbb R^+ \times \mathcal{P}  \times \mathbb{R}^+$, of intensity $\mathrm{d}t \delta_{\cal P}(\mathrm{d}e)  \mathbf{1}_{[0,\bar \mu^e]} (\theta)\mathrm{d}\theta$, and $Z_0= \sum_{k=1}^{N_0} \delta_{I_k}$ an initial population.</span>
<span id="cb11-428"><a href="#cb11-428" aria-hidden="true" tabindex="-1"></a>Then, under @cnj-non-explosion</span>
<span id="cb11-429"><a href="#cb11-429" aria-hidden="true" tabindex="-1"></a>, there exists a unique</span>
<span id="cb11-430"><a href="#cb11-430" aria-hidden="true" tabindex="-1"></a>measure-valued population process $Z$, strong solution on the following</span>
<span id="cb11-431"><a href="#cb11-431" aria-hidden="true" tabindex="-1"></a>SDE driven by the Poisson measure $Q$: </span>
<span id="cb11-432"><a href="#cb11-432" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-433"><a href="#cb11-433" aria-hidden="true" tabindex="-1"></a>    \begin{aligned}</span>
<span id="cb11-434"><a href="#cb11-434" aria-hidden="true" tabindex="-1"></a>    Z_t = Z_0 &amp;+ \int_0^t \int_{ \mathcal{J}\times \mathbb R^+ }\phi^e (s , I_k)  \mathbf{1}_{\{k \leq N_{s^-}\} }\mathbf{1}_{\{\theta \leq \lambda_s^e(I_k, Z_{s^-})<span class="sc">\}</span>} Q (\mathrm{d}s ,\mathrm{d}k , \mathrm{d}e, \mathrm{d}\theta ) <span class="sc">\\</span></span>
<span id="cb11-435"><a href="#cb11-435" aria-hidden="true" tabindex="-1"></a>    \nonumber &amp;+   \int_0^t \int_{\mathcal{P} \times \mathbb R^+}  \phi^e(s, I_{s^-}) \mathbf{1}_{<span class="sc">\{</span>\theta \leq \mu^e(s) <span class="sc">\}</span>} Q^{\mathcal{P}} (\mathrm{d}s ,\mathrm{d}e,  \mathrm{d}\theta),  \qquad \forall  0 \leq t \leq T,</span>
<span id="cb11-436"><a href="#cb11-436" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb11-437"><a href="#cb11-437" aria-hidden="true" tabindex="-1"></a>$$ {#eq-sde-eq-Z}</span>
<span id="cb11-438"><a href="#cb11-438" aria-hidden="true" tabindex="-1"></a>and where $I_{s^-}$ is an individual, chosen uniformly among alive individuals in the population $Z_{s^-}$.</span>
<span id="cb11-439"><a href="#cb11-439" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb11-440"><a href="#cb11-440" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-441"><a href="#cb11-441" aria-hidden="true" tabindex="-1"></a>The proof of @thm-eq-Z is detailed in the Appendix, @sec-prf-thm-eq-Z. Note that @eq-sde-eq-Z is an SDE describing the evolution of the IBM, the intensity of the events in the right hand side of the equation depending on the population process $Z$ itself. </span>
<span id="cb11-442"><a href="#cb11-442" aria-hidden="true" tabindex="-1"></a>The main idea of the proof of @thm-eq-Z is to use the non explosion property of @lem-non-explosion, and to write the r.h.s of @eq-sde-eq-Z as a sum of simple equations between two successive events, solved by induction.</span>
<span id="cb11-443"><a href="#cb11-443" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-444"><a href="#cb11-444" aria-hidden="true" tabindex="-1"></a>::: {#lem-non-explosion}</span>
<span id="cb11-445"><a href="#cb11-445" aria-hidden="true" tabindex="-1"></a>Let $Z$ be a solution of @eq-sde-eq-Z on ${\mathbb{R}}^+$, with $(T_n)_{n\geq 0}$ its jump times, $T_0 = 0$. If @cnj-non-explosion is satisfied, then</span>
<span id="cb11-446"><a href="#cb11-446" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-447"><a href="#cb11-447" aria-hidden="true" tabindex="-1"></a>    \lim_{n \to \infty} T_n = \infty, \quad {\mathbb{P}}\text{-a.s.}</span>
<span id="cb11-448"><a href="#cb11-448" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-449"><a href="#cb11-449" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb11-450"><a href="#cb11-450" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-451"><a href="#cb11-451" aria-hidden="true" tabindex="-1"></a>The proof of @lem-non-explosion, detailed in Appendix @sec-prf-lem-non-explosion is more technical and rely on pathwise comparison result, generalizing those obtained in <span class="co">[</span><span class="ot">@KaaElK20</span><span class="co">]</span>. An alternative pathwise representation of the population process, inspired by the randomized @cnj-randomized is given as well in @thm-randomized.</span>
<span id="cb11-452"><a href="#cb11-452" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-453"><a href="#cb11-453" aria-hidden="true" tabindex="-1"></a><span class="fu"># Population simulation {#sec-simulation}</span></span>
<span id="cb11-454"><a href="#cb11-454" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-455"><a href="#cb11-455" aria-hidden="true" tabindex="-1"></a>We now present the main algorithm for simulating the evolution of an IBM over $<span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>$.The algorithm implemented in <span class="in">`IBMPopSim`</span> allows the exact simulation of @eq-sde-eq-Z, based on an acceptance/reject algorithm for simulating random times called *thinning*. The exact simulation of event times with this acceptance/reject procedure is closely related to the simulations of inhomogeneous Poisson processes by the so-called thinning algorithm, often attributed to <span class="co">[</span><span class="ot">@LewShe79</span><span class="co">]</span>. </span>
<span id="cb11-456"><a href="#cb11-456" aria-hidden="true" tabindex="-1"></a>The simulation methods for inhomogeneous Poisson processes can be adapted to IBMs, and we introduce in this section a general algorithm extending those by <span class="co">[</span><span class="ot">@FouMel04</span><span class="co">]</span> (see also <span class="co">[</span><span class="ot">@FerTra09</span><span class="co">]</span>, <span class="co">[</span><span class="ot">@Ben10</span><span class="co">]</span>).</span>
<span id="cb11-457"><a href="#cb11-457" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-458"><a href="#cb11-458" aria-hidden="true" tabindex="-1"></a>The algorithm is based on exponential "candidate" event times, chosen with a (constant) intensity which must be greater than the global event intensity $\Lambda_t(Z_t)$ (@eq-global-intensity). Starting from time $t$, once a candidate event time $t + \bar T_\ell$ has been proposed, a candidate event type $e$ (birth, death,<span class="sc">\.</span>..) is chosen with a probability $p^e$ depending on the event intensity bounds $\bar \mu^e$, $\bar \lambda^e$ and $\bar W^e$, as defined in @cnj-intensity1 and @cnj-intensity2. </span>
<span id="cb11-459"><a href="#cb11-459" aria-hidden="true" tabindex="-1"></a>An individual $I$ is then drawn from the population. </span>
<span id="cb11-460"><a href="#cb11-460" aria-hidden="true" tabindex="-1"></a>Finally, it remains to accept or reject the candidate event with a probability $q^e(t,I,Z_t)$ depending on the true event intensity. </span>
<span id="cb11-461"><a href="#cb11-461" aria-hidden="true" tabindex="-1"></a>If the candidate event time is accepted, then the event $e$ occurs at time $t + \bar T_\ell$ to the individual $I$. The main idea of the algorithm implemented can be summarized as follows:</span>
<span id="cb11-462"><a href="#cb11-462" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-463"><a href="#cb11-463" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Draw a candidate time $t + \bar T_\ell$ and candidate event type $e$.</span>
<span id="cb11-464"><a href="#cb11-464" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Draw a uniform variable $\theta \sim \mathcal{U}(<span class="co">[</span><span class="ot">0, 1</span><span class="co">]</span>)$ and individual $I$.</span>
<span id="cb11-465"><a href="#cb11-465" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>**If** $\theta \leq q^e(t,I,Z_t)$ **then** event $e$ occur to individual $I$, **else** Do nothing and start again from $t + \bar T_\ell$.</span>
<span id="cb11-466"><a href="#cb11-466" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-467"><a href="#cb11-467" aria-hidden="true" tabindex="-1"></a>Before introducing the main algorithms in more details, we recall briefly the thinning procedure for simulating inhomogeneous Poisson processes, as well as the links with pathwise representations. Some recalls on Poisson random measures are presented in @sec-recall-poisson.</span>
<span id="cb11-468"><a href="#cb11-468" aria-hidden="true" tabindex="-1"></a>For a more general presentation of thinning of a Poisson random measure, see <span class="co">[</span><span class="ot">@Dev86; @Cin11; @Kal17</span><span class="co">]</span>.</span>
<span id="cb11-469"><a href="#cb11-469" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-470"><a href="#cb11-470" aria-hidden="true" tabindex="-1"></a><span class="fu">## Thinning of Poisson measure {#sec-thinning}</span></span>
<span id="cb11-471"><a href="#cb11-471" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-472"><a href="#cb11-472" aria-hidden="true" tabindex="-1"></a>Let us start with the simulation and pathwise representation of an inhomogeneous Poisson process on $<span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>$ with intensity $(\Lambda(t))_{t\in <span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>}$. The thinning procedure is based on the fundamental assumption that $\Lambda(t) \leq  \bar \Lambda$ is bounded on $<span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>$. In this case, the inhomogeneous Poisson can be obtained from an homogeneous Poisson process of intensity $\bar \Lambda$, which can be simulated easily.</span>
<span id="cb11-473"><a href="#cb11-473" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-474"><a href="#cb11-474" aria-hidden="true" tabindex="-1"></a>First, the Poisson process can be extended to a Marked Poisson measure $\bar Q:= \sum_{\ell \ge 1} \delta_{(\bar T_\ell, \bar \Theta_\ell)}$ on $(\mathbb{R}^+)^2$, defined as follow:</span>
<span id="cb11-475"><a href="#cb11-475" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-476"><a href="#cb11-476" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The jump times of $(\bar T_\ell)_{\ell \ge 1}$ of $\bar Q$ are the jump times of a Poisson process of intensity $\bar \Lambda$.</span>
<span id="cb11-477"><a href="#cb11-477" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-478"><a href="#cb11-478" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The marks $(\bar \Theta_\ell)_{\ell \ge 1}$ are _i.i.d._ random variables, uniformly distributed on $<span class="co">[</span><span class="ot">0, \bar \Lambda</span><span class="co">]</span>$.</span>
<span id="cb11-479"><a href="#cb11-479" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-480"><a href="#cb11-480" aria-hidden="true" tabindex="-1"></a>By @prp-marked-poisson , $\bar{Q}$ is a Poisson random measure with mean measure</span>
<span id="cb11-481"><a href="#cb11-481" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-482"><a href="#cb11-482" aria-hidden="true" tabindex="-1"></a>    \bar \mu(\mathrm{d}t, \mathrm{d}\theta): = \bar \Lambda \mathrm{d}t</span>
<span id="cb11-483"><a href="#cb11-483" aria-hidden="true" tabindex="-1"></a>    \frac{\mathbf{1}_{[0, \bar \Lambda]}(\theta)}{\bar \Lambda} \mathrm{d}\theta= \mathrm{d}t  \mathbf{1}_{<span class="co">[</span><span class="ot">0, \bar \Lambda</span><span class="co">]</span>}(\theta) \mathrm{d}\theta.</span>
<span id="cb11-484"><a href="#cb11-484" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-485"><a href="#cb11-485" aria-hidden="true" tabindex="-1"></a>In particular, the average number of atoms $(\bar T_\ell, \bar \Theta_\ell)$ in $<span class="co">[</span><span class="ot">0,t</span><span class="co">]</span>\times <span class="co">[</span><span class="ot">0,h</span><span class="co">]</span>$ is</span>
<span id="cb11-486"><a href="#cb11-486" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-487"><a href="#cb11-487" aria-hidden="true" tabindex="-1"></a>    \mathbb{E}<span class="co">[</span><span class="ot">Q([0,t]\times [0,h])</span><span class="co">]</span>={\mathbb{E}}<span class="co">[</span><span class="ot">\sum_{\ell} \boldsymbol{1}_{[0,t]\times [0,h]} (\bar T_\ell, \bar \Theta_{\ell})</span><span class="co">]</span>  = \int_{(\mathbb{R}^+)^2}  \bar \mu(\mathrm{d}t, \mathrm{d}\theta)  = t (\bar \Lambda \wedge h).</span>
<span id="cb11-488"><a href="#cb11-488" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-489"><a href="#cb11-489" aria-hidden="true" tabindex="-1"></a>The thinning is based on the restriction property for Poisson measure: for a measurable set $\Delta\subset {\mathbb{R}}^+\times {\mathbb{R}}^+$, the restriction $Q^\Delta:= \boldsymbol{1}_{\Delta}\bar Q$ of $\bar Q$ to $\Delta$ (by taking only atoms in $\Delta$) is also a Poisson random measure of mean measure $\mu^{\Delta}(\mathrm{d}t, \mathrm{d}\theta)  = \boldsymbol{1}_{\Delta}(t,\theta) \bar \mu(\mathrm{d}t, \mathrm{d}\theta).$</span>
<span id="cb11-490"><a href="#cb11-490" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-491"><a href="#cb11-491" aria-hidden="true" tabindex="-1"></a>In order to obtain an inhomogeneous Poisson measure of intensity $(\Lambda(t))$, the "good" choice of $\Delta$ is the hypograph of $\Lambda$:</span>
<span id="cb11-492"><a href="#cb11-492" aria-hidden="true" tabindex="-1"></a>$\Delta =<span class="sc">\{</span> (t,\theta) \in <span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>\times <span class="co">[</span><span class="ot">0,\bar \Lambda</span><span class="co">]</span> ; \; \theta \leq \Lambda(t)<span class="sc">\}</span>$ </span>
<span id="cb11-493"><a href="#cb11-493" aria-hidden="true" tabindex="-1"></a>(see @fig-thinning). Then, </span>
<span id="cb11-494"><a href="#cb11-494" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-495"><a href="#cb11-495" aria-hidden="true" tabindex="-1"></a>    Q^\Delta = \sum_{\ell \ge 1} \mathbf{1}_{\left\{\bar \Theta_\ell \le \Lambda(\bar T_\ell)\right\}} \delta_{(\bar T_\ell, \bar \Theta_\ell)},</span>
<span id="cb11-496"><a href="#cb11-496" aria-hidden="true" tabindex="-1"></a>$$ </span>
<span id="cb11-497"><a href="#cb11-497" aria-hidden="true" tabindex="-1"></a>and since $\Lambda(t) \leq \bar \Lambda$, on $<span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>$:</span>
<span id="cb11-498"><a href="#cb11-498" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-499"><a href="#cb11-499" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb11-500"><a href="#cb11-500" aria-hidden="true" tabindex="-1"></a>    \mu^{\Delta}(\mathrm{d}t, \mathrm{d}\theta) &amp; = \boldsymbol{1}_{<span class="sc">\{</span> \theta \leq \Lambda(t)<span class="sc">\}</span>}  \mathrm{d}t</span>
<span id="cb11-501"><a href="#cb11-501" aria-hidden="true" tabindex="-1"></a>\mathbf{1}_{[0, \bar \Lambda]}(\theta)\mathrm{d}\theta = \boldsymbol{1}_{<span class="sc">\{</span>\theta \leq \Lambda(t)<span class="sc">\}</span>} \mathrm{d}t \mathrm{d}\theta.</span>
<span id="cb11-502"><a href="#cb11-502" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb11-503"><a href="#cb11-503" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-504"><a href="#cb11-504" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-505"><a href="#cb11-505" aria-hidden="true" tabindex="-1"></a><span class="al">![test](img/plot_thinning.tex)</span>{#fig-thinning}</span>
<span id="cb11-506"><a href="#cb11-506" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-507"><a href="#cb11-507" aria-hidden="true" tabindex="-1"></a>Finally, the inhomogeneous Poisson process is obtained by the projection @prp-proj-poisson-measure, which states that the jump times of $Q^\Delta$ are the jump times of an inhomogeneous Poisson process of intensity $(\Lambda(t))$.</span>
<span id="cb11-508"><a href="#cb11-508" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-509"><a href="#cb11-509" aria-hidden="true" tabindex="-1"></a>::: {#prp-thinning}</span>
<span id="cb11-510"><a href="#cb11-510" aria-hidden="true" tabindex="-1"></a>The counting process $N^\Lambda$, projection of $Q^{\Delta}$ on the time component and defined by,</span>
<span id="cb11-511"><a href="#cb11-511" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-512"><a href="#cb11-512" aria-hidden="true" tabindex="-1"></a>    N^{\Lambda}_t := Q^{\Delta}( [0,t] \times {\mathbb{R}}^+) = \int_0^t \int_{{\mathbb{R}}^+} \boldsymbol{1}_{\{\theta \leq \Lambda(s)\}} \bar Q(\mathrm{d}s, \mathrm{d}\theta) = \sum_{\ell \geq 1} \mathsf{1}_{\{ \bar T_\ell \leq t \}} \mathsf{1}_{\{\bar \Theta_\ell \leq  \Lambda(\bar T_\ell) <span class="sc">\}</span>},  \quad \forall t \in <span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>,</span>
<span id="cb11-513"><a href="#cb11-513" aria-hidden="true" tabindex="-1"></a>$$ {#eq-thinning-inhomogeneous-poisson}</span>
<span id="cb11-514"><a href="#cb11-514" aria-hidden="true" tabindex="-1"></a>is an inhomogeneous Poisson process on $<span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>$ of intensity function $(\Lambda(t))_{t\in <span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>}$. The thinning @eq-thinning-inhomogeneous-poisson is a pathwise representation of $N^\Lambda$ by *restriction and projection* of the Poisson measure $Q$ on $<span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>$.</span>
<span id="cb11-515"><a href="#cb11-515" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb11-516"><a href="#cb11-516" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-517"><a href="#cb11-517" aria-hidden="true" tabindex="-1"></a>The previous proposition yields a straightforward thinning algorithm to simulate the jump times $(T_k)_{k \ge 1}$ of an inhomogeneous Poisson process of intensity $\Lambda(t)$, by selecting jump times $\bar T_\ell$ such that $\bar \Theta_\ell \le \Lambda(\bar T_\ell)$.</span>
<span id="cb11-518"><a href="#cb11-518" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-519"><a href="#cb11-519" aria-hidden="true" tabindex="-1"></a><span class="fu">### Multivariate Poisson process {#sec-vector}</span></span>
<span id="cb11-520"><a href="#cb11-520" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-521"><a href="#cb11-521" aria-hidden="true" tabindex="-1"></a>This can be extended to the simulation of multivariate inhomogeneous Poisson processes, which is an important example before tackling the simulation of an IBM.</span>
<span id="cb11-522"><a href="#cb11-522" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-523"><a href="#cb11-523" aria-hidden="true" tabindex="-1"></a>Let $(N^j)_{j \in \mathcal{J}}$ be a (inhomogeneous) multivariate Poisson process indexed by a finite set $\mathcal{J}$, such that $\forall j \in \mathcal{J}$, the intensity $(\lambda_j(t))_{t\in <span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>}$ of $N_j$ is bounded on $<span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>$:</span>
<span id="cb11-524"><a href="#cb11-524" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-525"><a href="#cb11-525" aria-hidden="true" tabindex="-1"></a>    \sup_{t\in<span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>} \lambda_j(t) \le \bar \lambda_j, \text{ and let }</span>
<span id="cb11-526"><a href="#cb11-526" aria-hidden="true" tabindex="-1"></a>    \bar \Lambda = \sum_{j \in \mathcal{J}} \bar \lambda_j.</span>
<span id="cb11-527"><a href="#cb11-527" aria-hidden="true" tabindex="-1"></a>$$ </span>
<span id="cb11-528"><a href="#cb11-528" aria-hidden="true" tabindex="-1"></a>Recall that such multivariate counting process can be rewritten as a Poisson random measure $N= \sum_{k\geq 1} \delta_{(T_k,J_k)}$ on ${\mathbb{R}}^+\times \mathcal{J}$ (see e.g. Sec. 2 of Chapter 6 in&nbsp;<span class="co">[</span><span class="ot">@Cin11</span><span class="co">]</span>), where $T_k$ is the $k$th jump time of $\sum_{j\in \mathcal{J}} N^j$ and $J_k$ corresponds to the component of the the vector which jumps. In particular, $N^j_t = N(<span class="co">[</span><span class="ot">0,t</span><span class="co">]</span>\times <span class="sc">\{</span>j<span class="sc">\}</span>)$.</span>
<span id="cb11-529"><a href="#cb11-529" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-530"><a href="#cb11-530" aria-hidden="true" tabindex="-1"></a>Once again the simulation of such process can be obtained from the simulation of a (homogeneous) multivariate Poisson process of intensity vector $(\bar{\lambda}_j)_{j \in \mathcal{J}}$, extended into a Poisson measures by adding marks on ${\mathbb{R}}^+$. </span>
<span id="cb11-531"><a href="#cb11-531" aria-hidden="true" tabindex="-1"></a>Thus, we introduce the Marked Poisson measure $\bar Q = \sum \delta_{(\bar T_\ell, \bar J_\ell, \bar \Theta_\ell)}$ on ${\mathbb{R}}^+  \times \mathcal{J}\times {\mathbb{R}}^+$, such that:</span>
<span id="cb11-532"><a href="#cb11-532" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-533"><a href="#cb11-533" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The jump times $(\bar T_\ell)$ of $\bar Q$ are the jump times of a Poisson measure of intensity $\bar \Lambda$.</span>
<span id="cb11-534"><a href="#cb11-534" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The variables $(\bar J_\ell)$ are *i.i.d.* random variables on $\mathcal{J}$, with $\displaystyle p_j= {\mathbb{P}}(\bar J_1 = j)= \bar \lambda_j/\bar \Lambda$ and representing the component of the vector which jumps.</span>
<span id="cb11-535"><a href="#cb11-535" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The marks $(\bar \Theta_\ell)$ are independent variables with $\bar \Theta_\ell$ a uniform random variable on $[0,\bar \lambda_{{\bar J}_\ell}]$, $\forall \ell \geq 1$.</span>
<span id="cb11-536"><a href="#cb11-536" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-537"><a href="#cb11-537" aria-hidden="true" tabindex="-1"></a>By @prp-marked-poisson and @prp-proj-poisson-measure, each measure $\bar Q_j (\mathrm{d}t, \mathrm{d}\theta) = \bar Q(\mathrm{d}t, <span class="sc">\{</span>j<span class="sc">\}</span>, \mathrm{d}\theta) = \sum_{\ell \geq 1} \mathsf{1}_{\{\bar J_\ell=j \}} \delta_{(\bar T_\ell, \bar \Theta_\ell)}$ is a marked Poisson measure of intensity</span>
<span id="cb11-538"><a href="#cb11-538" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-539"><a href="#cb11-539" aria-hidden="true" tabindex="-1"></a>    \bar \mu_j ( \mathrm{d}t  ,\mathrm{d}\theta) = \bar{\Lambda}p_j \mathrm{d}t  \frac{\mathsf{1}_{\{\theta \leq \bar \lambda_{j}\}}(\theta)}{\bar \lambda_{j}} \mathrm{d}\theta = \mathrm{d}t  \mathsf{1}_{\{\theta \leq \bar \lambda_{j}<span class="sc">\}</span>}(\theta) \mathrm{d}\theta.</span>
<span id="cb11-540"><a href="#cb11-540" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-541"><a href="#cb11-541" aria-hidden="true" tabindex="-1"></a>As a direct application of @prp-thinning , the inhomogeneous multivariate Poisson process is obtained by restriction of each measures $\bar Q_j$ to $\Delta_j = <span class="sc">\{</span> (t, \theta) \in <span class="co">[</span><span class="ot">0,T</span><span class="co">]</span> \times <span class="co">[</span><span class="ot">0,\bar \lambda_j</span><span class="co">]</span> ;\; \theta \leq \lambda_j(t) <span class="sc">\}</span>$ and projection.</span>
<span id="cb11-542"><a href="#cb11-542" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-543"><a href="#cb11-543" aria-hidden="true" tabindex="-1"></a>::: {#prp-thinning-vector}</span>
<span id="cb11-544"><a href="#cb11-544" aria-hidden="true" tabindex="-1"></a>The multivariate counting process $(N^j)_{j \in \mathcal{J}}$, defined for all $j \in \mathcal{J}$ and $t \in <span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>$ by thinning and projection of $\bar Q$:</span>
<span id="cb11-545"><a href="#cb11-545" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-546"><a href="#cb11-546" aria-hidden="true" tabindex="-1"></a>    N^j_t  := \int_0^t \int_{ {\mathbb{R}}^+} \boldsymbol{1}_{\{\theta \leq \lambda_j(s)\}} \bar{Q}(\mathrm{d}s, \{j\}, \mathrm{d}\theta) = \sum_{\ell \geq 1} \mathsf{1}_{\{ \bar T_\ell \leq t \}}\mathsf{1}_{\{\bar J_\ell = j\}} \mathsf{1}_{\{\bar \Theta_\ell \leq  \lambda_j (\bar T_\ell ) <span class="sc">\}</span>},</span>
<span id="cb11-547"><a href="#cb11-547" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-548"><a href="#cb11-548" aria-hidden="true" tabindex="-1"></a>is an inhomogeneous Poisson process of intensity vector $(\lambda_j(t))_{j\in\mathcal{J}}$ on $<span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>$.</span>
<span id="cb11-549"><a href="#cb11-549" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb11-550"><a href="#cb11-550" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-551"><a href="#cb11-551" aria-hidden="true" tabindex="-1"></a>@prp-thinning-vector yields the following simulation @alg-thinning2 for multivariate Poisson processes.</span>
<span id="cb11-552"><a href="#cb11-552" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-553"><a href="#cb11-553" aria-hidden="true" tabindex="-1"></a><span class="in">```pseudocode</span></span>
<span id="cb11-554"><a href="#cb11-554" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: alg-thinning2</span></span>
<span id="cb11-555"><a href="#cb11-555" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-indent-size: "1.2em"</span></span>
<span id="cb11-556"><a href="#cb11-556" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-comment-delimiter: "//"</span></span>
<span id="cb11-557"><a href="#cb11-557" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-line-number: true</span></span>
<span id="cb11-558"><a href="#cb11-558" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-line-number-punc: ":"</span></span>
<span id="cb11-559"><a href="#cb11-559" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-no-end: false</span></span>
<span id="cb11-560"><a href="#cb11-560" aria-hidden="true" tabindex="-1"></a><span class="in">#| pdf-placement: "htb!"</span></span>
<span id="cb11-561"><a href="#cb11-561" aria-hidden="true" tabindex="-1"></a><span class="in">#| pdf-line-number: true</span></span>
<span id="cb11-562"><a href="#cb11-562" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-563"><a href="#cb11-563" aria-hidden="true" tabindex="-1"></a><span class="in">\begin{algorithm}</span></span>
<span id="cb11-564"><a href="#cb11-564" aria-hidden="true" tabindex="-1"></a><span class="in">\caption{Thinning algorithm for multivariate inhomogeneous Poisson processes.}</span></span>
<span id="cb11-565"><a href="#cb11-565" aria-hidden="true" tabindex="-1"></a><span class="in">\begin{algorithmic}</span></span>
<span id="cb11-566"><a href="#cb11-566" aria-hidden="true" tabindex="-1"></a><span class="in">    \State \textbf{Input:} Functions $\lambda_j: [0,T] \to [0,\bar \lambda]$ and $\bar \lambda_j$, $\bar \Lambda = \sum_{j \in \mathcal{J}} \bar \lambda_j$</span></span>
<span id="cb11-567"><a href="#cb11-567" aria-hidden="true" tabindex="-1"></a><span class="in">    \State \textbf{Output:} Points $(T_k, J_k)$ of Poisson measure $N$ on $[0,T] \times \mathcal{J}$</span></span>
<span id="cb11-568"><a href="#cb11-568" aria-hidden="true" tabindex="-1"></a><span class="in">    \State Initialization $T_0 \longleftarrow 0$, $\bar T_0 \longleftarrow 0$</span></span>
<span id="cb11-569"><a href="#cb11-569" aria-hidden="true" tabindex="-1"></a><span class="in">    \While{$T_k &lt; T$}</span></span>
<span id="cb11-570"><a href="#cb11-570" aria-hidden="true" tabindex="-1"></a><span class="in">        \Repeat</span></span>
<span id="cb11-571"><a href="#cb11-571" aria-hidden="true" tabindex="-1"></a><span class="in">            \State increment iterative variable $\ell \longleftarrow \ell+1$</span></span>
<span id="cb11-572"><a href="#cb11-572" aria-hidden="true" tabindex="-1"></a><span class="in">            \State compute next proposed time $\bar T_{\ell} \longleftarrow \bar T_{\ell-1} + S_\ell$  with $S_\ell \sim \mathcal{E}(\bar \Lambda)$ </span></span>
<span id="cb11-573"><a href="#cb11-573" aria-hidden="true" tabindex="-1"></a><span class="in">            \State draw $\bar J_\ell \sim \mathcal{U}\big\{ \bar \lambda_j / \bar \Lambda, j \in \mathcal{J} \big\}$ i.e. $\mathbb{P}(\bar J_\ell = j) = \bar \lambda_j / \bar \Lambda$</span></span>
<span id="cb11-574"><a href="#cb11-574" aria-hidden="true" tabindex="-1"></a><span class="in">            \State draw $\bar \Theta_\ell \sim \mathcal{U}([0,\bar \lambda_{\bar J_\ell}])$</span></span>
<span id="cb11-575"><a href="#cb11-575" aria-hidden="true" tabindex="-1"></a><span class="in">        \Until{accepted event $\bar \Theta_\ell \le \lambda_{\bar J_\ell}(\bar T_{\ell})$} </span></span>
<span id="cb11-576"><a href="#cb11-576" aria-hidden="true" tabindex="-1"></a><span class="in">        \State record $(T_k, J_k) \longleftarrow (\bar T_{\ell}, \bar J_\ell)$ as accepted point</span></span>
<span id="cb11-577"><a href="#cb11-577" aria-hidden="true" tabindex="-1"></a><span class="in">    \EndWhile</span></span>
<span id="cb11-578"><a href="#cb11-578" aria-hidden="true" tabindex="-1"></a><span class="in">\end{algorithmic}</span></span>
<span id="cb11-579"><a href="#cb11-579" aria-hidden="true" tabindex="-1"></a><span class="in">\end{algorithm}</span></span>
<span id="cb11-580"><a href="#cb11-580" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb11-581"><a href="#cb11-581" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-582"><a href="#cb11-582" aria-hidden="true" tabindex="-1"></a>::: {#rem-alternate-thinning}</span>
<span id="cb11-583"><a href="#cb11-583" aria-hidden="true" tabindex="-1"></a>The acceptance/rejection @alg-thinning2 can be efficient when the functions $\lambda_j$ are of different order, and thus bounded by different $\bar \lambda_j$. However, it is important to note that the simulation of the discrete random variables $(\bar J_\ell)$ can be costly (compared to a uniform law) when $\mathcal{J}$ is large, for instance when an individual is drawn from a large population. In this case, an alternative is to choose the same bound $\bar \lambda_j= \bar \lambda$ for all $j \in \mathcal{J}$. Then the marks $(\bar J_\ell, \bar \Theta_\ell)$ are *i.i.d.* uniform variables on $\mathcal{J}\times <span class="co">[</span><span class="ot">0,\bar \lambda</span><span class="co">]</span>$, faster to simulate.</span>
<span id="cb11-584"><a href="#cb11-584" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb11-585"><a href="#cb11-585" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-586"><a href="#cb11-586" aria-hidden="true" tabindex="-1"></a><span class="fu">## Simulation algorithm {#sec-simulation-algo}</span></span>
<span id="cb11-587"><a href="#cb11-587" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-588"><a href="#cb11-588" aria-hidden="true" tabindex="-1"></a>Let us now come back to the simulation of the IBM introduced in @sec-ibm. For ease of notations, we assume that there are no event with Poisson intensity ($\mathcal{P} =\emptyset$), so that all events that occur are of type $e \in \mathcal{E} \cup \mathcal{E}_W$, with individual intensity $\lambda_t^e(I,Z_t)$ depending on the population composition $Z_t$ ($e \in \mathcal{E}_W$) or not ($e \in \mathcal{E}$), as defined in @eq-individual-intensity and verifying either @cnj-intensity1 or @cnj-intensity2.</span>
<span id="cb11-589"><a href="#cb11-589" aria-hidden="true" tabindex="-1"></a>The global intensity @eq-global-ev-intensity at time $t \in <span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>$ is thus</span>
<span id="cb11-590"><a href="#cb11-590" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-591"><a href="#cb11-591" aria-hidden="true" tabindex="-1"></a>    \Lambda_t(Z_t) = \sum_{e \in \mathcal{E}} \Big( \sum_{k=1}^{N_t} \lambda^e(t, I_k) \Big)</span>
<span id="cb11-592"><a href="#cb11-592" aria-hidden="true" tabindex="-1"></a><span class="ss">    + </span>\sum_{e \in \mathcal{E}_W} \Big( \sum_{k=1}^{N_t} \sum_{j=1}^{N_t} W^e(t, I_k, I_j) \Big) \leq \bar \Lambda(N_t),</span>
<span id="cb11-593"><a href="#cb11-593" aria-hidden="true" tabindex="-1"></a>$$ {#eq-def-intensity}</span>
<span id="cb11-594"><a href="#cb11-594" aria-hidden="true" tabindex="-1"></a>with</span>
<span id="cb11-595"><a href="#cb11-595" aria-hidden="true" tabindex="-1"></a>$\bar \Lambda(n) = \big(\sum_{e \in \mathcal{E}} \bar \lambda^e \big) n + \big( \sum_{e \in \mathcal{E}_W} \bar W^e \big) n^2$.</span>
<span id="cb11-596"><a href="#cb11-596" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-597"><a href="#cb11-597" aria-hidden="true" tabindex="-1"></a>One of the main difficulty is that the intensity of events is not deterministic as in the case of inhomogeneous Poisson processes, but a function $\Lambda_t(Z_t)$ of the population state, bounded by a function which also depends on the population size. However, the @alg-thinning2 can be adapted to simulate the IBM. The construction is done by induction, by conditioning on the state of the population $Z_{T_k}$ at the $k$th event time $T_k$ ($T_0 = 0$).</span>
<span id="cb11-598"><a href="#cb11-598" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-599"><a href="#cb11-599" aria-hidden="true" tabindex="-1"></a>We first present the construction of the first event at time $T_1$.</span>
<span id="cb11-600"><a href="#cb11-600" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-601"><a href="#cb11-601" aria-hidden="true" tabindex="-1"></a><span class="fu">### First event simulation</span></span>
<span id="cb11-602"><a href="#cb11-602" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-603"><a href="#cb11-603" aria-hidden="true" tabindex="-1"></a>Before the first event time, on $<span class="sc">\{</span> t &lt; T_1 <span class="sc">\}</span>$, the population composition is constant : $Z_t = Z_0 = <span class="sc">\{</span> I_1, \dots, I_{N_0}<span class="sc">\}</span>$. For each type of event $e$ and individual $I_k$, $k \in <span class="sc">\{</span>1,\dots N_0<span class="sc">\}</span>$, we denote by $N^{k,e}$ the counting process of intensity $\lambda_t^e (I_k,Z_t)$, counting the occurrences of the events of type $e$ happening to the individual $I_k$. Then, the first event $T_1$ is the first jump time of the multivariate counting vector $(N^{(k,e)})_{ (k,e) \in \mathcal{J}_0}$, with $\mathcal{J}_0 = <span class="sc">\{</span>1,\dots , N_0<span class="sc">\}</span>\times \big(\mathcal{E} \cup \mathcal{E}_W \big)$.</span>
<span id="cb11-604"><a href="#cb11-604" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-605"><a href="#cb11-605" aria-hidden="true" tabindex="-1"></a>Since the population composition is constant before the first event time, each counting process $N^{j}$ coincides on $[0,T_1[$ with an inhomogeneous Poisson process, of intensity $\lambda_t^e (I_k,Z_0)$. Thus (conditionally to $Z_0$), $T_1$ is also the first jump time of an inhomogeneous multivariate Poisson process $N^0 = (N^{0,j})_{j \in \mathcal{J}_0}$ of intensity function $(\lambda_j)_{j\in \mathcal J_0}$, defined for all $j = (k,e) \in \mathcal{J}_0$ by:</span>
<span id="cb11-606"><a href="#cb11-606" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-607"><a href="#cb11-607" aria-hidden="true" tabindex="-1"></a>    \lambda_j(t) = \lambda^e_t(I_k,Z_0) \le \bar \lambda^e_0 \quad \text{with} \quad \bar \lambda^e_0 = \bar \lambda^e \mathbf{1}_{e \in \mathcal{E}} + \bar W^e N_0 \mathbf{1}_{e \in \mathcal{E}_W},</span>
<span id="cb11-608"><a href="#cb11-608" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-609"><a href="#cb11-609" aria-hidden="true" tabindex="-1"></a>by @cnj-intensity1 and @cnj-intensity2. In particular, the jump times of $N^0$ occur at the intensity</span>
<span id="cb11-610"><a href="#cb11-610" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-611"><a href="#cb11-611" aria-hidden="true" tabindex="-1"></a>    \Lambda(t) =\sum_{j \in \mathcal{J}_0} \lambda_j(t)  =\sum_{e \in \mathcal{E} \cup \mathcal{E}_W} \sum_{k=1}^{N_0}  \lambda^e_t(I_k,Z_0) \leq \bar \Lambda(N_0)=N_0 \sum_{e \in \mathcal{E} \cup \mathcal{E}_W} \bar \lambda^e_0.</span>
<span id="cb11-612"><a href="#cb11-612" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-613"><a href="#cb11-613" aria-hidden="true" tabindex="-1"></a>By @prp-thinning-vector, $N^0$ can be obtained by thinning of the marked Poisson measure $\bar Q^0 = \sum_{\ell \geq 1} \delta_{(\bar T_\ell , (\bar{K}_\ell, \bar E_\ell), \bar \Theta_\ell)}$ on ${\mathbb{R}}^+\times\mathcal{J}_0 \times {\mathbb{R}}^+$, with:</span>
<span id="cb11-614"><a href="#cb11-614" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-615"><a href="#cb11-615" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$(\bar T_\ell)_{\ell \in {\mathbb{N}}^*}$ the jump times of a Poisson process of rate $\bar \Lambda(N_0)$.</span>
<span id="cb11-616"><a href="#cb11-616" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$(\bar{K}_\ell, \bar E_\ell)_{\ell \in {\mathbb{N}}^*}$ discrete *i.i.d.* random variables on $\mathcal{J}_0 = \{1,\dots , N_0\}\times \big(\mathcal{E} \cup \mathcal{E}_W \big)$, with $K_\ell$ representing the index of the chosen individual and $E_\ell$ the event type for the proposed event, such that:</span>
<span id="cb11-617"><a href="#cb11-617" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-618"><a href="#cb11-618" aria-hidden="true" tabindex="-1"></a>    \mathbb{P}( \bar  K_1 = k, \bar E_1 = e) </span>
<span id="cb11-619"><a href="#cb11-619" aria-hidden="true" tabindex="-1"></a>    = \frac{\bar \lambda^e_0 }{\bar \Lambda(N_0)}</span>
<span id="cb11-620"><a href="#cb11-620" aria-hidden="true" tabindex="-1"></a>    = \frac{1}{N_0} \frac{\bar \lambda^e_0 N_0}{\bar \Lambda(N_0)},</span>
<span id="cb11-621"><a href="#cb11-621" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-622"><a href="#cb11-622" aria-hidden="true" tabindex="-1"></a>i.e. $(\bar K_1, \bar E_1)$ are distributed as independent random variables where $\bar K_1 \sim \mathcal U(<span class="sc">\{</span>1,\dots, N_0<span class="sc">\}</span>)$ and $\bar E_1$ such that </span>
<span id="cb11-623"><a href="#cb11-623" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-624"><a href="#cb11-624" aria-hidden="true" tabindex="-1"></a>    p_e := \mathbb{P}( \bar E_1 = e)</span>
<span id="cb11-625"><a href="#cb11-625" aria-hidden="true" tabindex="-1"></a>        = \frac{\bar \lambda^e_0 N_0}{\bar \Lambda(N_0)}.</span>
<span id="cb11-626"><a href="#cb11-626" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-627"><a href="#cb11-627" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$(\bar \Theta_\ell)_{\ell \in {\mathbb{N}}^*}$ are independent uniform random variables, with $\bar \Theta_\ell \sim \mathcal{U}([0,\bar \lambda^{\bar E_\ell}]).$</span>
<span id="cb11-628"><a href="#cb11-628" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-629"><a href="#cb11-629" aria-hidden="true" tabindex="-1"></a>Since the first event is the first jump of $N^0$, by @prp-thinning-vector and @alg-thinning2, the first event time $T_1$ is the first jump time $\bar T_\ell$ of $\bar Q^0$ such that $\bar \Theta_\ell \leq \lambda^{\bar E_\ell}_{\bar T_\ell}(I_{\bar K_\ell}, Z_0)$.</span>
<span id="cb11-630"><a href="#cb11-630" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-631"><a href="#cb11-631" aria-hidden="true" tabindex="-1"></a>At $T_1 =\bar T_{\ell}$, the event $\bar E_\ell$ occurs to the individual $I_{\bar K_\ell} = (\tau^b, \infty, x)$. For instance, if $\bar E_\ell =d$, a death/exit event occurs, so that $Z_{T_1} = Z_{0} + \delta_{(\tau^b, T_1, x)} - \delta_{I_{\bar K_\ell}}$ and $N_{T_1} = N_{0}$. If $\bar E_\ell =b$ or $en$, a birth or entry event occurs, so that $N_{T_1} = N_{0} + 1$, and a new individual $I_{N_0+1}$ is added to the population, chosen as described in @tbl-event-action. </span>
<span id="cb11-632"><a href="#cb11-632" aria-hidden="true" tabindex="-1"></a>Finally, if $\bar E_\ell=s$, a swap event occurs, the population size stays constant and $I_{\bar K_\ell}$ is replaced by an individual $I_{\bar K_\ell}'$, chosen as described in @tbl-event-action.</span>
<span id="cb11-633"><a href="#cb11-633" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-634"><a href="#cb11-634" aria-hidden="true" tabindex="-1"></a>The steps for simulating the first event in the population can be iterated in order to simulate the population. At the $k$th step, the same procedure is repeated to simulate the $k$th event, starting from a population $Z_{T_{k-1}}$ of size $N_{T_{k-1}}$.</span>
<span id="cb11-635"><a href="#cb11-635" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-636"><a href="#cb11-636" aria-hidden="true" tabindex="-1"></a><span class="in">```pseudocode</span></span>
<span id="cb11-637"><a href="#cb11-637" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: alg-no-interaction</span></span>
<span id="cb11-638"><a href="#cb11-638" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-indent-size: "1.2em"</span></span>
<span id="cb11-639"><a href="#cb11-639" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-comment-delimiter: "//"</span></span>
<span id="cb11-640"><a href="#cb11-640" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-line-number: true</span></span>
<span id="cb11-641"><a href="#cb11-641" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-line-number-punc: ":"</span></span>
<span id="cb11-642"><a href="#cb11-642" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-no-end: false</span></span>
<span id="cb11-643"><a href="#cb11-643" aria-hidden="true" tabindex="-1"></a><span class="in">#| pdf-placement: "htb!"</span></span>
<span id="cb11-644"><a href="#cb11-644" aria-hidden="true" tabindex="-1"></a><span class="in">#| pdf-line-number: true</span></span>
<span id="cb11-645"><a href="#cb11-645" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-646"><a href="#cb11-646" aria-hidden="true" tabindex="-1"></a><span class="in">\begin{algorithm}</span></span>
<span id="cb11-647"><a href="#cb11-647" aria-hidden="true" tabindex="-1"></a><span class="in">\caption{IBM simulation algorithm (without events of Poissonian intensity)}</span></span>
<span id="cb11-648"><a href="#cb11-648" aria-hidden="true" tabindex="-1"></a><span class="in">\begin{algorithmic}</span></span>
<span id="cb11-649"><a href="#cb11-649" aria-hidden="true" tabindex="-1"></a><span class="in">    \State \textbf{Input:} Initial population $Z_0$, horizon $T &gt; 0$, and events described by:</span></span>
<span id="cb11-650"><a href="#cb11-650" aria-hidden="true" tabindex="-1"></a><span class="in">        \State - Intensity functions and bounds $(\lambda^e, \bar \lambda^e)$ for $e \in \mathcal{E}$ and $(W^e, \bar W^e)$ for $e \in \mathcal{E}_W$ </span></span>
<span id="cb11-651"><a href="#cb11-651" aria-hidden="true" tabindex="-1"></a><span class="in">        \State - Event action functions $\phi^e(t, I)$ for $e \in \mathcal{E} \cup \mathcal{E}_W$ (see @tbl-event-action)</span></span>
<span id="cb11-652"><a href="#cb11-652" aria-hidden="true" tabindex="-1"></a><span class="in">    \State \textbf{Output:} Population $Z_T$</span></span>
<span id="cb11-653"><a href="#cb11-653" aria-hidden="true" tabindex="-1"></a><span class="in">    \State Initialization $T_0 \longleftarrow 0$, $\bar T_0 \longleftarrow 0$</span></span>
<span id="cb11-654"><a href="#cb11-654" aria-hidden="true" tabindex="-1"></a><span class="in">    \While{$T_k &lt; T$}</span></span>
<span id="cb11-655"><a href="#cb11-655" aria-hidden="true" tabindex="-1"></a><span class="in">        \Repeat</span></span>
<span id="cb11-656"><a href="#cb11-656" aria-hidden="true" tabindex="-1"></a><span class="in">            \State increment iterative variable $\ell \longleftarrow \ell+1$</span></span>
<span id="cb11-657"><a href="#cb11-657" aria-hidden="true" tabindex="-1"></a><span class="in">            \State compute next proposed time $\bar T_{\ell} \longleftarrow \bar T_{\ell-1} + \mathcal{E}\big(\bar \Lambda(N_{T_k}) \big)$</span></span>
<span id="cb11-658"><a href="#cb11-658" aria-hidden="true" tabindex="-1"></a><span class="in">            \State draw a proposed event $\bar E_\ell \sim \mathcal{U}\{p_e\}$ with $p_e = \frac{\bar \lambda^e \mathbf{1}_{e \in \mathcal{E}} + \bar W^e N_{T_k} \mathbf{1}_{e \in \mathcal{E}_W}}{\sum_{e \in \mathcal{E}} \bar \lambda^e + \sum_{e \in \mathcal{E}_W} \bar W^e N_{T_k}}$</span></span>
<span id="cb11-659"><a href="#cb11-659" aria-hidden="true" tabindex="-1"></a><span class="in">            \State draw an individual index $\bar K_\ell \sim \mathcal{U}(\{1,\dots,N_{T_k}\})$ </span></span>
<span id="cb11-660"><a href="#cb11-660" aria-hidden="true" tabindex="-1"></a><span class="in">            \State draw $\bar \Theta_\ell \sim \mathcal{U}([0, \bar \lambda^{\bar E_\ell}])$ if $\bar E_\ell \in \mathcal{E}$ or $\bar \Theta_\ell \sim \mathcal{U}([0, \bar W^{\bar E_\ell} N_{T_k}])$ if $\bar E_\ell \in \mathcal{E}_W$</span></span>
<span id="cb11-661"><a href="#cb11-661" aria-hidden="true" tabindex="-1"></a><span class="in">        \Until{accepted event $\bar \Theta_\ell \le \lambda^{\bar E_\ell}_{\bar T_\ell}(I_{\bar K_\ell},Z_{T_{k}})$}</span></span>
<span id="cb11-662"><a href="#cb11-662" aria-hidden="true" tabindex="-1"></a><span class="in">        \State increment iterative variable $k \longleftarrow k+1$ </span></span>
<span id="cb11-663"><a href="#cb11-663" aria-hidden="true" tabindex="-1"></a><span class="in">        \State record $(T_k, E_k, I_k) \longleftarrow (\bar T_{\ell}, \bar E_\ell,  I_{\bar K_\ell})$ as accepted time, event and individual</span></span>
<span id="cb11-664"><a href="#cb11-664" aria-hidden="true" tabindex="-1"></a><span class="in">        \State update the population $Z_{T_k} = Z_{T_{k-1}} + \phi^{E_k}(T_k, I_k)$</span></span>
<span id="cb11-665"><a href="#cb11-665" aria-hidden="true" tabindex="-1"></a><span class="in">    \EndWhile</span></span>
<span id="cb11-666"><a href="#cb11-666" aria-hidden="true" tabindex="-1"></a><span class="in">\end{algorithmic}</span></span>
<span id="cb11-667"><a href="#cb11-667" aria-hidden="true" tabindex="-1"></a><span class="in">\end{algorithm}</span></span>
<span id="cb11-668"><a href="#cb11-668" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb11-669"><a href="#cb11-669" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-670"><a href="#cb11-670" aria-hidden="true" tabindex="-1"></a>::: {#thm-no-interaction}</span>
<span id="cb11-671"><a href="#cb11-671" aria-hidden="true" tabindex="-1"></a>@alg-no-interaction are exact simulations of solution of the SDE @eq-sde-eq-Z.</span>
<span id="cb11-672"><a href="#cb11-672" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb11-673"><a href="#cb11-673" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-674"><a href="#cb11-674" aria-hidden="true" tabindex="-1"></a>The proof of @thm-no-interaction is detailed in the Appendix @prf-no-interaction.</span>
<span id="cb11-675"><a href="#cb11-675" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-676"><a href="#cb11-676" aria-hidden="true" tabindex="-1"></a>::: {#rem-remvoval-dead} </span>
<span id="cb11-677"><a href="#cb11-677" aria-hidden="true" tabindex="-1"></a>The population $Z_{T_k}$ includes dead/exited individuals before the event time $T_k$. Thus, $N_{T_k} &gt; N_{T_k}^a$ is greater than the number of alive individuals at time $T_k$. When a dead individual $I_{\bar K_l}$ is drawn from the population during the rejection/acceptance phase of the algorithm, the proposed event $(\bar T_{\ell}, \bar E_\ell,  I_{\bar K_\ell})$ is automatically rejected since the event intensity is $\lambda^{\bar E_\ell}_{T_\ell}(I_{\bar K_\ell}, Z_{T_k}) = 0$ (nothing can happen to a dead individual). </span>
<span id="cb11-678"><a href="#cb11-678" aria-hidden="true" tabindex="-1"></a>This can slow down the algorithm, especially when the proportion of dead/exited individuals in the population increases. However, the computational cost of keeping dead/exited individuals in the population is much lower than the cost of removing an individual from the population at each death/exit event, which is linear in the population size.</span>
<span id="cb11-679"><a href="#cb11-679" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-680"><a href="#cb11-680" aria-hidden="true" tabindex="-1"></a>Actually, dead/exited individuals are regularly removed from the population in the <span class="in">`IBMPopSim`</span> algorithm, in order to optimize the trade-off between having to many dead individuals and removing dead individuals from the population too often. The frequency at which dead individuals are "removed from the population" can be chosen by the user, as an optional argument of the main function <span class="in">`popsim`</span> (see details in @sec-simulation). </span>
<span id="cb11-681"><a href="#cb11-681" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb11-682"><a href="#cb11-682" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-683"><a href="#cb11-683" aria-hidden="true" tabindex="-1"></a>::: {#rem-sharp-bounds}</span>
<span id="cb11-684"><a href="#cb11-684" aria-hidden="true" tabindex="-1"></a>In practice, the bounds $\bar \lambda^e$ and $\bar W^e$ should be chosen as sharp as possible. It is easy to see that conditionally to $<span class="sc">\{</span>\bar E_\ell = e, \bar T_\ell = t, \bar K_\ell = l <span class="sc">\}</span>$ the probability of accepting the event is, depending if there are interactions,</span>
<span id="cb11-685"><a href="#cb11-685" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-686"><a href="#cb11-686" aria-hidden="true" tabindex="-1"></a>    \mathbb{P}\big(\bar \Theta_\ell \le \lambda^e_t(I_l,Z_{T_k})| \mathcal{F}_{T_k}\big)</span>
<span id="cb11-687"><a href="#cb11-687" aria-hidden="true" tabindex="-1"></a>    = \frac{\lambda^e(t, I_l)}{\bar \lambda^e} \mathbf{1}_{e \in \mathcal{E}} +  \frac{\sum_{j=1}^{N_{T_k}} W^e(t, I_l, I_j)}{\bar W^e N_{T_k}} \mathbf{1}_{e \in \mathcal{E}_W}.</span>
<span id="cb11-688"><a href="#cb11-688" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-689"><a href="#cb11-689" aria-hidden="true" tabindex="-1"></a>The sharper the bounds $\bar \lambda^e$ and $\bar W^e$ are, the higher is the acceptance rate. For even sharper bounds, an alternative is to define bounds $\bar \lambda^e(I_l)$ and $\bar W^e(I_l)$ depending on the individuals' characteristics. However, the algorithm is modified and the individual $I_l$ is not chosen uniformly in the population anymore. Due to the population size, this is way more costly than choosing uniform bounds, as explained in @rem-alternate-thinning.</span>
<span id="cb11-690"><a href="#cb11-690" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb11-691"><a href="#cb11-691" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-692"><a href="#cb11-692" aria-hidden="true" tabindex="-1"></a><span class="fu">## Simulation algorithm with randomization {#sec-simulation-randomized}</span></span>
<span id="cb11-693"><a href="#cb11-693" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-694"><a href="#cb11-694" aria-hidden="true" tabindex="-1"></a>Let $e \in \cal E_W$ be an event with interactions. In order to evaluate the individual intensity $\lambda^e_t (I,Z_t) = \sum_{j=1}^{N_t} W^e(t, I,I_j)$ one must compute $W^e(t, I_l, I_j)$ for all individuals in the population. This step can be computationally costly, especially for large populations. </span>
<span id="cb11-695"><a href="#cb11-695" aria-hidden="true" tabindex="-1"></a>One way to avoid this summation is to use randomization (see also&nbsp;<span class="co">[</span><span class="ot">@FouMel04</span><span class="co">]</span> in a model without age). The randomization consists in replacing the summation by an evaluation of the interaction function $W^e$ using an individual $J$ drawn uniformly from the population.</span>
<span id="cb11-696"><a href="#cb11-696" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-697"><a href="#cb11-697" aria-hidden="true" tabindex="-1"></a>More precisely, if $J \sim \mathcal{U}(<span class="sc">\{</span>1, \dots, N_{T_k}<span class="sc">\}</span>)$ is independent of $\bar \Theta_\ell$, we have </span>
<span id="cb11-698"><a href="#cb11-698" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-699"><a href="#cb11-699" aria-hidden="true" tabindex="-1"></a>    \mathbb{P}\Big(\bar \Theta_\ell \le </span>
<span id="cb11-700"><a href="#cb11-700" aria-hidden="true" tabindex="-1"></a>    \sum_{j=1}^{N_{T_k}} W^e(t, I_l, I_j) | \mathcal{F}_{T_k} \Big)</span>
<span id="cb11-701"><a href="#cb11-701" aria-hidden="true" tabindex="-1"></a>    = \mathbb{P}\big(\bar \Theta_\ell </span>
<span id="cb11-702"><a href="#cb11-702" aria-hidden="true" tabindex="-1"></a>    \le N_{T_k} W^e(t, I_l, I_J) | \mathcal{F}_{T_k}\big).</span>
<span id="cb11-703"><a href="#cb11-703" aria-hidden="true" tabindex="-1"></a>$$ {#eq-randomized-event}</span>
<span id="cb11-704"><a href="#cb11-704" aria-hidden="true" tabindex="-1"></a>Equivalently, we can write this probability as $\mathbb{P}\big(\tilde \Theta_\ell \le W^e(t, I_l, I_J) \big)$ where $\tilde \Theta_\ell  = \frac{\bar \Theta_\ell}{N_{T_k}}\sim \mathcal{U}(<span class="co">[</span><span class="ot">0, \bar W^e</span><span class="co">]</span>)$ is independent of $J \sim \mathcal{U}(<span class="sc">\{</span>1, \dots, N_{T_k}<span class="sc">\}</span>)$.</span>
<span id="cb11-705"><a href="#cb11-705" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-706"><a href="#cb11-706" aria-hidden="true" tabindex="-1"></a>::: {#rem} </span>
<span id="cb11-707"><a href="#cb11-707" aria-hidden="true" tabindex="-1"></a>The efficiency of the randomization procedure increases with the population homogeneity. If the function $W^e$ varies little according to the individuals in the population, the randomization approach is very efficient in practice, especially when the population is large.</span>
<span id="cb11-708"><a href="#cb11-708" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb11-709"><a href="#cb11-709" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-710"><a href="#cb11-710" aria-hidden="true" tabindex="-1"></a>We now present the main algorithm implemented in the <span class="in">`popsim`</span> function of the <span class="in">`IBMPopSim`</span> package in the case where events arrive with individual intensities, but also with interactions (using randomization) and Poisson intensities. In this general case, $\bar \Lambda(n)$ is defined by @eq-def-bar-Lambda.</span>
<span id="cb11-711"><a href="#cb11-711" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-712"><a href="#cb11-712" aria-hidden="true" tabindex="-1"></a>::: {#prp-randomized}</span>
<span id="cb11-713"><a href="#cb11-713" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb11-714"><a href="#cb11-714" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-715"><a href="#cb11-715" aria-hidden="true" tabindex="-1"></a>TODO</span>
<span id="cb11-716"><a href="#cb11-716" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-717"><a href="#cb11-717" aria-hidden="true" tabindex="-1"></a><span class="fu"># Model creation and simulation with IBMPopSim {#sec-package}</span></span>
<span id="cb11-718"><a href="#cb11-718" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-719"><a href="#cb11-719" aria-hidden="true" tabindex="-1"></a>The use of the <span class="in">`IBMPopSim`</span> package is mainly done in two steps: a first model creation followed by the simulation of the population evolution. The creation of a model is itself based on two steps: the description of the population $Z_t$, as introduced in @sec-population, and the description of the events types, along with their associated intensities, as detailed in @sec-events and @sec-event-intensity.</span>
<span id="cb11-720"><a href="#cb11-720" aria-hidden="true" tabindex="-1"></a>A model is compiled by calling the <span class="in">`mk_model`</span> function, which internally uses a template mechanism to generate automatically the source code describing the model, which is subsequently compiled using the <span class="in">`Rcpp`</span> package to produce the object code.</span>
<span id="cb11-721"><a href="#cb11-721" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-722"><a href="#cb11-722" aria-hidden="true" tabindex="-1"></a>After the compilation of the model, the simulations are launched by calling the <span class="in">`popsim`</span> function. This function depends on the previously compiled model and simulates a random trajectory of the population evolution based on an initial population and on parameter values, which can change from a call to another.</span>
<span id="cb11-723"><a href="#cb11-723" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-724"><a href="#cb11-724" aria-hidden="true" tabindex="-1"></a>In this section, we take a closer look at each component of a model in <span class="in">`IBMPopSim`</span>. We also refer to the <span class="co">[</span><span class="ot">IBMPopSim website</span><span class="co">](https://daphnegiorgi.github.io/IBMPopSim/)</span> and to the <span class="in">`vignettes`</span> of the package for more details on the package and various examples of model creation.</span>
<span id="cb11-725"><a href="#cb11-725" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-726"><a href="#cb11-726" aria-hidden="true" tabindex="-1"></a><span class="fu">## Population {#sec-population}</span></span>
<span id="cb11-727"><a href="#cb11-727" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-728"><a href="#cb11-728" aria-hidden="true" tabindex="-1"></a>A population $Z$ is represented by an object of class <span class="in">`population`</span> containing a data frame where each row corresponds to an individual $I=(\tau^b, \tau^d, x)$, and which has at least two columns, <span class="in">`birth`</span> and <span class="in">`death`</span>, corresponding to the birth date $\tau^b$ and death/exit date $\tau^d$ ($\tau^d$ is set to <span class="in">`NA`</span> for alive individuals). The data frame can contain more than two columns if individuals are described by additional characteristics $x= (x_1,\dots x_n)$.</span>
<span id="cb11-729"><a href="#cb11-729" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-730"><a href="#cb11-730" aria-hidden="true" tabindex="-1"></a>If entry events can occur in the population, the population shall contain a characteristic named <span class="in">`entry`</span>. This can be done by setting the flag <span class="in">`entry=TRUE`</span> in the <span class="in">`population`</span> function, or by calling the <span class="in">`add_characteristic`</span> function on an existing population. During the simulation, the date at which an individual enters the population is automatically recorded in the variable <span class="in">`I.entry`</span>.</span>
<span id="cb11-731"><a href="#cb11-731" aria-hidden="true" tabindex="-1"></a>If exit events can occur, the population shall contain a characteristic named <span class="in">`out`</span>. This can be done by setting the flag <span class="in">`out=TRUE`</span> in the <span class="in">`population`</span> function, or by calling the <span class="in">`add_characteristic`</span> function. When an individual <span class="in">`I`</span> exits the population during the simulation, <span class="in">`I.out`</span> is set to <span class="in">`TRUE`</span> and its exit time is recorded as a "death" date.</span>
<span id="cb11-732"><a href="#cb11-732" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-733"><a href="#cb11-733" aria-hidden="true" tabindex="-1"></a>In the example below, individuals are described by their birth and death dates, as well a Boolean characteristics called male, and the <span class="in">`entry`</span> characteristic. For instance, the first individual is a female whose age at $t_0=0$ is $107$ and who was originally in the population.</span>
<span id="cb11-736"><a href="#cb11-736" aria-hidden="true" tabindex="-1"></a><span class="in">```{R}</span></span>
<span id="cb11-737"><a href="#cb11-737" aria-hidden="true" tabindex="-1"></a>pop_init <span class="ot">&lt;-</span> <span class="fu">population</span>(EW_pop_14<span class="sc">$</span>sample, <span class="at">entry=</span><span class="cn">TRUE</span>)</span>
<span id="cb11-738"><a href="#cb11-738" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(pop_init)</span>
<span id="cb11-739"><a href="#cb11-739" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb11-740"><a href="#cb11-740" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-741"><a href="#cb11-741" aria-hidden="true" tabindex="-1"></a><span class="fu">### Individual</span></span>
<span id="cb11-742"><a href="#cb11-742" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-743"><a href="#cb11-743" aria-hidden="true" tabindex="-1"></a>In the <span class="in">`C++`</span> model which is automatically generated and compiled, an individual <span class="in">`I`</span> is an object of an internal class containing some attributes (<span class="in">`birth_date`</span>, <span class="in">`death_date`</span> and the characteristics), and some methods including:</span>
<span id="cb11-744"><a href="#cb11-744" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-745"><a href="#cb11-745" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`I.age(t)`</span>: a <span class="in">`const`</span> method returning the age of an individual <span class="in">`I`</span> at time <span class="in">`t`</span>,</span>
<span id="cb11-746"><a href="#cb11-746" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`I.set_age(a, t)`</span>: a method to set the age <span class="in">`a`</span> at time <span class="in">`t`</span> of an individual <span class="in">`I`</span> (set <span class="in">`birth_date`</span> at <span class="in">`t-a`</span>),</span>
<span id="cb11-747"><a href="#cb11-747" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`I.is_dead(t)`</span>: a <span class="in">`const`</span> method returning <span class="in">`true`</span> if the individual <span class="in">`I`</span> is dead at time <span class="in">`t`</span>.</span>
<span id="cb11-748"><a href="#cb11-748" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-749"><a href="#cb11-749" aria-hidden="true" tabindex="-1"></a>::: {#rem-characteristics}</span>
<span id="cb11-750"><a href="#cb11-750" aria-hidden="true" tabindex="-1"></a>A characteristic $x_i$ must be of atomic type: <span class="in">`logical`</span>, <span class="in">`integer`</span>, <span class="in">`double`</span> or <span class="in">`character`</span>. The function <span class="in">`get_characteristic`</span> allows to easily get characteristics names and their types from a population data frame. We draw the attention to the fact that some names for characteristics are forbidden, or reserved to specific cases : this is the case for <span class="in">`birth`</span>, <span class="in">`death`</span>, <span class="in">`entry`</span>, <span class="in">`out`</span>, <span class="in">`id`</span>.</span>
<span id="cb11-751"><a href="#cb11-751" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb11-752"><a href="#cb11-752" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-753"><a href="#cb11-753" aria-hidden="true" tabindex="-1"></a><span class="fu">## Events {#sec-package-events}</span></span>
<span id="cb11-754"><a href="#cb11-754" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-755"><a href="#cb11-755" aria-hidden="true" tabindex="-1"></a>The most important step of the model creation is the events creation. The call to the function creating an event is of form</span>
<span id="cb11-758"><a href="#cb11-758" aria-hidden="true" tabindex="-1"></a><span class="in">```{R}</span></span>
<span id="cb11-759"><a href="#cb11-759" aria-hidden="true" tabindex="-1"></a><span class="co">#| eval: false </span></span>
<span id="cb11-760"><a href="#cb11-760" aria-hidden="true" tabindex="-1"></a><span class="fu">mk_event_CLASS</span>(<span class="at">type=</span><span class="st">"TYPE"</span>, <span class="at">name=</span><span class="st">"NAME"</span>, ...)</span>
<span id="cb11-761"><a href="#cb11-761" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb11-762"><a href="#cb11-762" aria-hidden="true" tabindex="-1"></a>where <span class="in">`CLASS`</span> is replaced by the class of the event intensity, described in @sec-event-intensity , and <span class="in">`type`</span> corresponds to the event type, described in Section&nbsp;@sec-events.</span>
<span id="cb11-763"><a href="#cb11-763" aria-hidden="true" tabindex="-1"></a>@tbl-intensity-classes and @tbl-event-types summarize the different possible choices for intensity classes and types of event. The optional argument <span class="in">`name`</span> gives a name to the event. If not specified, the name of the event is its type, for instance <span class="in">`death`</span>. However, a name must be specified if the model is composed of several events with the same type (for instance when there are multiple death events corresponding to different causes of death). The other arguments depend on the intensity class and on the event type.</span>
<span id="cb11-764"><a href="#cb11-764" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-765"><a href="#cb11-765" aria-hidden="true" tabindex="-1"></a>::: {#tbl-panel layout-ncol=2}</span>
<span id="cb11-766"><a href="#cb11-766" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-767"><a href="#cb11-767" aria-hidden="true" tabindex="-1"></a>Intensity class         Set               <span class="in">`CLASS`</span></span>
<span id="cb11-768"><a href="#cb11-768" aria-hidden="true" tabindex="-1"></a>----------------------- ----------------- -------------------------</span>
<span id="cb11-769"><a href="#cb11-769" aria-hidden="true" tabindex="-1"></a>Individual              $\mathcal{E}$     <span class="in">`individual`</span></span>
<span id="cb11-770"><a href="#cb11-770" aria-hidden="true" tabindex="-1"></a>Interaction             $\mathcal{E}_W$   <span class="in">`interaction`</span></span>
<span id="cb11-771"><a href="#cb11-771" aria-hidden="true" tabindex="-1"></a>Poisson                 $\mathcal{P}$     <span class="in">`poisson`</span></span>
<span id="cb11-772"><a href="#cb11-772" aria-hidden="true" tabindex="-1"></a>Inhomogeneous Poisson   $\mathcal{P}$     <span class="in">`inhomogeneous_poisson`</span></span>
<span id="cb11-773"><a href="#cb11-773" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-774"><a href="#cb11-774" aria-hidden="true" tabindex="-1"></a>: Intensity Classes {#tbl-intensity-classes}</span>
<span id="cb11-775"><a href="#cb11-775" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-776"><a href="#cb11-776" aria-hidden="true" tabindex="-1"></a>Event type   <span class="in">`TYPE`</span></span>
<span id="cb11-777"><a href="#cb11-777" aria-hidden="true" tabindex="-1"></a>------------ ---------</span>
<span id="cb11-778"><a href="#cb11-778" aria-hidden="true" tabindex="-1"></a>Birth        <span class="in">`birth`</span></span>
<span id="cb11-779"><a href="#cb11-779" aria-hidden="true" tabindex="-1"></a>Death        <span class="in">`death`</span></span>
<span id="cb11-780"><a href="#cb11-780" aria-hidden="true" tabindex="-1"></a>Entry        <span class="in">`entry`</span></span>
<span id="cb11-781"><a href="#cb11-781" aria-hidden="true" tabindex="-1"></a>Exit         <span class="in">`exit`</span></span>
<span id="cb11-782"><a href="#cb11-782" aria-hidden="true" tabindex="-1"></a>Swap         <span class="in">`swap`</span></span>
<span id="cb11-783"><a href="#cb11-783" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-784"><a href="#cb11-784" aria-hidden="true" tabindex="-1"></a>: Event Types {#tbl-event-types}</span>
<span id="cb11-785"><a href="#cb11-785" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-786"><a href="#cb11-786" aria-hidden="true" tabindex="-1"></a>Main caption</span>
<span id="cb11-787"><a href="#cb11-787" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb11-788"><a href="#cb11-788" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-789"><a href="#cb11-789" aria-hidden="true" tabindex="-1"></a>The intensity function and the kernel of an event are defined through arguments of the function <span class="in">`mk_event_CLASS`</span>. These arguments are strings composed of few lines of code. Since the model is compiled using <span class="in">`Rcpp`</span>, the code should be written in <span class="in">`C++`</span>. However, thanks to the functions/variables of the package, even the non-experienced <span class="in">`C++`</span> user can define a model quite easily. </span>
<span id="cb11-790"><a href="#cb11-790" aria-hidden="true" tabindex="-1"></a>To facilitate the implementation, the user can also define a list of **model parameters**, which can be used in the event and intensity definitions. These parameters are stored in a named list and can be of various types: atomic type, numeric vector or matrix, predefined function of one variable (<span class="in">`stepfun`</span>, <span class="in">`linfun`</span>, <span class="in">`gompertz`</span>, <span class="in">`weibull`</span>, <span class="in">`piecewise_x`</span>), piecewise functions of two variables (<span class="in">`piecewise_xy`</span>). </span>
<span id="cb11-791"><a href="#cb11-791" aria-hidden="true" tabindex="-1"></a>We refer to the <span class="in">`vignette(IBMPopSim_cpp)`</span> for more details on parameters types and basic <span class="in">`C++`</span> tools. Another advantage of the model parameters is that their value can be modified from a simulation to another without changing the model.</span>
<span id="cb11-792"><a href="#cb11-792" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-793"><a href="#cb11-793" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-794"><a href="#cb11-794" aria-hidden="true" tabindex="-1"></a><span class="fu"># Insurance portfolio {#sec-insurance-portfolio}</span></span>
<span id="cb11-795"><a href="#cb11-795" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-796"><a href="#cb11-796" aria-hidden="true" tabindex="-1"></a>TODO </span>
<span id="cb11-797"><a href="#cb11-797" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-798"><a href="#cb11-798" aria-hidden="true" tabindex="-1"></a><span class="fu"># Population with genetically variable traits {#sec-example-interaction}</span></span>
<span id="cb11-799"><a href="#cb11-799" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-800"><a href="#cb11-800" aria-hidden="true" tabindex="-1"></a>TODO</span>
<span id="cb11-801"><a href="#cb11-801" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-802"><a href="#cb11-802" aria-hidden="true" tabindex="-1"></a><span class="fu"># Appendix {.appendix .unnumbered} </span></span>
<span id="cb11-803"><a href="#cb11-803" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-804"><a href="#cb11-804" aria-hidden="true" tabindex="-1"></a><span class="fu">## Recall on Poisson random measures {#sec-recall-poisson}</span></span>
<span id="cb11-805"><a href="#cb11-805" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-806"><a href="#cb11-806" aria-hidden="true" tabindex="-1"></a>We recall below some useful properties of Poisson random measures,</span>
<span id="cb11-807"><a href="#cb11-807" aria-hidden="true" tabindex="-1"></a>mainly following Chapter&nbsp;6 of&nbsp;<span class="co">[</span><span class="ot">@Cin11</span><span class="co">]</span>. We also refer to&nbsp;<span class="co">[</span><span class="ot">@Kal17</span><span class="co">]</span> for a</span>
<span id="cb11-808"><a href="#cb11-808" aria-hidden="true" tabindex="-1"></a>more comprehensive presentation of random counting measures.</span>
<span id="cb11-809"><a href="#cb11-809" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-810"><a href="#cb11-810" aria-hidden="true" tabindex="-1"></a>::: {#def-poisson-random-measure} </span>
<span id="cb11-811"><a href="#cb11-811" aria-hidden="true" tabindex="-1"></a><span class="fu">## Poisson Random Measures</span></span>
<span id="cb11-812"><a href="#cb11-812" aria-hidden="true" tabindex="-1"></a>Let $\mu$ be a $\sigma$-finite diffuse measure on a Borel subspace $(E,\mathcal{E})$ of $({\mathbb{R}}^d, \mathcal{B}({\mathbb{R}}^d))$. A random counting measure $Q= \sum_{k\geq 1} \delta_{X_k}$ is a Poisson (counting) random measure of *mean measure* $\mu$ if</span>
<span id="cb11-813"><a href="#cb11-813" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-814"><a href="#cb11-814" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>$\forall A \in \mathcal{E}$, $Q(A)$ is a Poisson random variable with ${\mathbb{E}}<span class="co">[</span><span class="ot">Q(A)</span><span class="co">]</span>= \mu(A)$. </span>
<span id="cb11-815"><a href="#cb11-815" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>For all disjoints subsets $A_1, \dots, A_n \in \mathcal{E}$, $Q(A_1), \dots, Q(A_n)$ are independent Poisson random variables.</span>
<span id="cb11-816"><a href="#cb11-816" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb11-817"><a href="#cb11-817" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-818"><a href="#cb11-818" aria-hidden="true" tabindex="-1"></a>Let us briefly recall here some simple but useful operations on Poisson measures. In the following, $Q$ is a Poisson measure of mean measure $\mu$, unless stated otherwise.</span>
<span id="cb11-819"><a href="#cb11-819" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-820"><a href="#cb11-820" aria-hidden="true" tabindex="-1"></a>::: {#prp-restriction-poisson-measure}</span>
<span id="cb11-821"><a href="#cb11-821" aria-hidden="true" tabindex="-1"></a><span class="fu">## Restricted Poisson measure</span></span>
<span id="cb11-822"><a href="#cb11-822" aria-hidden="true" tabindex="-1"></a>If $B \in \mathcal{E}$, then, the restriction of $Q$ to $B$ defined by </span>
<span id="cb11-823"><a href="#cb11-823" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-824"><a href="#cb11-824" aria-hidden="true" tabindex="-1"></a>    Q^B = \boldsymbol{1}_B Q = \sum_{k \ge 1} \mathbf{1}_{B}(X_k) \delta_{X_k}</span>
<span id="cb11-825"><a href="#cb11-825" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-826"><a href="#cb11-826" aria-hidden="true" tabindex="-1"></a>is also a Poisson random measure, of mean measure $\mu^B = \mu(\cdot \cap B)$.</span>
<span id="cb11-827"><a href="#cb11-827" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb11-828"><a href="#cb11-828" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-829"><a href="#cb11-829" aria-hidden="true" tabindex="-1"></a>::: {#prp-proj-poisson-measure}</span>
<span id="cb11-830"><a href="#cb11-830" aria-hidden="true" tabindex="-1"></a><span class="fu">## Projection of Poisson measure</span></span>
<span id="cb11-831"><a href="#cb11-831" aria-hidden="true" tabindex="-1"></a>If $E = F_1 \times F_2$ is a product space, then the projection</span>
<span id="cb11-832"><a href="#cb11-832" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-833"><a href="#cb11-833" aria-hidden="true" tabindex="-1"></a>    Q_1(\mathrm{d}x) = \int_{F_2} Q(\mathrm{d}x , \mathrm{d}y)</span>
<span id="cb11-834"><a href="#cb11-834" aria-hidden="true" tabindex="-1"></a>$$ </span>
<span id="cb11-835"><a href="#cb11-835" aria-hidden="true" tabindex="-1"></a>is a Poisson random measure of mean measure $\mu_1 (\mathrm{d}x ) = \int_{F_2} \mu(\mathrm{d}x, \mathrm{d}y)$.</span>
<span id="cb11-836"><a href="#cb11-836" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb11-837"><a href="#cb11-837" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-838"><a href="#cb11-838" aria-hidden="true" tabindex="-1"></a><span class="fu">### Link with Poisson processes</span></span>
<span id="cb11-839"><a href="#cb11-839" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-840"><a href="#cb11-840" aria-hidden="true" tabindex="-1"></a>Let $Q= \sum_{k\geq 1} \delta_{T_k}$ a Poisson random measure on $E={\mathbb{R}}^+$ with mean measure $\mu(\mathrm{d}t) = \Lambda (t) \mathrm{d}t$ absolutely continuous with respect to the Lebesgue measure, $\mu(A) = \int_A \Lambda(t) \mathrm{d}t$. </span>
<span id="cb11-841"><a href="#cb11-841" aria-hidden="true" tabindex="-1"></a>The counting process</span>
<span id="cb11-842"><a href="#cb11-842" aria-hidden="true" tabindex="-1"></a>$(N_t)_{t \ge 0}$ defined by </span>
<span id="cb11-843"><a href="#cb11-843" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-844"><a href="#cb11-844" aria-hidden="true" tabindex="-1"></a>    N_t = Q(<span class="co">[</span><span class="ot">0,t</span><span class="co">]</span>) = \sum_{k \geq 1} \boldsymbol{1}_{<span class="sc">\{</span>T_k \leq t<span class="sc">\}</span>}, \quad \forall \; t\geq 0,</span>
<span id="cb11-845"><a href="#cb11-845" aria-hidden="true" tabindex="-1"></a>$$ {#eq-inhomogeneous-pp}</span>
<span id="cb11-846"><a href="#cb11-846" aria-hidden="true" tabindex="-1"></a>is an inhomogeneous Poisson process with intensity function (or rate) $t \mapsto \Lambda(t)$. In particular, when $\Lambda(t) \equiv c$ is a constant, $N$ is a homogeneous Poisson process with rate $c$. Assuming that the atoms are ordered $T_1&lt; T_2&lt; \dots$, we recall that the sequence $(T_{k+1}-T_k)_{k\geq 1}$ is a sequence of *i.i.d.* exponential variables of parameter $c$.</span>
<span id="cb11-847"><a href="#cb11-847" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-848"><a href="#cb11-848" aria-hidden="true" tabindex="-1"></a><span class="fu">### Marked Poisson measures on $E = {\mathbb{R}}^+ \times F$</span></span>
<span id="cb11-849"><a href="#cb11-849" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-850"><a href="#cb11-850" aria-hidden="true" tabindex="-1"></a>We are interested in the particular case when $E$ is the product space ${\mathbb{R}}^+ \times F$, with $(F,\mathcal{F})$ a Borel subspace of ${\mathbb{R}}^d$. Then, a random counting measure is defined by a random set $S =<span class="sc">\{</span> (T_k, \Theta_k ), k \geq 1<span class="sc">\}</span>$. The random variables $T_k\geq 0$ can be considered as time variables, and constitute the jump times of the random measure, while the variables $\Theta_k \in F$ represent space variables.</span>
<span id="cb11-851"><a href="#cb11-851" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-852"><a href="#cb11-852" aria-hidden="true" tabindex="-1"></a>We recall in this special case the Theorem&nbsp;VI.3.2 in&nbsp;<span class="co">[</span><span class="ot">@Cin11</span><span class="co">]</span>.</span>
<span id="cb11-853"><a href="#cb11-853" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-854"><a href="#cb11-854" aria-hidden="true" tabindex="-1"></a>::: {#prp-marked-poisson}</span>
<span id="cb11-855"><a href="#cb11-855" aria-hidden="true" tabindex="-1"></a><span class="fu">## Marked Poisson measure </span></span>
<span id="cb11-856"><a href="#cb11-856" aria-hidden="true" tabindex="-1"></a>Let $m$ be a $\sigma$--finite diffuse measure on ${\mathbb{R}}^+$, and $K$ a transition probability kernel from $({\mathbb{R}}^+,\mathcal{B}({\mathbb{R}}^+))$ into $(F, \mathcal{F})$. </span>
<span id="cb11-857"><a href="#cb11-857" aria-hidden="true" tabindex="-1"></a>Assume that the collection $(T_k)_{k \ge 1}$ forms a Poisson process $(N_t) =(\sum_{k\geq 1} \mathsf{1}_{\{T_k \leq t\}})$ with mean $m(\mathrm{d}t) =\Lambda(t) \mathrm{d}t$, and that given $(T_k)_{k \ge 1}$, the variables $\Theta_k$ are conditionally independent and have the respective distributions $K(T_k, \cdot)$.</span>
<span id="cb11-858"><a href="#cb11-858" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-859"><a href="#cb11-859" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Then, $<span class="sc">\{</span> (T_k, \Theta_k) ;\; k \ge 1\}$ forms a Poisson random measure $Q = \sum_{k\ge 1} \delta_{(T_k, \Theta_k)}$ on $({\mathbb{R}}^+ \times F, \mathcal{B}({\mathbb{R}}^+) \otimes \mathcal{F})$, called a *Marked point process* , with mean $\mu$ defined by </span>
<span id="cb11-860"><a href="#cb11-860" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-861"><a href="#cb11-861" aria-hidden="true" tabindex="-1"></a>    \mu(\mathrm{d}t, \mathrm{d}y) = \Lambda(t) \mathrm{d}t K(t, \mathrm{d}y).</span>
<span id="cb11-862"><a href="#cb11-862" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-863"><a href="#cb11-863" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-864"><a href="#cb11-864" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Reciprocally let $Q$ be a Poisson random measure of mean measure $\mu(\mathrm{d}t, \mathrm{d}y)$, admitting the following disintegration with respect to the first coordinate: $\mu(\mathrm{d}t , \mathrm{d}y) =\tilde  \Lambda(t) \mathrm{d}t \nu(t, \mathrm{d}y)$, with $\nu(t, F)&lt;\infty$. </span>
<span id="cb11-865"><a href="#cb11-865" aria-hidden="true" tabindex="-1"></a>Let $K(t, \mathrm{d}y) = \dfrac{\nu(t,\mathrm{d}y) }{\nu(t, F) }$ and $\Lambda(t) = \nu(t, F)\tilde  \Lambda(t)$. Then, $Q = \sum_{k\ge 1} \delta_{(T_k, \Theta_k)}$ is a marked Poisson measure with $(T_k,\Theta_k)_{k\in {\mathbb{N}}^*}$ defined as above. </span>
<span id="cb11-866"><a href="#cb11-866" aria-hidden="true" tabindex="-1"></a>In particular, the projection $N= (N_t)_{t\geq0}$ of the Poisson measure on the first coordinate,</span>
<span id="cb11-867"><a href="#cb11-867" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-868"><a href="#cb11-868" aria-hidden="true" tabindex="-1"></a>    N_t = Q([0,t] \times F) = \sum_{k\geq 1} \boldsymbol{1}_{[0,t] \times F} (T_k, \Theta_k)  = \sum_{k\geq 1} \boldsymbol{1}_{<span class="sc">\{</span>T_k \leq t<span class="sc">\}</span>}, \quad \forall \; t \geq 0,</span>
<span id="cb11-869"><a href="#cb11-869" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-870"><a href="#cb11-870" aria-hidden="true" tabindex="-1"></a>is an inhomogeneous Poisson process of rate $\Lambda(t)= \nu(t, F)\tilde  \Lambda(t)$.</span>
<span id="cb11-871"><a href="#cb11-871" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb11-872"><a href="#cb11-872" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-873"><a href="#cb11-873" aria-hidden="true" tabindex="-1"></a>::: {#rem}</span>
<span id="cb11-874"><a href="#cb11-874" aria-hidden="true" tabindex="-1"></a>When the transition probability kernel $K$ does not depend on the time: $K(t, A) = \nu(A)$ for some probability measure $\nu$, then the marks $(\Theta_k)_{k \ge 1}$ form an *i.i.d.* sequence with distribution $\nu$, independent of $(T_k)_{k \ge 1}$.</span>
<span id="cb11-875"><a href="#cb11-875" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb11-876"><a href="#cb11-876" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-877"><a href="#cb11-877" aria-hidden="true" tabindex="-1"></a>The preceding proposition thus yields a straight forward iterative simulation procedure for a Marked Poisson process on $<span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>\times F$ with mean measure $\mu(\mathrm{d}t, \mathrm{d}y) = c \mathrm{d}t K(t, \mathrm{d}y)$ and $c&gt;0$. The procedure is described in @alg-marked-poisson.</span>
<span id="cb11-878"><a href="#cb11-878" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-879"><a href="#cb11-879" aria-hidden="true" tabindex="-1"></a><span class="fu">## Pathwise representation of IBMs {#sec-pathwise-representation}</span></span>
<span id="cb11-880"><a href="#cb11-880" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-881"><a href="#cb11-881" aria-hidden="true" tabindex="-1"></a><span class="fu">### Notation reminder</span></span>
<span id="cb11-882"><a href="#cb11-882" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-883"><a href="#cb11-883" aria-hidden="true" tabindex="-1"></a>The population's evolution is described by the measure valued process $(Z_t)_{t\geq 0}$. Several types of events $e$ can occur to individuals denoted by $I$. In an event of type $e$ occur to the individual $I$ at time $t$, then the population state $Z_{t^-}$ is modified by $\phi^e(t,I)$. </span>
<span id="cb11-884"><a href="#cb11-884" aria-hidden="true" tabindex="-1"></a>If $e\in \mathcal{E} \cup \mathcal{E}_W$, then events of type $e$ occur with an intensity $\sum_{k=1}^{N_t} \lambda_t^e(I,Z_t)$, with $\lambda_t^e(I,Z_t)$ defined by @eq-individual-intensity. </span>
<span id="cb11-885"><a href="#cb11-885" aria-hidden="true" tabindex="-1"></a>If $e \in \mathcal{P}$, then events of type $e$ occur in the population at a Poisson intensity of $(\mu^e_t)$.</span>
<span id="cb11-886"><a href="#cb11-886" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-887"><a href="#cb11-887" aria-hidden="true" tabindex="-1"></a><span class="fu">### Proof of @thm-eq-Z {#sec-prf-thm-eq-Z} </span></span>
<span id="cb11-888"><a href="#cb11-888" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-889"><a href="#cb11-889" aria-hidden="true" tabindex="-1"></a>::: {.proof}</span>
<span id="cb11-890"><a href="#cb11-890" aria-hidden="true" tabindex="-1"></a>For ease of notation, we prove the case when $\mathcal{P} =\emptyset$ (there are no events with Poisson intensity).</span>
<span id="cb11-891"><a href="#cb11-891" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-892"><a href="#cb11-892" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Step 1. The existence of a solution to @eq-sde-eq-Z is obtained by induction. Let $Z^1$ be the unique solution the thinning equation:</span>
<span id="cb11-893"><a href="#cb11-893" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-894"><a href="#cb11-894" aria-hidden="true" tabindex="-1"></a>    Z_t^1 = Z_0 + \int_0^t \int_{ \mathcal{J}\times \mathbb R^+ }\phi^e (s , I_k)  \mathbf{1}_{\{k \leq N_{0}\} }\mathbf{1}_{\{\theta \leq \lambda_s^e(I_k, Z_{0})<span class="sc">\}</span>} Q (\mathrm{d}s,\mathrm{d}k , \mathrm{d}e, \mathrm{d}\theta ), \quad \forall  0 \leq t \leq T.</span>
<span id="cb11-895"><a href="#cb11-895" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-896"><a href="#cb11-896" aria-hidden="true" tabindex="-1"></a>Let $T_1$ be the first jump time of $Z^1$. Since $Z_{s^-}^1 = Z_{0}$ and $N_{s^-}=N_{0}$ on $<span class="co">[</span><span class="ot">0, T_1</span><span class="co">]</span>$, $Z^1$ is solution of @eq-sde-eq-Z on $<span class="co">[</span><span class="ot">0,T_1</span><span class="co">]</span>$.</span>
<span id="cb11-897"><a href="#cb11-897" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-898"><a href="#cb11-898" aria-hidden="true" tabindex="-1"></a>Let us now assume that @eq-sde-eq-Z admits a solution $Z^n$ on $<span class="co">[</span><span class="ot">0,T_n</span><span class="co">]</span>$, with $T_n$ the $n$--th event time in the population. Let $Z^{n+1}$ be the unique solution of the thinning equation:</span>
<span id="cb11-899"><a href="#cb11-899" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-900"><a href="#cb11-900" aria-hidden="true" tabindex="-1"></a>    Z^{n+1}_t  =  Z_{t\wedge T_n}^n + \int_{t\wedge T_n}^{t} \int_{ \mathcal{J}\times \mathbb R^+ }\phi^e (s , I_k)  \mathbf{1}_{\{\theta \leq \lambda_s^e(I_k, Z_{T_n}^n)\}} \mathbf{1}_{\{k \leq N_{T_n}^n <span class="sc">\}</span> }Q (\mathrm{d}s ,\mathrm{d}k , \mathrm{d}e, \mathrm{d}\theta ).</span>
<span id="cb11-901"><a href="#cb11-901" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-902"><a href="#cb11-902" aria-hidden="true" tabindex="-1"></a>First, observe that $Z^{n+1}$ coincides with $Z^n$ on $<span class="co">[</span><span class="ot">0,T_n</span><span class="co">]</span>$. Let $T_{n+1}$ be the $(n+1)$--th jump of $Z^{n+1}$. Furthermore, $Z_{s^-}^{n+1} = Z_{T_n}^n$ and $N_{s^-}^{n+1}=N_{T_n}^{n}$ on $<span class="co">[</span><span class="ot">T_n, T_{n+1}</span><span class="co">]</span>$ (nothing happens between two successive event times), $Z^{n+1}$ verifies for all $t\leq T_{n+1}$: </span>
<span id="cb11-903"><a href="#cb11-903" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb11-904"><a href="#cb11-904" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb11-905"><a href="#cb11-905" aria-hidden="true" tabindex="-1"></a>    Z^{n+1}_t  =  Z_{t\wedge T_n}^n +\int_{t\wedge T_n}^{t} \int_{ \mathcal{J}\times \mathbb R^+ }\phi^e (s , I_k)  \mathbf{1}_{\{\theta \leq \lambda_s^e(I_k, Z_{s^-}^{n+1} )\}} \mathbf{1}_{\{k \leq N_{s^-}^{n+1} <span class="sc">\}</span> }Q (\mathrm{d}s ,\mathrm{d}k , \mathrm{d}e, \mathrm{d}\theta ).</span>
<span id="cb11-906"><a href="#cb11-906" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb11-907"><a href="#cb11-907" aria-hidden="true" tabindex="-1"></a>$$ </span>
<span id="cb11-908"><a href="#cb11-908" aria-hidden="true" tabindex="-1"></a>Since, $Z^n$ is a solution of @eq-sde-eq-Z on $<span class="co">[</span><span class="ot">0,T_n</span><span class="co">]</span>$ coinciding with $Z^{n+1}$, this achieves to prove that $Z^{n+1}$ is solution of @eq-sde-eq-Z on $<span class="co">[</span><span class="ot">0,T_{n+1}</span><span class="co">]</span>$.</span>
<span id="cb11-909"><a href="#cb11-909" aria-hidden="true" tabindex="-1"></a>Finally, let $Z =\lim_{n\to \infty } Z^n$. For all $n\geq 1$, $T_n$ is the $n$--th event time of $Z$, and $Z$ is solution of @eq-sde-eq-Z on all time intervals $<span class="co">[</span><span class="ot">0,T_n\wedge T</span><span class="co">]</span>$ by construction.</span>
<span id="cb11-910"><a href="#cb11-910" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-911"><a href="#cb11-911" aria-hidden="true" tabindex="-1"></a>By @lem-non-explosion $T_n \underset{n\to \infty}{\longrightarrow} \infty$. Thus, by letting $n\to \infty$ we can conclude that $Z$ is a solution of @eq-sde-eq-Z on $<span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>$.</span>
<span id="cb11-912"><a href="#cb11-912" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-913"><a href="#cb11-913" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Step 2. Let $\tilde Z$ be a solution of @eq-sde-eq-Z. Using the same arguments than in Step 1, it is straight forward to show that $\tilde Z$ coincides with $Z^n$ on $<span class="co">[</span><span class="ot">0,T_n</span><span class="co">]</span>$, for all $n \geq 1$. Thus, $\tilde{Z} = Z$, with achieves to prove uniqueness.</span>
<span id="cb11-914"><a href="#cb11-914" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb11-915"><a href="#cb11-915" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-916"><a href="#cb11-916" aria-hidden="true" tabindex="-1"></a><span class="fu"># References {.unnumbered}</span></span>
<span id="cb11-917"><a href="#cb11-917" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-918"><a href="#cb11-918" aria-hidden="true" tabindex="-1"></a>::: {#refs}</span>
<span id="cb11-919"><a href="#cb11-919" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb11-920"><a href="#cb11-920" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-921"><a href="#cb11-921" aria-hidden="true" tabindex="-1"></a><span class="fu"># Session information {.appendix .unnumbered}</span></span>
<span id="cb11-922"><a href="#cb11-922" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-923"><a href="#cb11-923" aria-hidden="true" tabindex="-1"></a><span class="in">```{r session-info}</span></span>
<span id="cb11-924"><a href="#cb11-924" aria-hidden="true" tabindex="-1"></a><span class="in">sessionInfo()</span></span>
<span id="cb11-925"><a href="#cb11-925" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->
<script>
(function(d) {
  d.querySelectorAll(".pseudocode-container").forEach(function(el) {
    let pseudocodeOptions = {
      indentSize: el.dataset.indentSize || "1.2em",
      commentDelimiter: el.dataset.commentDelimiter || "//",
      lineNumber: el.dataset.lineNumber === "true" ? true : false,
      lineNumberPunc: el.dataset.lineNumberPunc || ":",
      noEnd: el.dataset.noEnd === "true" ? true : false,
      titlePrefix: el.dataset.algTitle || "Algorithm"
    };
    pseudocode.renderElement(el.querySelector(".pseudocode"), pseudocodeOptions);
  });
})(document);
(function(d) {
  d.querySelectorAll(".pseudocode-container").forEach(function(el) {
    titleSpan = el.querySelector(".ps-root > .ps-algorithm > .ps-line > .ps-keyword")
    titlePrefix = el.dataset.algTitle;
    titleIndex = el.dataset.chapterLevel ? el.dataset.chapterLevel + "." + el.dataset.pseudocodeIndex : el.dataset.pseudocodeIndex;
    titleSpan.innerHTML = titlePrefix + " " + titleIndex + " ";
  });
})(document);
</script>
<script>
(function(d) {
  d.querySelectorAll(".pseudocode-container").forEach(function(el) {
    let pseudocodeOptions = {
      indentSize: el.dataset.indentSize || "1.2em",
      commentDelimiter: el.dataset.commentDelimiter || "//",
      lineNumber: el.dataset.lineNumber === "true" ? true : false,
      lineNumberPunc: el.dataset.lineNumberPunc || ":",
      noEnd: el.dataset.noEnd === "true" ? true : false,
      titlePrefix: el.dataset.algTitle || "Algorithm"
    };
    pseudocode.renderElement(el.querySelector(".pseudocode"), pseudocodeOptions);
  });
})(document);
(function(d) {
  d.querySelectorAll(".pseudocode-container").forEach(function(el) {
    titleSpan = el.querySelector(".ps-root > .ps-algorithm > .ps-line > .ps-keyword")
    titlePrefix = el.dataset.algTitle;
    titleIndex = el.dataset.chapterLevel ? el.dataset.chapterLevel + "." + el.dataset.pseudocodeIndex : el.dataset.pseudocodeIndex;
    titleSpan.innerHTML = titlePrefix + " " + titleIndex + " ";
  });
})(document);
</script>




</body></html>